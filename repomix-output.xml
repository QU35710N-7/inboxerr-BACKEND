This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
alembic.ini
alembic/env.py
alembic/README
alembic/script.py.mako
app/api/router.py
app/api/v1/dependencies.py
app/api/v1/endpoints/auth.py
app/api/v1/endpoints/campaigns.py
app/api/v1/endpoints/messages.py
app/api/v1/endpoints/metrics.py
app/api/v1/endpoints/webhooks.py
app/core/config.py
app/core/events.py
app/core/exceptions.py
app/core/security.py
app/db/base.py
app/db/repositories/base.py
app/db/repositories/campaigns.py
app/db/repositories/messages.py
app/db/repositories/users.py
app/db/repositories/webhooks.py
app/db/session.py
app/main.py
app/models/base.py
app/models/campaign.py
app/models/message.py
app/models/user.py
app/models/webhook.py
app/schemas/campaign.py
app/schemas/message.py
app/schemas/user.py
app/scripts/create_admin.py
app/services/campaigns/processor.py
app/services/event_bus/bus.py
app/services/event_bus/events.py
app/services/metrics/collector.py
app/services/rate_limiter.py
app/services/sms/retry_engine.py
app/services/sms/sender.py
app/services/webhooks/manager.py
app/services/webhooks/models.py
app/utils/pagination.py
app/utils/phone.py
docker-compose.yml
Dockerfile
project_structure.md
README.md
requirements.txt
scripts/reset_db.py
scripts/seed_db.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="alembic.ini">
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
version_path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="scripts/reset_db.py">
"""
Reset the development database by deleting the current DB file,
running all Alembic migrations, and seeding initial data for testing.
"""
import sys
import os
import subprocess
from pathlib import Path

# Path to the SQLite DB file
DB_PATH = "app.db"

# Resolve project root dynamically
PROJECT_ROOT = Path(__file__).resolve().parent.parent

def reset_database() -> None:
    """
    Delete the dev database, run Alembic migrations, and seed initial data.
    This should only be used in development environments.
    """
    db_file = PROJECT_ROOT / DB_PATH
    if db_file.exists():
        db_file.unlink()
        print(f"‚úÖ Removed existing DB at {DB_PATH}")
    else:
        print("‚ÑπÔ∏è No existing DB found")

    print("üöÄ Running Alembic migrations...")
    subprocess.run(["alembic", "upgrade", "head"], check=True, cwd=PROJECT_ROOT)

    print("üå± Seeding initial data...")
    subprocess.run(
        [sys.executable, "scripts/seed_db.py"], 
        check=True, 
        cwd=PROJECT_ROOT,
        env={**os.environ, "PYTHONPATH": str(PROJECT_ROOT)}
    )

    print("‚úÖ Database reset and seeded successfully!")

if __name__ == "__main__":
    reset_database()
</file>

<file path="alembic/env.py">
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context
from app.core.config import settings
from app.db.base import Base


# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    config.set_main_option("sqlalchemy.url", settings.DATABASE_URL.replace("sqlite+aiosqlite", "sqlite"))
    url = config.get_main_option("sqlalchemy.url")
    
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # üîß Inject corrected DB URL for Alembic
    config.set_main_option("sqlalchemy.url", settings.DATABASE_URL.replace("sqlite+aiosqlite", "sqlite"))

    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="alembic/README">
Generic single-database configuration.
</file>

<file path="alembic/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade schema."""
    ${downgrades if downgrades else "pass"}
</file>

<file path="app/api/v1/dependencies.py">
"""
Dependencies for API endpoints.
"""
from fastapi import Depends, HTTPException, status, Header
from fastapi.security import OAuth2PasswordBearer
from typing import Optional, List
import jwt
from datetime import datetime, timedelta

from app.core.config import settings
from app.core.exceptions import AuthenticationError, AuthorizationError
from app.schemas.user import User, TokenData, UserRole
from app.db.repositories.users import UserRepository
from app.services.rate_limiter import RateLimiter

# OAuth2 scheme for token authentication
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_PREFIX}/auth/token")


async def get_user_repository():
    """Get user repository."""
    from app.db.session import get_repository
    return await get_repository(UserRepository)


async def get_rate_limiter():
    """Get rate limiter service."""
    return RateLimiter()


async def get_current_user(
    token: str = Depends(oauth2_scheme),
    user_repository = Depends(get_user_repository)
) -> User:
    """
    Get the current authenticated user from the JWT token.
    
    Args:
        token: JWT token from Authorization header
        user_repository: User repository for database access
        
    Returns:
        User: The authenticated user
        
    Raises:
        AuthenticationError: If the token is invalid or expired
    """
    try:
        # Decode JWT token
        payload = jwt.decode(
            token, 
            settings.SECRET_KEY, 
            algorithms=["HS256"]
        )
        token_data = TokenData(**payload)
        
        # Check if token is expired
        if token_data.exp and datetime.utcnow() > token_data.exp:
            raise AuthenticationError("Token has expired")
        
        # Get user from database
        user = await user_repository.get_by_id(token_data.sub)
        if not user:
            raise AuthenticationError("User not found")
        
        # Check if user is active
        if not user.is_active:
            raise AuthenticationError("User is inactive")
        
        return user
        
    except jwt.PyJWTError:
        raise AuthenticationError("Invalid token")


async def verify_api_key(
    api_key: str = Header(..., alias=settings.API_KEY_HEADER),
    user_repository = Depends(get_user_repository)
) -> User:
    """
    Verify API key and return the associated user.
    
    Args:
        api_key: API key from header
        user_repository: User repository for database access
        
    Returns:
        User: The authenticated user
        
    Raises:
        AuthenticationError: If the API key is invalid
    """
    try:
        # Get API key from database
        api_key_record = await user_repository.get_api_key(api_key)
        if not api_key_record:
            raise AuthenticationError("Invalid API key")
        
        # Check if API key is active
        if not api_key_record.is_active:
            raise AuthenticationError("API key is inactive")
        
        # Check if API key is expired
        if api_key_record.expires_at and datetime.utcnow() > api_key_record.expires_at:
            raise AuthenticationError("API key has expired")
        
        # Get user associated with API key
        user = await user_repository.get_by_id(api_key_record.user_id)
        if not user:
            raise AuthenticationError("User not found")
        
        # Check if user is active
        if not user.is_active:
            raise AuthenticationError("User is inactive")
        
        # Update last used timestamp
        await user_repository.update_api_key_usage(api_key)
        
        return user
        
    except Exception as e:
        if isinstance(e, AuthenticationError):
            raise
        raise AuthenticationError("API key verification failed")


async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """
    Get the current active user.
    
    Args:
        current_user: Current authenticated user
        
    Returns:
        User: The authenticated active user
        
    Raises:
        AuthenticationError: If the user is inactive
    """
    if not current_user.is_active:
        raise AuthenticationError("Inactive user")
    return current_user


async def validate_permissions(
    required_permissions: List[str],
    current_user: User = Depends(get_current_user)
) -> None:
    """
    Validate that the current user has the required permissions.
    
    Args:
        required_permissions: List of required permissions
        current_user: Current authenticated user
        
    Raises:
        AuthorizationError: If the user doesn't have the required permissions
    """
    # Admin role has all permissions
    if current_user.role == UserRole.ADMIN:
        return
    
    # TODO: Implement proper permission checking
    # For now, just verify role-based access
    if current_user.role != UserRole.API and "api" in required_permissions:
        raise AuthorizationError("Insufficient permissions")
</file>

<file path="app/api/v1/endpoints/auth.py">
"""
API endpoints for authentication.
"""
from datetime import datetime, timedelta
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, status, Body
from fastapi.security import OAuth2PasswordRequestForm

from app.core.config import settings
from app.core.exceptions import AuthenticationError, AuthorizationError, NotFoundError
from app.api.v1.dependencies import (
    get_current_user,
    get_user_repository,
    validate_permissions
)
from app.schemas.user import (
    User,
    UserCreate,
    Token,
    APIKey,
    APIKeyCreate
)
from app.core.security import (
    create_access_token,
    verify_password,
    get_password_hash
)

router = APIRouter()


@router.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    user_repository = Depends(get_user_repository)
):
    """
    OAuth2 compatible token login, get an access token for future requests.
    """
    try:
        # Authenticate user
        user = await user_repository.get_by_email(form_data.username)
        if not user:
            raise AuthenticationError("Incorrect email or password")
        
        # Verify password
        if not verify_password(form_data.password, user.hashed_password):
            raise AuthenticationError("Incorrect email or password")
        
        # Check if user is active
        if not user.is_active:
            raise AuthenticationError("Inactive user")
        
        # Create access token
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        expires_at = datetime.utcnow() + access_token_expires
        
        access_token = create_access_token(
            data={
                "sub": str(user.id),
                "role": user.role,
                "exp": expires_at
            },
            expires_delta=access_token_expires
        )
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "expires_at": expires_at
        }
        
    except AuthenticationError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )


@router.post("/register", response_model=User, status_code=status.HTTP_201_CREATED)
async def register_user(
    user_data: UserCreate,
    user_repository = Depends(get_user_repository)
):
    """
    Register a new user.
    """
    # Check if user already exists
    existing_user = await user_repository.get_by_email(user_data.email)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email already registered"
        )
    
    # Create new user
    hashed_password = get_password_hash(user_data.password)
    
    user = await user_repository.create(
        email=user_data.email,
        hashed_password=hashed_password,
        full_name=user_data.full_name,
        is_active=user_data.is_active,
        role=user_data.role
    )
    
    return user


@router.get("/me", response_model=User)
async def read_users_me(
    current_user: User = Depends(get_current_user)
):
    """
    Get current user information.
    """
    return current_user


@router.post("/keys", response_model=APIKey)
async def create_api_key(
    api_key_data: APIKeyCreate,
    current_user: User = Depends(get_current_user),
    user_repository = Depends(get_user_repository)
):
    """
    Create a new API key.
    
    This is the only time the full API key will be returned.
    """
    # Create API key
    api_key = await user_repository.create_api_key(
        user_id=current_user.id,
        name=api_key_data.name,
        expires_at=api_key_data.expires_at,
        permissions=api_key_data.permissions
    )
    
    return api_key


@router.get("/keys", response_model=List[APIKey])
async def list_api_keys(
    current_user: User = Depends(get_current_user),
    user_repository = Depends(get_user_repository)
):
    """
    List all API keys for the current user.
    
    Note: The full API key value is not returned, only the ID and metadata.
    """
    # List API keys
    api_keys = await user_repository.list_api_keys(user_id=current_user.id)
    
    # Remove sensitive information
    for key in api_keys:
        key.key = f"{key.key[:8]}..." if key.key else None
    
    return api_keys


@router.delete("/keys/{key_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_api_key(
    key_id: str,
    current_user: User = Depends(get_current_user),
    user_repository = Depends(get_user_repository)
):
    """
    Delete an API key.
    """
    # Get API key
    api_key = await user_repository.get_api_key_by_id(key_id)
    if not api_key:
        raise NotFoundError(message="API key not found")
    
    # Check ownership
    if api_key.user_id != str(current_user.id) and current_user.role != "admin":
        raise AuthorizationError(message="Not authorized to delete this API key")
    
    # Delete API key
    success = await user_repository.delete_api_key(key_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete API key"
        )
    
    return None
</file>

<file path="app/api/v1/endpoints/campaigns.py">
# app/api/v1/endpoints/campaigns.py
import csv
import io
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, UploadFile, File, Query, Path, status
from fastapi.responses import JSONResponse

from app.api.v1.dependencies import get_current_user, get_rate_limiter
from app.core.exceptions import ValidationError, NotFoundError
from app.schemas.campaign import (
    CampaignCreate,
    CampaignCreateFromCSV,
    CampaignUpdate,
    CampaignResponse,
    CampaignStatus,
    CampaignListResponse
)
from app.schemas.user import User
from app.utils.pagination import PaginationParams, paginate_response
from app.services.campaigns.processor import get_campaign_processor

router = APIRouter()


@router.post("/", response_model=CampaignResponse, status_code=status.HTTP_201_CREATED)
async def create_campaign(
    campaign: CampaignCreate,
    current_user: User = Depends(get_current_user),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Create a new campaign.
    
    This creates a campaign in draft status. Messages can be added later.
    """
    # Check rate limits
    await rate_limiter.check_rate_limit(current_user.id, "create_campaign")
    
    try:
        # Get repository
        from app.db.session import get_repository
        from app.db.repositories.campaigns import CampaignRepository
        
        campaign_repo = await get_repository(CampaignRepository)
        
        # Create campaign
        result = await campaign_repo.create_campaign(
            name=campaign.name,
            description=campaign.description,
            user_id=current_user.id,
            scheduled_start_at=campaign.scheduled_start_at,
            scheduled_end_at=campaign.scheduled_end_at,
            settings=campaign.settings
        )
        
        return result
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating campaign: {str(e)}")


@router.post("/from-csv", response_model=CampaignResponse, status_code=status.HTTP_201_CREATED)
async def create_campaign_from_csv(
    file: UploadFile = File(...),
    campaign_data: str = Query(..., description="Campaign data as JSON string"),
    delimiter: str = Query(",", description="CSV delimiter"),
    has_header: bool = Query(True, description="Whether CSV has a header row"),
    phone_column: str = Query("phone", description="Column name containing phone numbers"),
    current_user: User = Depends(get_current_user),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Create a campaign and add phone numbers from CSV.
    
    This creates a campaign and immediately adds all phone numbers from the CSV.
    The campaign will remain in draft status until explicitly started.
    """
    import json
    
    # Check rate limits
    await rate_limiter.check_rate_limit(current_user.id, "create_campaign")
    
    try:
        # Parse campaign data
        campaign_dict = json.loads(campaign_data)
        campaign_data = CampaignCreateFromCSV(**campaign_dict)
        
        # Get repositories
        from app.db.session import get_repository
        from app.db.repositories.campaigns import CampaignRepository
        
        campaign_repo = await get_repository(CampaignRepository)
        
        # Create campaign
        campaign = await campaign_repo.create_campaign(
            name=campaign_data.name,
            description=campaign_data.description,
            user_id=current_user.id,
            scheduled_start_at=campaign_data.scheduled_start_at,
            scheduled_end_at=campaign_data.scheduled_end_at,
            settings=campaign_data.settings
        )
        
        # Read CSV file
        contents = await file.read()
        csv_file = io.StringIO(contents.decode('utf-8'))
        
        # Parse CSV
        csv_reader = csv.reader(csv_file, delimiter=delimiter)
        
        # Skip header if present
        if has_header:
            header = next(csv_reader)
            try:
                phone_index = header.index(phone_column)
            except ValueError:
                raise ValidationError(
                    message=f"Column '{phone_column}' not found in CSV header",
                    details={"available_columns": header}
                )
        else:
            phone_index = 0  # Assume first column has phone numbers
        
        # Extract phone numbers
        phone_numbers = []
        for row in csv_reader:
            if row and len(row) > phone_index:
                phone = row[phone_index].strip()
                if phone:
                    phone_numbers.append(phone)
        
        if not phone_numbers:
            raise ValidationError(message="No valid phone numbers found in CSV")
        
        # Add phone numbers to campaign
        added_count = await campaign_repo.add_messages_to_campaign(
            campaign_id=campaign.id,
            phone_numbers=phone_numbers,
            message_text=campaign_data.message_template,
            user_id=current_user.id
        )
        
        # Refresh campaign
        campaign = await campaign_repo.get_by_id(campaign.id)
        
        return campaign
        
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid campaign data JSON")
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating campaign: {str(e)}")


@router.get("/", response_model=CampaignListResponse)
async def list_campaigns(
    pagination: PaginationParams = Depends(),
    status: Optional[str] = Query(None, description="Filter by campaign status"),
    current_user: User = Depends(get_current_user),
):
    """
    List campaigns for the current user.
    
    Returns a paginated list of campaigns.
    """
    try:
        # Get repository
        from app.db.session import get_repository
        from app.db.repositories.campaigns import CampaignRepository
        
        campaign_repo = await get_repository(CampaignRepository)
        
        # Get campaigns with pagination
        campaigns, total = await campaign_repo.get_campaigns_for_user(
            user_id=current_user.id,
            status=status,
            skip=pagination.skip,
            limit=pagination.limit
        )
        
        # Calculate pagination info
        total_pages = (total + pagination.limit - 1) // pagination.limit
        
        # Return paginated response
        return {
            "items": campaigns,
            "total": total,
            "page": pagination.page,
            "size": pagination.limit,
            "pages": total_pages
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error listing campaigns: {str(e)}")


@router.get("/{campaign_id}", response_model=CampaignResponse)
async def get_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
):
   """
   Get details of a specific campaign.
   """
   try:
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       
       # Get campaign
       campaign = await campaign_repo.get_by_id(campaign_id)
       if not campaign:
           raise NotFoundError(message=f"Campaign {campaign_id} not found")
       
       # Check authorization
       if campaign.user_id != current_user.id:
           raise HTTPException(status_code=403, detail="Not authorized to access this campaign")
       
       return campaign
       
   except NotFoundError as e:
       raise HTTPException(status_code=404, detail=str(e))
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error retrieving campaign: {str(e)}")


@router.put("/{campaign_id}", response_model=CampaignResponse)
async def update_campaign(
   campaign_update: CampaignUpdate,
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
):
   """
   Update campaign details.
   
   Only draft campaigns can be fully updated. Active campaigns can only have their description updated.
   """
   try:
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       
       # Get campaign
       campaign = await campaign_repo.get_by_id(campaign_id)
       if not campaign:
           raise NotFoundError(message=f"Campaign {campaign_id} not found")
       
       # Check authorization
       if campaign.user_id != current_user.id:
           raise HTTPException(status_code=403, detail="Not authorized to update this campaign")
       
       # Check if campaign can be updated
       if campaign.status != "draft" and any([
           campaign_update.scheduled_start_at is not None,
           campaign_update.scheduled_end_at is not None,
           campaign_update.name is not None
       ]):
           raise HTTPException(
               status_code=400, 
               detail="Only draft campaigns can have name or schedule updated"
           )
       
       # Convert to dict and remove None values
       update_data = {k: v for k, v in campaign_update.dict().items() if v is not None}
       
       # Update campaign
       updated = await campaign_repo.update(id=campaign_id, obj_in=update_data)
       if not updated:
           raise HTTPException(status_code=500, detail="Failed to update campaign")
       
       return updated
       
   except NotFoundError as e:
       raise HTTPException(status_code=404, detail=str(e))
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error updating campaign: {str(e)}")


@router.post("/{campaign_id}/start", response_model=CampaignResponse)
async def start_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
   campaign_processor = Depends(get_campaign_processor),
):
   """
   Start a campaign.
   
   This will change the campaign status to active and begin sending messages.
   """
   try:
       # Start campaign
       success = await campaign_processor.start_campaign(
           campaign_id=campaign_id,
           user_id=current_user.id
       )
       
       if not success:
           raise HTTPException(status_code=400, detail="Failed to start campaign")
       
       # Get updated campaign
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       campaign = await campaign_repo.get_by_id(campaign_id)
       
       return campaign
       
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error starting campaign: {str(e)}")


@router.post("/{campaign_id}/pause", response_model=CampaignResponse)
async def pause_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
   campaign_processor = Depends(get_campaign_processor),
):
   """
   Pause a campaign.
   
   This will change the campaign status to paused and stop sending messages.
   The campaign can be resumed later.
   """
   try:
       # Pause campaign
       success = await campaign_processor.pause_campaign(
           campaign_id=campaign_id,
           user_id=current_user.id
       )
       
       if not success:
           raise HTTPException(status_code=400, detail="Failed to pause campaign")
       
       # Get updated campaign
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       campaign = await campaign_repo.get_by_id(campaign_id)
       
       return campaign
       
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error pausing campaign: {str(e)}")


@router.post("/{campaign_id}/cancel", response_model=CampaignResponse)
async def cancel_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
   campaign_processor = Depends(get_campaign_processor),
):
   """
   Cancel a campaign.
   
   This will change the campaign status to cancelled and stop sending messages.
   The campaign cannot be resumed after cancellation.
   """
   try:
       # Cancel campaign
       success = await campaign_processor.cancel_campaign(
           campaign_id=campaign_id,
           user_id=current_user.id
       )
       
       if not success:
           raise HTTPException(status_code=400, detail="Failed to cancel campaign")
       
       # Get updated campaign
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       campaign = await campaign_repo.get_by_id(campaign_id)
       
       return campaign
       
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error cancelling campaign: {str(e)}")


@router.get("/{campaign_id}/messages", response_model=dict)
async def get_campaign_messages(
   campaign_id: str = Path(..., description="Campaign ID"),
   pagination: PaginationParams = Depends(),
   status: Optional[str] = Query(None, description="Filter by message status"),
   current_user: User = Depends(get_current_user),
):
   """
   Get messages for a campaign.
   
   Returns a paginated list of messages for the specified campaign.
   """
   try:
       # First check if campaign exists and belongs to user
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       from app.db.repositories.messages import MessageRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       campaign = await campaign_repo.get_by_id(campaign_id)
       
       if not campaign:
           raise NotFoundError(message=f"Campaign {campaign_id} not found")
       
       if campaign.user_id != current_user.id:
           raise HTTPException(status_code=403, detail="Not authorized to access this campaign")
       
       # Get messages for campaign
       message_repo = await get_repository(MessageRepository)
       messages, total = await message_repo.get_messages_for_campaign(
           campaign_id=campaign_id,
           status=status,
           skip=pagination.skip,
           limit=pagination.limit
       )
       
       # Return paginated response
       return paginate_response(
           items=[message.dict() for message in messages],
           total=total,
           pagination=pagination
       )
       
   except NotFoundError as e:
       raise HTTPException(status_code=404, detail=str(e))
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error retrieving campaign messages: {str(e)}")


@router.delete("/{campaign_id}", status_code=204)
async def delete_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
):
   """
   Delete a campaign.
   
   Only draft campaigns can be deleted. Active, paused, or completed campaigns cannot be deleted.
   """
   try:
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       
       # Get campaign
       campaign = await campaign_repo.get_by_id(campaign_id)
       if not campaign:
           raise NotFoundError(message=f"Campaign {campaign_id} not found")
       
       # Check authorization
       if campaign.user_id != current_user.id:
           raise HTTPException(status_code=403, detail="Not authorized to delete this campaign")
       
       # Check if campaign can be deleted
       if campaign.status != "draft":
           raise HTTPException(
               status_code=400, 
               detail="Only draft campaigns can be deleted"
           )
       
       # Delete campaign
       success = await campaign_repo.delete(id=campaign_id)
       if not success:
           raise HTTPException(status_code=500, detail="Failed to delete campaign")
       
       return JSONResponse(status_code=204, content=None)
       
   except NotFoundError as e:
       raise HTTPException(status_code=404, detail=str(e))
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error deleting campaign: {str(e)}")
</file>

<file path="app/api/v1/endpoints/messages.py">
"""
API endpoints for SMS message management.
"""
import csv
import io
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, UploadFile, File, Query, Path
from fastapi.responses import JSONResponse

from app.api.v1.dependencies import get_current_user, get_rate_limiter, verify_api_key
from app.core.exceptions import ValidationError, SMSGatewayError, NotFoundError
from app.schemas.message import (
    MessageCreate,
    MessageResponse, 
    BatchMessageRequest, 
    BatchMessageResponse,
    MessageStatus,
    MessageStatusUpdate
)
from app.services.sms.sender import get_sms_sender
from app.schemas.user import User
from app.utils.pagination import PaginationParams, paginate_response

router = APIRouter()


@router.post("/send", response_model=MessageResponse, status_code=202)
async def send_message(
    message: MessageCreate,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Send a single SMS message.
    
    - **phone_number**: Recipient phone number in E.164 format (e.g., +1234567890)
    - **message**: Content of the SMS message
    - **scheduled_at**: Optional timestamp to schedule the message for future delivery
    """
    # Check rate limits
    await rate_limiter.check_rate_limit(current_user.id, "send_message")
    
    try:
        # Send message asynchronously
        result = await sms_sender.send_message(
            phone_number=message.phone_number,
            message_text=message.message,
            user_id=current_user.id,
            scheduled_at=message.scheduled_at,
            custom_id=message.custom_id,
        )
        
        return result
        
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except SMSGatewayError as e:
        raise HTTPException(status_code=502, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error sending message: {str(e)}")


@router.post("/batch", response_model=BatchMessageResponse, status_code=202)
async def send_batch(
    batch: BatchMessageRequest,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Send a batch of SMS messages.
    
    - **messages**: List of messages to send
    - **options**: Optional batch processing options
    """
    # Check rate limits - higher limit for batch operations
    await rate_limiter.check_rate_limit(current_user.id, "send_batch")
    
    if not batch.messages:
        raise ValidationError(message="Batch contains no messages")
    
    try:
        # Process batch asynchronously
        result = await sms_sender.send_batch(
            messages=batch.messages,
            user_id=current_user.id,
            options=batch.options,
        )
        
        return result
        
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except SMSGatewayError as e:
        raise HTTPException(status_code=502, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error processing batch: {str(e)}")


@router.post("/import", status_code=202)
async def import_messages(
    file: UploadFile = File(...),
    message_template: str = Query(..., description="Message template to send"),
    delimiter: str = Query(",", description="CSV delimiter"),
    has_header: bool = Query(True, description="Whether CSV has a header row"),
    phone_column: str = Query("phone", description="Column name containing phone numbers"),
    background_tasks: BackgroundTasks = None,
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Import phone numbers from CSV and send messages.
    
    - **file**: CSV file with phone numbers
    - **message_template**: Template for the message to send
    - **delimiter**: CSV delimiter character
    - **has_header**: Whether the CSV has a header row
    - **phone_column**: Column name containing phone numbers (if has_header=True)
    """
    # Check rate limits
    await rate_limiter.check_rate_limit(current_user.id, "import_messages")
    
    try:
        # Read CSV file
        contents = await file.read()
        csv_file = io.StringIO(contents.decode('utf-8'))
        
        # Parse CSV
        csv_reader = csv.reader(csv_file, delimiter=delimiter)
        
        # Skip header if present
        if has_header:
            header = next(csv_reader)
            try:
                phone_index = header.index(phone_column)
            except ValueError:
                raise ValidationError(
                    message=f"Column '{phone_column}' not found in CSV header",
                    details={"available_columns": header}
                )
        else:
            phone_index = 0  # Assume first column has phone numbers
        
        # Extract phone numbers
        phone_numbers = []
        for row in csv_reader:
            if row and len(row) > phone_index:
                phone = row[phone_index].strip()
                if phone:
                    phone_numbers.append(phone)
        
        if not phone_numbers:
            raise ValidationError(message="No valid phone numbers found in CSV")
        
        # Process in background
        task_id = await sms_sender.schedule_batch_from_numbers(
            phone_numbers=phone_numbers,
            message_text=message_template,
            user_id=current_user.id,
        )
        
        return {
            "status": "accepted",
            "message": f"Processing {len(phone_numbers)} messages",
            "task_id": task_id,
        }
        
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error importing messages: {str(e)}")


@router.get("/{message_id}", response_model=MessageResponse)
async def get_message(
    message_id: str = Path(..., description="Message ID"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    Get details of a specific message.
    """
    try:
        message = await sms_sender.get_message(message_id, user_id=current_user.id)
        if not message:
            raise NotFoundError(message=f"Message {message_id} not found")
        return message
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving message: {str(e)}")


@router.get("/", response_model=List[MessageResponse])
async def list_messages(
    pagination: PaginationParams = Depends(),
    status: Optional[str] = Query(None, description="Filter by message status"),
    phone_number: Optional[str] = Query(None, description="Filter by phone number"),
    from_date: Optional[str] = Query(None, description="Filter from date (ISO format)"),
    to_date: Optional[str] = Query(None, description="Filter to date (ISO format)"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    List messages with optional filtering.
    
    Returns a paginated list of messages for the current user.
    """
    try:
        filters = {
            "status": status,
            "phone_number": phone_number,
            "from_date": from_date,
            "to_date": to_date,
            "user_id": current_user.id
        }
        
        # Get messages with pagination
        messages, total = await sms_sender.list_messages(
            filters=filters,
            skip=pagination.skip,
            limit=pagination.limit
        )
        
        # Return paginated response
        return paginate_response(
            items=messages,
            total=total,
            pagination=pagination
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error listing messages: {str(e)}")


@router.put("/{message_id}/status", response_model=MessageResponse)
async def update_message_status(
    status_update: MessageStatusUpdate,
    message_id: str = Path(..., description="Message ID"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    Update the status of a message.
    
    This is primarily for administrative purposes or handling external status updates.
    """
    try:
        # Verify the user has permission to update this message
        message = await sms_sender.get_message(message_id, user_id=current_user.id)
        if not message:
            raise NotFoundError(message=f"Message {message_id} not found")
        
        # Update the status
        updated_message = await sms_sender.update_message_status(
            message_id=message_id,
            status=status_update.status,
            reason=status_update.reason,
            user_id=current_user.id
        )
        
        return updated_message
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error updating message status: {str(e)}")


@router.delete("/{message_id}", status_code=204)
async def delete_message(
    message_id: str = Path(..., description="Message ID"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    Delete a message.
    
    This will only remove it from the database, but cannot recall messages already sent.
    """
    try:
        # Verify the message exists and belongs to the user
        message = await sms_sender.get_message(message_id, user_id=current_user.id)
        if not message:
            raise NotFoundError(message=f"Message {message_id} not found")
        
        # Delete the message
        success = await sms_sender.delete_message(message_id, user_id=current_user.id)
        if not success:
            raise HTTPException(status_code=500, detail="Failed to delete message")
        
        return JSONResponse(status_code=204, content=None)
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error deleting message: {str(e)}")


@router.get("/tasks/{task_id}", response_model=dict)
async def get_task_status(
    task_id: str = Path(..., description="Task ID"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    Check the status of a background task.
    
    Used for tracking progress of batch operations and imports.
    """
    try:
        task_status = await sms_sender.get_task_status(task_id, user_id=current_user.id)
        if not task_status:
            raise NotFoundError(message=f"Task {task_id} not found")
        
        return task_status
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving task status: {str(e)}")
</file>

<file path="app/core/events.py">
"""
Event handlers for application lifecycle events.
"""
import asyncio
import logging
from typing import Dict, List, Any

from app.core.config import settings
from app.services.event_bus.bus import get_event_bus
from app.services.event_bus.events import EventType

logger = logging.getLogger("inboxerr")

# Collection of background tasks to manage
background_tasks: List[asyncio.Task] = []


async def startup_event_handler() -> None:
    """
    Handle application startup.
    
    Initialize services, database connections, and start background processes.
    """
    logger.info("Starting Inboxerr Backend application")
    
    # Initialize database (async)
    try:
        # We'll implement this in the database module
        from app.db.session import initialize_database
        await initialize_database()
        logger.info("Database initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing database: {e}")
        # Don't raise error to allow startup to continue
    
    # Initialize event bus
    try:
        event_bus = get_event_bus()
        await event_bus.initialize()
        logger.info("Event bus initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing event bus: {e}")
    
    # Start retry engine if enabled
    if settings.RETRY_ENABLED:
        try:
            from app.services.sms.retry_engine import get_retry_engine
            retry_engine = await get_retry_engine()
            retry_task = asyncio.create_task(retry_engine.start())
            background_tasks.append(retry_task)
            logger.info("Retry engine started successfully")
        except Exception as e:
            logger.error(f"Error starting retry engine: {e}")
    
    # Start webhook listener if enabled
    try:
        from app.services.webhooks.manager import initialize_webhook_manager
        await initialize_webhook_manager()
        logger.info("Webhook manager initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing webhooks: {e}")
    
    # Initialize metrics collector
    try:
        from app.services.metrics.collector import initialize_metrics
        await initialize_metrics()
        logger.info("Metrics collector initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing metrics: {e}")
    
    # Log successful startup
    logger.info(f"‚úÖ {settings.PROJECT_NAME} v{settings.VERSION} startup complete")


async def shutdown_event_handler() -> None:
    """
    Handle application shutdown.
    
    Clean up resources and close connections properly.
    """
    logger.info("Shutting down Inboxerr Backend application")
    
    # Publish shutdown event
    try:
        event_bus = get_event_bus()
        await event_bus.publish(EventType.SYSTEM_SHUTDOWN, {
            "reason": "Application shutdown",
            "graceful": True
        })
        logger.info("Published shutdown event")
    except Exception as e:
        logger.error(f"Error publishing shutdown event: {e}")
    
    # Cancel all background tasks
    for task in background_tasks:
        if not task.done():
            task.cancel()
            try:
                # Wait briefly for task to cancel
                await asyncio.wait_for(task, timeout=5.0)
            except (asyncio.TimeoutError, asyncio.CancelledError):
                logger.warning(f"Task {task.get_name()} was cancelled")
    
    # Close database connections
    try:
        from app.db.session import close_database_connections
        await close_database_connections()
        logger.info("Database connections closed")
    except Exception as e:
        logger.error(f"Error closing database connections: {e}")
    
    # Shutdown webhook manager
    try:
        from app.services.webhooks.manager import shutdown_webhook_manager
        await shutdown_webhook_manager()
        logger.info("Webhook manager shutdown complete")
    except Exception as e:
        logger.error(f"Error shutting down webhook manager: {e}")
    
    logger.info("‚úÖ Application shutdown complete")
</file>

<file path="app/core/exceptions.py">
"""
Custom exception classes for Inboxerr Backend.
"""
from typing import Any, Dict, Optional


class InboxerrException(Exception):
    """Base exception class for Inboxerr application."""
    
    def __init__(
        self,
        message: str,
        code: str = "INTERNAL_ERROR",
        status_code: int = 500,
        details: Optional[Dict[str, Any]] = None,
    ):
        self.message = message
        self.code = code
        self.status_code = status_code
        self.details = details or {}
        super().__init__(message)


class AuthenticationError(InboxerrException):
    """Raised when authentication fails."""
    
    def __init__(
        self,
        message: str = "Authentication failed",
        code: str = "AUTHENTICATION_ERROR",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=401, details=details)


class AuthorizationError(InboxerrException):
    """Raised when a user doesn't have permission."""
    
    def __init__(
        self,
        message: str = "Not authorized",
        code: str = "AUTHORIZATION_ERROR",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=403, details=details)


class ValidationError(InboxerrException):
    """Raised for validation errors."""
    
    def __init__(
        self,
        message: str = "Validation error",
        code: str = "VALIDATION_ERROR",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=422, details=details)


class NotFoundError(InboxerrException):
    """Raised when a resource is not found."""
    
    def __init__(
        self,
        message: str = "Resource not found",
        code: str = "NOT_FOUND",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=404, details=details)


class SMSGatewayError(InboxerrException):
    """Raised when there's an error with the SMS gateway."""
    
    def __init__(
        self,
        message: str = "SMS Gateway error",
        code: str = "SMS_GATEWAY_ERROR",
        details: Optional[Dict[str, Any]] = None,
        status_code: int = 502,
    ):
        super().__init__(message=message, code=code, status_code=status_code, details=details)


class RetryableError(InboxerrException):
    """Error that can be retried."""
    
    def __init__(
        self,
        message: str = "Retryable error",
        code: str = "RETRYABLE_ERROR",
        details: Optional[Dict[str, Any]] = None,
        retry_after: int = 60,
    ):
        details = details or {}
        details["retry_after"] = retry_after
        super().__init__(message=message, code=code, status_code=503, details=details)


class WebhookError(InboxerrException):
    """Raised when there's an issue with webhook processing."""
    
    def __init__(
        self,
        message: str = "Webhook error",
        code: str = "WEBHOOK_ERROR",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=400, details=details)
</file>

<file path="app/core/security.py">
"""
Security utilities for authentication and authorization.
"""
from datetime import datetime, timedelta
from typing import Any, Dict, Optional, Union
import jwt
from passlib.context import CryptContext
import secrets
import string

from app.core.config import settings

# Password hashing context
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a password against a hash.
    
    Args:
        plain_password: Plain-text password
        hashed_password: Hashed password
        
    Returns:
        bool: True if password matches hash
    """
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """
    Hash a password.
    
    Args:
        password: Plain-text password
        
    Returns:
        str: Hashed password
    """
    return pwd_context.hash(password)


def create_access_token(
    data: Dict[str, Any],
    expires_delta: Optional[timedelta] = None
) -> str:
    """
    Create a JWT access token.
    
    Args:
        data: Data to encode in the token
        expires_delta: Token expiration time
        
    Returns:
        str: JWT token
    """
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    
    to_encode.update({"exp": expire})
    
    encoded_jwt = jwt.encode(
        to_encode,
        settings.SECRET_KEY,
        algorithm="HS256"
    )
    
    return encoded_jwt


def generate_api_key() -> str:
    """
    Generate a secure API key.
    
    Returns:
        str: API key
    """
    # Characters to use in API key
    alphabet = string.ascii_letters + string.digits
    
    # Generate a random string for the API key
    api_key = ''.join(secrets.choice(alphabet) for _ in range(32))
    
    # Add prefix for identification
    return f"ibx_{''.join(secrets.choice(alphabet) for _ in range(8))}_{api_key}"


def validate_api_key(api_key: str) -> bool:
    """
    Validate API key format.
    
    Args:
        api_key: API key to validate
        
    Returns:
        bool: True if format is valid
    """
    # Check format (prefix_random_key)
    parts = api_key.split('_')
    if len(parts) != 3:
        return False
    
    prefix, random_part, key = parts
    
    # Validate prefix
    if prefix != "ibx":
        return False
    
    # Validate random part length
    if len(random_part) != 8:
        return False
    
    # Validate key length
    if len(key) != 32:
        return False
    
    # Validate characters
    valid_chars = set(string.ascii_letters + string.digits)
    return all(c in valid_chars for c in random_part + key)


def generate_webhook_signing_key() -> str:
    """
    Generate a secure webhook signing key.
    
    Returns:
        str: Webhook signing key
    """
    # Generate a random string for the signing key
    return secrets.token_hex(32)  # 64 character hex string


def create_hmac_signature(payload: str, secret_key: str, timestamp: str) -> str:
    """
    Create HMAC signature for webhook payload validation.
    
    Args:
        payload: JSON payload as string
        secret_key: Secret key for signing
        timestamp: Timestamp string
        
    Returns:
        str: HMAC signature
    """
    import hmac
    import hashlib
    
    message = (payload + timestamp).encode()
    signature = hmac.new(
        secret_key.encode(),
        message,
        hashlib.sha256
    ).hexdigest()
    
    return signature


def verify_webhook_signature(
    payload: str,
    signature: str,
    secret_key: str,
    timestamp: str,
    tolerance: int = 300
) -> bool:
    """
    Verify webhook signature.
    
    Args:
        payload: JSON payload as string
        signature: Signature to verify
        secret_key: Secret key for signing
        timestamp: Timestamp used in signature
        tolerance: Timestamp tolerance in seconds
        
    Returns:
        bool: True if signature is valid
    """
    import hmac
    import time
    
    # Verify timestamp is within tolerance
    try:
        ts = int(timestamp)
        current_time = int(time.time())
        if abs(current_time - ts) > tolerance:
            return False
    except (ValueError, TypeError):
        return False
    
    # Calculate expected signature
    expected = create_hmac_signature(payload, secret_key, timestamp)
    
    # Compare signatures (constant-time comparison)
    return hmac.compare_digest(expected, signature)
</file>

<file path="app/db/base.py">
"""
Import all models here to ensure they are registered with SQLAlchemy.
"""
# Import Base
from app.models.base import Base

# Import all models
from app.models.user import User, APIKey
from app.models.campaign import Campaign
from app.models.message import Message, MessageEvent, MessageBatch, MessageTemplate
from app.models.webhook import Webhook, WebhookDelivery, WebhookEvent

# This allows alembic to auto-discover all models when creating migrations
</file>

<file path="app/db/repositories/base.py">
"""
Base repository with common database operations.
"""
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union
from uuid import uuid4

from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel
from sqlalchemy import select, update, delete
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.base import Base

# Define generic types for models
ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)


class BaseRepository(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    """
    Base repository with common CRUD operations.
    
    Generic repository pattern implementation for database access.
    """
    
    def __init__(self, session: AsyncSession, model: Type[ModelType]):
        """
        Initialize repository with session and model.
        
        Args:
            session: Database session
            model: SQLAlchemy model class
        """
        self.session = session
        self.model = model
    
    async def get_by_id(self, id: str) -> Optional[ModelType]:
        """
        Get a record by ID.
        
        Args:
            id: Record ID
            
        Returns:
            ModelType: Found record or None
        """
        query = select(self.model).where(self.model.id == id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_attribute(self, attr_name: str, attr_value: Any) -> Optional[ModelType]:
        """
        Get a record by a specific attribute.
        
        Args:
            attr_name: Attribute name
            attr_value: Attribute value
            
        Returns:
            ModelType: Found record or None
        """
        query = select(self.model).where(getattr(self.model, attr_name) == attr_value)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def list(
        self, 
        *,
        filters: Optional[Dict[str, Any]] = None,
        skip: int = 0, 
        limit: int = 100
    ) -> List[ModelType]:
        """
        Get a list of records with optional filtering.
        
        Args:
            filters: Optional filters as dict
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            List[ModelType]: List of records
        """
        query = select(self.model)
        
        # Apply filters if provided
        if filters:
            for attr_name, attr_value in filters.items():
                if hasattr(self.model, attr_name) and attr_value is not None:
                    query = query.where(getattr(self.model, attr_name) == attr_value)
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def create(self, *, obj_in: Union[CreateSchemaType, Dict[str, Any]]) -> ModelType:
        """
        Create a new record.
        
        Args:
            obj_in: Data to create record with
            
        Returns:
            ModelType: Created record
        """
        # Convert to dict if it's a Pydantic model
        obj_in_data = obj_in if isinstance(obj_in, dict) else obj_in.dict(exclude_unset=True)
        
        # Create model instance
        db_obj = self.model(**obj_in_data)
        
        # Generate ID if not provided
        if not db_obj.id:
            db_obj.id = str(uuid4())
        
        # Add to session
        self.session.add(db_obj)
        await self.session.commit()
        await self.session.refresh(db_obj)
        
        return db_obj
    
    async def update(
        self, 
        *,
        id: str,
        obj_in: Union[UpdateSchemaType, Dict[str, Any]]
    ) -> Optional[ModelType]:
        """
        Update a record.
        
        Args:
            id: Record ID
            obj_in: Data to update record with
            
        Returns:
            ModelType: Updated record or None
        """
        # Get current record
        db_obj = await self.get_by_id(id)
        if not db_obj:
            return None
        
        # Convert to dict if it's a Pydantic model
        update_data = obj_in if isinstance(obj_in, dict) else obj_in.dict(exclude_unset=True)
        
        # Remove None values
        update_data = {k: v for k, v in update_data.items() if v is not None}
        
        # Update record
        for field, value in update_data.items():
            if hasattr(db_obj, field):
                setattr(db_obj, field, value)
        
        # Save changes
        self.session.add(db_obj)
        await self.session.commit()
        await self.session.refresh(db_obj)
        
        return db_obj
    
    async def delete(self, *, id: str) -> bool:
        """
        Delete a record.
        
        Args:
            id: Record ID
            
        Returns:
            bool: True if deleted, False if not found
        """
        # Check if record exists
        db_obj = await self.get_by_id(id)
        if not db_obj:
            return False
        
        # Delete record
        await self.session.delete(db_obj)
        await self.session.commit()
        
        return True
    
    async def count(self, *, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        Count records with optional filtering.
        
        Args:
            filters: Optional filters as dict
            
        Returns:
            int: Number of records
        """
        from sqlalchemy import func
        
        query = select(func.count()).select_from(self.model)
        
        # Apply filters if provided
        if filters:
            for attr_name, attr_value in filters.items():
                if hasattr(self.model, attr_name) and attr_value is not None:
                    query = query.where(getattr(self.model, attr_name) == attr_value)
        
        result = await self.session.execute(query)
        return result.scalar_one()
</file>

<file path="app/db/repositories/campaigns.py">
# app/db/repositories/campaigns.py
from datetime import datetime
from typing import List, Optional, Dict, Any, Tuple
from uuid import uuid4

from sqlalchemy import select, update, and_, or_, desc, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.db.repositories.base import BaseRepository
from app.models.campaign import Campaign
from app.models.message import Message


class CampaignRepository(BaseRepository[Campaign, Dict[str, Any], Dict[str, Any]]):
    """Campaign repository for campaign operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with session."""
        super().__init__(session=session, model=Campaign)
    
    async def create_campaign(
        self,
        *,
        name: str,
        user_id: str,
        description: Optional[str] = None,
        scheduled_start_at: Optional[datetime] = None,
        scheduled_end_at: Optional[datetime] = None,
        settings: Optional[Dict[str, Any]] = None
    ) -> Campaign:
        """
        Create a new campaign.
        
        Args:
            name: Campaign name
            user_id: User ID
            description: Optional campaign description
            scheduled_start_at: Optional scheduled start time
            scheduled_end_at: Optional scheduled end time
            settings: Optional campaign settings
            
        Returns:
            Campaign: Created campaign
        """
        campaign = Campaign(
            id=str(uuid4()),
            name=name,
            description=description,
            status="draft",
            user_id=user_id,
            scheduled_start_at=scheduled_start_at,
            scheduled_end_at=scheduled_end_at,
            settings=settings or {}
        )
        
        self.session.add(campaign)
        await self.session.commit()
        await self.session.refresh(campaign)
        
        return campaign
    
    async def update_campaign_status(
        self,
        *,
        campaign_id: str,
        status: str,
        started_at: Optional[datetime] = None,
        completed_at: Optional[datetime] = None
    ) -> Optional[Campaign]:
        """
        Update campaign status.
        
        Args:
            campaign_id: Campaign ID
            status: New status
            started_at: Optional start timestamp
            completed_at: Optional completion timestamp
            
        Returns:
            Campaign: Updated campaign or None
        """
        campaign = await self.get_by_id(campaign_id)
        if not campaign:
            return None
        
        campaign.status = status
        
        if started_at:
            campaign.started_at = started_at
        
        if completed_at:
            campaign.completed_at = completed_at
        
        # If status is active and no start time, set it now
        if status == "active" and not campaign.started_at:
            campaign.started_at = datetime.utcnow()
        
        # If status is completed and no completion time, set it now
        if status in ["completed", "cancelled", "failed"] and not campaign.completed_at:
            campaign.completed_at = datetime.utcnow()
        
        self.session.add(campaign)
        await self.session.commit()
        await self.session.refresh(campaign)
        
        return campaign
    
    async def update_campaign_stats(
        self,
        *,
        campaign_id: str,
        increment_sent: int = 0,
        increment_delivered: int = 0,
        increment_failed: int = 0
    ) -> Optional[Campaign]:
        """
        Update campaign statistics.
        
        Args:
            campaign_id: Campaign ID
            increment_sent: Increment sent count
            increment_delivered: Increment delivered count
            increment_failed: Increment failed count
            
        Returns:
            Campaign: Updated campaign or None
        """
        campaign = await self.get_by_id(campaign_id)
        if not campaign:
            return None
        
        # Update counts
        campaign.sent_count += increment_sent
        campaign.delivered_count += increment_delivered
        campaign.failed_count += increment_failed
        
        # Check if campaign is complete
        total_processed = campaign.sent_count + campaign.failed_count
        if total_processed >= campaign.total_messages and campaign.total_messages > 0:
            campaign.status = "completed"
            campaign.completed_at = datetime.utcnow()
        
        self.session.add(campaign)
        await self.session.commit()
        await self.session.refresh(campaign)
        
        return campaign
    
    async def get_campaigns_for_user(
        self,
        *,
        user_id: str,
        status: Optional[str] = None,
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Campaign], int]:
        """
        Get campaigns for a user with optional filtering.
        
        Args:
            user_id: User ID
            status: Optional status filter
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Campaign], int]: List of campaigns and total count
        """
        # Base query
        query = select(Campaign).where(Campaign.user_id == user_id)
        count_query = select(func.count()).select_from(Campaign).where(Campaign.user_id == user_id)
        
        # Apply status filter
        if status:
            query = query.where(Campaign.status == status)
            count_query = count_query.where(Campaign.status == status)
        
        # Order by created_at desc
        query = query.order_by(desc(Campaign.created_at))
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await self.session.execute(query)
        count_result = await self.session.execute(count_query)
        
        campaigns = result.scalars().all()
        total = count_result.scalar_one()
        
        return campaigns, total
    
    async def add_messages_to_campaign(
        self,
        *,
        campaign_id: str,
        phone_numbers: List[str],
        message_text: str,
        user_id: str
    ) -> int:
        """
        Add messages to a campaign.
        
        Args:
            campaign_id: Campaign ID
            phone_numbers: List of recipient phone numbers
            message_text: Message content
            user_id: User ID
            
        Returns:
            int: Number of messages added
        """
        from app.db.repositories.messages import MessageRepository
        from app.utils.phone import validate_phone
        
        # Get campaign
        campaign = await self.get_by_id(campaign_id)
        if not campaign:
            return 0
        
        # Validate campaign belongs to user
        if campaign.user_id != user_id:
            return 0
        
        # TODO: Implement bulk insertion for better performance
        message_repo = MessageRepository(self.session)
        added_count = 0
        
        for phone in phone_numbers:
            # Basic validation
            is_valid, formatted_number, _ = validate_phone(phone)
            if is_valid:
                # Add message to campaign
                await message_repo.create_message(
                    phone_number=formatted_number,
                    message_text=message_text,
                    user_id=user_id,
                    scheduled_at=campaign.scheduled_start_at,
                    metadata={"campaign_id": campaign_id},
                    campaign_id=campaign_id  # Direct link to campaign
                )
                added_count += 1
        
        # Update campaign message count
        if added_count > 0:
            campaign.total_messages += added_count
            self.session.add(campaign)
            await self.session.commit()
        
        return added_count
</file>

<file path="app/db/repositories/users.py">
"""
User repository for database operations related to users.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import uuid4

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.security import get_password_hash, generate_api_key
from app.db.repositories.base import BaseRepository
from app.models.user import User, APIKey
from app.schemas.user import UserCreate, UserUpdate


class UserRepository(BaseRepository[User, UserCreate, UserUpdate]):
    """User repository for database operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize with session and User model."""
        super().__init__(session=session, model=User)
    
    async def get_by_email(self, email: str) -> Optional[User]:
        """
        Get a user by email.
        
        Args:
            email: User email
            
        Returns:
            User: Found user or None
        """
        return await self.get_by_attribute("email", email)
    
    async def create(
        self, 
        *,
        email: str,
        hashed_password: str,
        full_name: Optional[str] = None,
        is_active: bool = True,
        role: str = "user"
    ) -> User:
        """
        Create a new user.
        
        Args:
            email: User email
            hashed_password: Hashed password
            full_name: User's full name
            is_active: Whether the user is active
            role: User role
            
        Returns:
            User: Created user
        """
        db_obj = User(
            email=email,
            hashed_password=hashed_password,
            full_name=full_name,
            is_active=is_active,
            role=role
        )
        
        self.session.add(db_obj)
        await self.session.commit()
        await self.session.refresh(db_obj)
        
        return db_obj
    
    async def update_password(self, *, user_id: str, new_password: str) -> Optional[User]:
        """
        Update user password.
        
        Args:
            user_id: User ID
            new_password: New password (plain text)
            
        Returns:
            User: Updated user or None
        """
        # Hash the new password
        hashed_password = get_password_hash(new_password)
        
        # Update the user
        return await self.update(
            id=user_id,
            obj_in={"hashed_password": hashed_password}
        )
    
    async def create_api_key(
        self, 
        *,
        user_id: str,
        name: str,
        expires_at: Optional[datetime] = None,
        permissions: List[str] = None
    ) -> APIKey:
        """
        Create a new API key for a user.
        
        Args:
            user_id: User ID
            name: API key name
            expires_at: Expiration timestamp
            permissions: List of permissions
            
        Returns:
            APIKey: Created API key
        """
        # Generate API key
        key_value = generate_api_key()
        
        # Create API key
        api_key = APIKey(
            id=str(uuid4()),
            key=key_value,
            name=name,
            user_id=user_id,
            expires_at=expires_at,
            is_active=True,
            permissions=permissions or []
        )
        
        self.session.add(api_key)
        await self.session.commit()
        await self.session.refresh(api_key)
        
        return api_key
    
    async def get_api_key(self, key: str) -> Optional[APIKey]:
        """
        Get an API key by its value.
        
        Args:
            key: API key value
            
        Returns:
            APIKey: Found API key or None
        """
        query = select(APIKey).where(APIKey.key == key, APIKey.is_active == True)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_api_key_by_id(self, key_id: str) -> Optional[APIKey]:
        """
        Get an API key by its ID.
        
        Args:
            key_id: API key ID
            
        Returns:
            APIKey: Found API key or None
        """
        query = select(APIKey).where(APIKey.id == key_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def list_api_keys(self, user_id: str) -> List[APIKey]:
        """
        List all API keys for a user.
        
        Args:
            user_id: User ID
            
        Returns:
            List[APIKey]: List of API keys
        """
        query = select(APIKey).where(APIKey.user_id == user_id)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update_api_key_usage(self, key: str) -> bool:
        """
        Update the last_used_at timestamp for an API key.
        
        Args:
            key: API key value
            
        Returns:
            bool: True if updated, False if not found
        """
        query = update(APIKey).where(
            APIKey.key == key, 
            APIKey.is_active == True
        ).values(
            last_used_at=datetime.utcnow()
        )
        
        result = await self.session.execute(query)
        await self.session.commit()
        
        return result.rowcount > 0
    
    async def delete_api_key(self, key_id: str) -> bool:
        """
        Delete an API key.
        
        Args:
            key_id: API key ID
            
        Returns:
            bool: True if deleted, False if not found
        """
        api_key = await self.get_api_key_by_id(key_id)
        if not api_key:
            return False
            
        await self.session.delete(api_key)
        await self.session.commit()
        
        return True
    
    async def deactivate_api_key(self, key_id: str) -> bool:
        """
        Deactivate an API key without deleting it.
        
        Args:
            key_id: API key ID
            
        Returns:
            bool: True if deactivated, False if not found
        """
        api_key = await self.get_api_key_by_id(key_id)
        if not api_key:
            return False
            
        api_key.is_active = False
        self.session.add(api_key)
        await self.session.commit()
        
        return True
</file>

<file path="app/db/repositories/webhooks.py">
"""
Webhook repository for database operations related to webhooks.
"""
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import uuid4

from sqlalchemy import select, update, delete, and_, or_, desc, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.db.repositories.base import BaseRepository
from app.models.webhook import Webhook, WebhookDelivery, WebhookEvent
from app.core.security import generate_webhook_signing_key


class WebhookRepository(BaseRepository[Webhook, Dict[str, Any], Dict[str, Any]]):
    """Webhook repository for database operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize with session and Webhook model."""
        super().__init__(session=session, model=Webhook)
    
    async def create_webhook(
        self,
        *,
        name: str,
        url: str,
        event_types: List[str],
        user_id: str,
        secret_key: Optional[str] = None,
        gateway_webhook_id: Optional[str] = None
    ) -> Webhook:
        """
        Create a new webhook.
        
        Args:
            name: Webhook name
            url: Webhook URL
            event_types: List of event types to receive
            user_id: User ID
            secret_key: Optional secret key for signature validation
            gateway_webhook_id: Optional gateway webhook ID
            
        Returns:
            Webhook: Created webhook
        """
        # Generate secret key if not provided
        if not secret_key:
            secret_key = generate_webhook_signing_key()
        
        webhook = Webhook(
            id=str(uuid4()),
            name=name,
            url=url,
            event_types=event_types,
            user_id=user_id,
            secret_key=secret_key,
            gateway_webhook_id=gateway_webhook_id,
            is_active=True
        )
        
        self.session.add(webhook)
        await self.session.commit()
        await self.session.refresh(webhook)
        
        return webhook
    
    async def get_webhooks_for_event(
        self,
        *,
        event_type: str,
        user_id: Optional[str] = None
    ) -> List[Webhook]:
        """
        Get webhooks for a specific event type.
        
        Args:
            event_type: Event type
            user_id: Optional user ID to filter webhooks
            
        Returns:
            List[Webhook]: List of matching webhooks
        """
        query = select(Webhook).where(
            and_(
                Webhook.is_active == True,
                Webhook.event_types.contains([event_type])
            )
        )
        
        if user_id:
            query = query.where(Webhook.user_id == user_id)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def create_webhook_delivery(
        self,
        *,
        webhook_id: str,
        event_type: str,
        message_id: Optional[str],
        payload: Dict[str, Any],
        status_code: Optional[int] = None,
        is_success: bool = False,
        error_message: Optional[str] = None,
        retry_count: int = 0
    ) -> WebhookDelivery:
        """
        Record a webhook delivery attempt.
        
        Args:
            webhook_id: Webhook ID
            event_type: Event type
            message_id: Message ID (if applicable)
            payload: Webhook payload
            status_code: HTTP status code
            is_success: Whether delivery was successful
            error_message: Error message if failed
            retry_count: Number of retry attempts
            
        Returns:
            WebhookDelivery: Created webhook delivery record
        """
        delivery = WebhookDelivery(
            id=str(uuid4()),
            webhook_id=webhook_id,
            event_type=event_type,
            message_id=message_id,
            payload=payload,
            status_code=status_code,
            is_success=is_success,
            error_message=error_message,
            retry_count=retry_count
        )
        
        if not is_success and retry_count < 3:  # Configure max retries
            # Schedule next retry with exponential backoff
            backoff = 5 * (2 ** retry_count)  # 5, 10, 20 minutes
            delivery.next_retry_at = datetime.utcnow() + timedelta(minutes=backoff)
        
        self.session.add(delivery)
        await self.session.commit()
        await self.session.refresh(delivery)
        
        # Update webhook stats
        await self._update_webhook_stats(
            webhook_id=webhook_id,
            is_success=is_success,
            last_triggered=datetime.utcnow()
        )
        
        return delivery
    
    async def _update_webhook_stats(
        self,
        *,
        webhook_id: str,
        is_success: bool,
        last_triggered: datetime
    ) -> None:
        """
        Update webhook statistics.
        
        Args:
            webhook_id: Webhook ID
            is_success: Whether delivery was successful
            last_triggered: Timestamp of delivery attempt
        """
        webhook = await self.get_by_id(webhook_id)
        if not webhook:
            return
        
        webhook.last_triggered_at = last_triggered
        
        if is_success:
            webhook.success_count += 1
        else:
            webhook.failure_count += 1
        
        self.session.add(webhook)
        await self.session.commit()
    
    async def get_pending_retries(
        self,
        *,
        limit: int = 10
    ) -> List[WebhookDelivery]:
        """
        Get webhook deliveries pending retry.
        
        Args:
            limit: Maximum number of deliveries to return
            
        Returns:
            List[WebhookDelivery]: List of deliveries pending retry
        """
        now = datetime.utcnow()
        
        query = select(WebhookDelivery).where(
            and_(
                WebhookDelivery.is_success == False,
                WebhookDelivery.next_retry_at <= now,
                WebhookDelivery.next_retry_at.is_not(None),
                WebhookDelivery.retry_count < 3  # Configure max retries
            )
        ).order_by(WebhookDelivery.next_retry_at).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update_delivery_status(
        self,
        *,
        delivery_id: str,
        status_code: int,
        is_success: bool,
        error_message: Optional[str] = None,
        increment_retry: bool = False
    ) -> Optional[WebhookDelivery]:
        """
        Update webhook delivery status.
        
        Args:
            delivery_id: Delivery ID
            status_code: HTTP status code
            is_success: Whether delivery was successful
            error_message: Error message if failed
            increment_retry: Whether to increment retry count
            
        Returns:
            WebhookDelivery: Updated delivery record or None
        """
        delivery = await self.session.get(WebhookDelivery, delivery_id)
        if not delivery:
            return None
        
        delivery.status_code = status_code
        delivery.is_success = is_success
        delivery.error_message = error_message
        
        if increment_retry:
            delivery.retry_count += 1
        
        if not is_success and delivery.retry_count < 3:  # Configure max retries
            # Schedule next retry with exponential backoff
            backoff = 5 * (2 ** delivery.retry_count)  # 5, 10, 20 minutes
            delivery.next_retry_at = datetime.utcnow() + timedelta(minutes=backoff)
        else:
            delivery.next_retry_at = None
        
        self.session.add(delivery)
        await self.session.commit()
        await self.session.refresh(delivery)
        
        # Update webhook stats
        await self._update_webhook_stats(
            webhook_id=delivery.webhook_id,
            is_success=is_success,
            last_triggered=datetime.utcnow()
        )
        
        return delivery
    
    async def create_webhook_event(
        self,
        *,
        event_type: str,
        payload: Dict[str, Any],
        phone_number: Optional[str] = None,
        message_id: Optional[str] = None,
        gateway_message_id: Optional[str] = None
    ) -> WebhookEvent:
        """
        Record a webhook event received from SMS gateway.
        
        Args:
            event_type: Event type
            payload: Event payload
            phone_number: Phone number
            message_id: Message ID
            gateway_message_id: Gateway message ID
            
        Returns:
            WebhookEvent: Created webhook event
        """
        event = WebhookEvent(
            id=str(uuid4()),
            event_type=event_type,
            phone_number=phone_number,
            message_id=message_id,
            gateway_message_id=gateway_message_id,
            payload=payload,
            processed=False
        )
        
        self.session.add(event)
        await self.session.commit()
        await self.session.refresh(event)
        
        return event
    
    async def mark_event_processed(
        self,
        *,
        event_id: str,
        error_message: Optional[str] = None
    ) -> Optional[WebhookEvent]:
        """
        Mark a webhook event as processed.
        
        Args:
            event_id: Event ID
            error_message: Optional error message
            
        Returns:
            WebhookEvent: Updated event or None
        """
        event = await self.session.get(WebhookEvent, event_id)
        if not event:
            return None
        
        event.processed = True
        event.error_message = error_message
        
        self.session.add(event)
        await self.session.commit()
        await self.session.refresh(event)
        
        return event
    
    async def get_unprocessed_events(
        self,
        *,
        limit: int = 10
    ) -> List[WebhookEvent]:
        """
        Get unprocessed webhook events.
        
        Args:
            limit: Maximum number of events to return
            
        Returns:
            List[WebhookEvent]: List of unprocessed events
        """
        query = select(WebhookEvent).where(
            WebhookEvent.processed == False
        ).order_by(WebhookEvent.created_at).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
</file>

<file path="app/db/session.py">
"""
Database session management.
"""
import logging
from typing import AsyncGenerator, Type

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

from app.core.config import settings
from app.db.base import Base

# Create async engine
engine = create_async_engine(
    settings.DATABASE_URL,
    echo=settings.DEBUG,
    future=True
)

# Create async session factory
async_session_factory = sessionmaker(
    engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)

logger = logging.getLogger("inboxerr.db")


async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Dependency for getting async database session.
    
    Yields:
        AsyncSession: Database session
    """
    async with async_session_factory() as session:
        logger.debug("Database session created")
        try:
            yield session
            await session.commit()
            logger.debug("Database session committed")
        except Exception as e:
            await session.rollback()
            logger.error(f"Database session rolled back due to: {str(e)}")
            raise
        finally:
            await session.close()
            logger.debug("Database session closed")


async def initialize_database() -> None:
    """
    Initialize database by creating all tables.
    
    This should be called during application startup.
    """
    logger.info("Initializing database")
    async with engine.begin() as conn:
        # Create all tables
        await conn.run_sync(Base.metadata.create_all)
    logger.info("Database initialized successfully")


async def close_database_connections() -> None:
    """
    Close all database connections.
    
    This should be called during application shutdown.
    """
    logger.info("Closing database connections")
    await engine.dispose()
    logger.info("Database connections closed")


async def get_repository(repo_type: Type):
    """
    Get repository instance.
    
    Args:
        repo_type: Repository class
        
    Returns:
        Repository instance
    """
    async with async_session_factory() as session:
        return repo_type(session)
</file>

<file path="app/main.py">
"""
Main FastAPI application entry point for Inboxerr Backend.
"""
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging

from app.api.router import api_router
from app.core.config import settings
from app.core.exceptions import InboxerrException
from app.core.events import startup_event_handler, shutdown_event_handler

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger("inboxerr")

# Create FastAPI app
app = FastAPI(
    title=settings.PROJECT_NAME,
    description=settings.PROJECT_DESCRIPTION,
    version=settings.VERSION,
    docs_url="/api/docs",
    redoc_url="/api/redoc",
    openapi_url="/api/openapi.json",
)

# Set up CORS middleware
if settings.BACKEND_CORS_ORIGINS:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# Register event handlers
app.add_event_handler("startup", startup_event_handler)
app.add_event_handler("shutdown", shutdown_event_handler)

# Register exception handlers
@app.exception_handler(InboxerrException)
async def inboxerr_exception_handler(request: Request, exc: InboxerrException):
    """Custom exception handler for InboxerrException."""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "status": "error",
            "code": exc.code,
            "message": exc.message,
            "details": exc.details,
        },
    )

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Enhanced HTTP exception handler with consistent format."""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "status": "error",
            "code": f"HTTP_{exc.status_code}",
            "message": exc.detail,
            "details": None,
        },
    )

# Register routers
app.include_router(api_router, prefix=settings.API_PREFIX)

# Root endpoint
@app.get("/", tags=["Health"])
async def root():
    """Root endpoint for health checks."""
    return {
        "status": "ok",
        "service": settings.PROJECT_NAME,
        "version": settings.VERSION,
    }

if __name__ == "__main__":
    # For debugging only - use uvicorn for production
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
</file>

<file path="app/models/base.py">
"""
Base database model with common fields and methods.
"""
import uuid
from datetime import datetime
from typing import Any, Dict, Optional

from sqlalchemy import Column, DateTime, String
from sqlalchemy.ext.declarative import as_declarative, declared_attr


@as_declarative()
class Base:
    """Base class for all database models."""
    
    # Generate __tablename__ automatically from class name
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower()
    
    # Common columns for all models
    id = Column(String, primary_key=True, index=True, default=lambda: str(uuid.uuid4()))
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    def dict(self) -> Dict[str, Any]:
        """Convert model to dictionary."""
        return {c.name: getattr(self, c.name) for c in self.__table__.columns}
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Base":
        """Create model instance from dictionary."""
        return cls(**{
            k: v for k, v in data.items() 
            if k in [c.name for c in cls.__table__.columns]
        })
</file>

<file path="app/models/campaign.py">
# app/models/campaign.py
from datetime import datetime
from typing import List, Optional

from sqlalchemy import Column, String, DateTime, Boolean, JSON, Integer, ForeignKey, Text
from sqlalchemy.orm import relationship

from app.models.base import Base


class Campaign(Base):
    """Campaign model for bulk SMS messaging."""
    
    # Basic campaign information
    name = Column(String, nullable=False, index=True)
    description = Column(Text, nullable=True)
    
    # Campaign status
    status = Column(String, nullable=False, default="draft", index=True)  # draft, active, paused, completed, cancelled, failed
    
    # Campaign statistics
    total_messages = Column(Integer, default=0, nullable=False)
    sent_count = Column(Integer, default=0, nullable=False)
    delivered_count = Column(Integer, default=0, nullable=False)
    failed_count = Column(Integer, default=0, nullable=False)
    
    # Campaign configuration
    scheduled_start_at = Column(DateTime, nullable=True, index=True)
    scheduled_end_at = Column(DateTime, nullable=True)
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    
    # Campaign settings
    settings = Column(JSON, nullable=True, default=dict)  # Store campaign-specific settings
    
    # Ownership
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    
    # Relationships
    user = relationship("User")
    messages = relationship("Message", back_populates="campaign")
    
    # Helper properties
    @property
    def progress_percentage(self) -> float:
        """Calculate the campaign progress percentage."""
        if self.total_messages == 0:
            return 0
        return round((self.sent_count / self.total_messages) * 100, 2)
    
    @property
    def delivery_success_rate(self) -> float:
        """Calculate the delivery success rate."""
        if self.sent_count == 0:
            return 0
        return round((self.delivered_count / self.sent_count) * 100, 2)
</file>

<file path="app/models/user.py">
"""
Database models for user management.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any

from sqlalchemy import Boolean, Column, String, DateTime, JSON, ForeignKey
from sqlalchemy.orm import relationship

from app.models.base import Base


class User(Base):
    """User model for authentication and authorization."""
    
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    role = Column(String, default="user", nullable=False)
    
    # Relationships
    api_keys = relationship("APIKey", back_populates="user", cascade="all, delete-orphan")
    messages = relationship("Message", back_populates="user", cascade="all, delete-orphan")


class APIKey(Base):
    """API key model for API authentication."""
    
    key = Column(String, unique=True, index=True, nullable=False)
    name = Column(String, nullable=False)
    user_id = Column(String, ForeignKey("user.id"), nullable=False)
    expires_at = Column(DateTime, nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    last_used_at = Column(DateTime, nullable=True)
    permissions = Column(JSON, default=list, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="api_keys")
</file>

<file path="app/models/webhook.py">
"""
Database models for webhook management.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any

from sqlalchemy import Column, String, DateTime, Boolean, JSON, Integer, ForeignKey, Text
from sqlalchemy.orm import relationship

from app.models.base import Base


class Webhook(Base):
    """Webhook configuration model."""
    
    # Webhook configuration
    name = Column(String, nullable=False)
    url = Column(String, nullable=False)
    event_types = Column(JSON, nullable=False)  # List of event types to send
    is_active = Column(Boolean, default=True, nullable=False)
    secret_key = Column(String, nullable=True)  # For signature validation
    
    # Ownership and association
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    gateway_webhook_id = Column(String, nullable=True)  # ID from SMS gateway
    
    # Stats
    last_triggered_at = Column(DateTime, nullable=True)
    success_count = Column(Integer, default=0, nullable=False)
    failure_count = Column(Integer, default=0, nullable=False)
    
    # Relationships
    user = relationship("User")
    deliveries = relationship("WebhookDelivery", back_populates="webhook", cascade="all, delete-orphan")


class WebhookDelivery(Base):
    """Model for tracking webhook delivery attempts."""
    
    webhook_id = Column(String, ForeignKey("webhook.id"), nullable=False, index=True)
    event_type = Column(String, nullable=False, index=True)
    message_id = Column(String, ForeignKey("message.id"), nullable=True, index=True)
    payload = Column(JSON, nullable=False)
    status_code = Column(Integer, nullable=True)
    is_success = Column(Boolean, nullable=False)
    error_message = Column(String, nullable=True)
    retry_count = Column(Integer, default=0, nullable=False)
    next_retry_at = Column(DateTime, nullable=True)
    
    # Relationships
    webhook = relationship("Webhook", back_populates="deliveries")
    message = relationship("Message")


class WebhookEvent(Base):
    """Model for tracking webhook events received from SMS gateway."""
    
    event_type = Column(String, nullable=False, index=True)
    phone_number = Column(String, nullable=True, index=True)
    message_id = Column(String, nullable=True, index=True)
    gateway_message_id = Column(String, nullable=True, index=True)
    payload = Column(JSON, nullable=False)
    processed = Column(Boolean, default=False, nullable=False)
    error_message = Column(String, nullable=True)
</file>

<file path="app/schemas/campaign.py">
# app/schemas/campaign.py
from typing import List, Optional, Dict, Any
from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, Field, validator


class CampaignBase(BaseModel):
    """Base schema for campaign data."""
    name: str = Field(..., description="Campaign name")
    description: Optional[str] = Field(None, description="Campaign description")
    scheduled_start_at: Optional[datetime] = Field(None, description="Scheduled start time")
    scheduled_end_at: Optional[datetime] = Field(None, description="Scheduled end time")
    settings: Optional[Dict[str, Any]] = Field(default={}, description="Campaign settings")


class CampaignCreate(CampaignBase):
    """Schema for creating a new campaign."""
    pass


class CampaignCreateFromCSV(BaseModel):
    """Schema for creating a campaign from CSV file."""
    name: str = Field(..., description="Campaign name")
    description: Optional[str] = Field(None, description="Campaign description")
    message_template: str = Field(..., description="Message template to send")
    scheduled_start_at: Optional[datetime] = Field(None, description="Scheduled start time")
    scheduled_end_at: Optional[datetime] = Field(None, description="Scheduled end time")
    settings: Optional[Dict[str, Any]] = Field(default={}, description="Campaign settings")


class CampaignUpdate(BaseModel):
    """Schema for updating a campaign."""
    name: Optional[str] = Field(None, description="Campaign name")
    description: Optional[str] = Field(None, description="Campaign description")
    scheduled_start_at: Optional[datetime] = Field(None, description="Scheduled start time")
    scheduled_end_at: Optional[datetime] = Field(None, description="Scheduled end time")
    settings: Optional[Dict[str, Any]] = Field(None, description="Campaign settings")


class CampaignStatus(BaseModel):
    """Schema for campaign status update."""
    status: str = Field(..., description="Campaign status")
    
    @validator("status")
    def validate_status(cls, v):
        """Validate status value."""
        valid_statuses = ["draft", "active", "paused", "completed", "cancelled", "failed"]
        if v not in valid_statuses:
            raise ValueError(f"Status must be one of: {', '.join(valid_statuses)}")
        return v


class CampaignResponse(CampaignBase):
    """Schema for campaign response."""
    id: str = Field(..., description="Campaign ID")
    status: str = Field(..., description="Campaign status")
    total_messages: int = Field(..., description="Total number of messages")
    sent_count: int = Field(..., description="Number of sent messages")
    delivered_count: int = Field(..., description="Number of delivered messages")
    failed_count: int = Field(..., description="Number of failed messages")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    started_at: Optional[datetime] = Field(None, description="Start timestamp")
    completed_at: Optional[datetime] = Field(None, description="Completion timestamp")
    user_id: str = Field(..., description="User ID")
    
    # Add computed fields
    progress_percentage: float = Field(0, description="Progress percentage")
    delivery_success_rate: float = Field(0, description="Delivery success rate")
    
    class Config:
        """Pydantic config."""
        from_attributes = True


class CampaignListResponse(BaseModel):
    """Schema for campaign list response with pagination."""
    items: List[CampaignResponse]
    total: int
    page: int
    size: int
    pages: int
</file>

<file path="app/schemas/message.py">
"""
Pydantic schemas for message-related API operations.
"""
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field, validator


class MessageStatus(str, Enum):
    """Possible message statuses."""
    PENDING = "pending"
    PROCESSED = "processed"
    SENT = "sent"
    DELIVERED = "delivered"
    FAILED = "failed"
    SCHEDULED = "scheduled"
    CANCELLED = "cancelled"


class MessageCreate(BaseModel):
    """Schema for creating a new message."""
    phone_number: str = Field(..., description="Recipient phone number in E.164 format")
    message: str = Field(..., description="Message content")
    scheduled_at: Optional[datetime] = Field(None, description="Schedule message for future delivery")
    custom_id: Optional[str] = Field(None, description="Custom ID for tracking")
    
    @validator("phone_number")
    def validate_phone_number(cls, v):
        """Validate phone number format."""
        # Basic validation - will be handled more thoroughly in the service
        if not v or not (v.startswith("+") and len(v) >= 8):
            raise ValueError("Phone number must be in E.164 format (e.g. +1234567890)")
        return v
    
    @validator("message")
    def validate_message(cls, v):
        """Validate message content."""
        if not v or len(v.strip()) == 0:
            raise ValueError("Message cannot be empty")
        if len(v) > 1600:  # Allow for multi-part SMS
            raise ValueError("Message exceeds maximum length of 1600 characters")
        return v


class MessageResponse(BaseModel):
    """Schema for message response."""
    id: str = Field(..., description="Message ID")
    custom_id: Optional[str] = Field(None, description="Custom ID if provided")
    phone_number: str = Field(..., description="Recipient phone number")
    message: str = Field(..., description="Message content")
    status: MessageStatus = Field(..., description="Current message status")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    scheduled_at: Optional[datetime] = Field(None, description="Scheduled delivery time")
    sent_at: Optional[datetime] = Field(None, description="Time when message was sent")
    delivered_at: Optional[datetime] = Field(None, description="Time when message was delivered")
    failed_at: Optional[datetime] = Field(None, description="Time when message failed")
    reason: Optional[str] = Field(None, description="Failure reason if applicable")
    gateway_message_id: Optional[str] = Field(None, description="ID from SMS gateway")
    user_id: str = Field(..., description="User who sent the message")
    metadata: Optional[Dict[str, Any]] = Field(default={}, description="Additional metadata")
    
    class Config:
        """Pydantic config."""
        from_attributes = True


class MessageStatusUpdate(BaseModel):
    """Schema for updating message status."""
    status: MessageStatus = Field(..., description="New message status")
    reason: Optional[str] = Field(None, description="Reason for status change (required for FAILED)")
    
    @validator("reason")
    def validate_reason(cls, v, values):
        """Validate reason field."""
        if values.get("status") == MessageStatus.FAILED and not v:
            raise ValueError("Reason is required when status is FAILED")
        return v


class BatchOptions(BaseModel):
    """Options for batch processing."""
    delay_between_messages: Optional[float] = Field(0.3, description="Delay between messages in seconds")
    fail_on_first_error: Optional[bool] = Field(False, description="Stop processing on first error")
    retry_failed: Optional[bool] = Field(True, description="Automatically retry failed messages")


class BatchMessageRequest(BaseModel):
    """Schema for batch message request."""
    messages: List[MessageCreate] = Field(..., description="List of messages to send")
    options: Optional[BatchOptions] = Field(default=None, description="Batch processing options")
    
    @validator("messages")
    def validate_messages(cls, v):
        """Validate message list."""
        if not v:
            raise ValueError("Message list cannot be empty")
        if len(v) > 1000:
            raise ValueError("Maximum batch size is 1000 messages")
        return v


class BatchMessageResponse(BaseModel):
    """Schema for batch message response."""
    batch_id: str = Field(..., description="Batch ID for tracking")
    total: int = Field(..., description="Total number of messages in batch")
    processed: int = Field(..., description="Number of messages processed")
    successful: int = Field(..., description="Number of successful messages")
    failed: int = Field(..., description="Number of failed messages")
    status: str = Field(..., description="Overall batch status")
    created_at: datetime = Field(..., description="Batch creation timestamp")
    messages: Optional[List[MessageResponse]] = Field(None, description="List of message responses")
</file>

<file path="app/schemas/user.py">
"""
Pydantic schemas for user-related API operations.
"""
from typing import List, Optional
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field, EmailStr, validator


class UserRole(str, Enum):
    """User role enum."""
    ADMIN = "admin"
    USER = "user"
    API = "api"


class UserBase(BaseModel):
    """Base user schema."""
    email: Optional[EmailStr] = Field(None, description="User email address")
    full_name: Optional[str] = Field(None, description="User's full name")
    is_active: Optional[bool] = Field(True, description="Whether the user is active")
    role: Optional[UserRole] = Field(UserRole.USER, description="User role")


class UserCreate(UserBase):
    """Schema for creating a new user."""
    email: EmailStr = Field(..., description="User email address")
    password: str = Field(..., description="User password")
    
    @validator("password")
    def validate_password(cls, v):
        """Validate password strength."""
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(char.isdigit() for char in v):
            raise ValueError("Password must contain at least one digit")
        if not any(char.isupper() for char in v):
            raise ValueError("Password must contain at least one uppercase letter")
        return v


class UserUpdate(UserBase):
    """Schema for updating a user."""
    password: Optional[str] = Field(None, description="User password")
    
    @validator("password")
    def validate_password(cls, v):
        """Validate password if provided."""
        if v is not None:
            if len(v) < 8:
                raise ValueError("Password must be at least 8 characters long")
            if not any(char.isdigit() for char in v):
                raise ValueError("Password must contain at least one digit")
            if not any(char.isupper() for char in v):
                raise ValueError("Password must contain at least one uppercase letter")
        return v


class User(UserBase):
    """Schema for user response."""
    id: str = Field(..., description="User ID")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    
    class Config:
        """Pydantic config."""
        from_attributes = True


class UserInDB(User):
    """Schema for user in database (with hashed password)."""
    hashed_password: str = Field(..., description="Hashed password")


class Token(BaseModel):
    """Schema for authentication token."""
    access_token: str
    token_type: str = "bearer"
    expires_at: datetime


class TokenData(BaseModel):
    """Schema for token payload."""
    sub: str  # User ID
    exp: Optional[datetime] = None
    role: Optional[str] = None


class APIKey(BaseModel):
    """Schema for API key."""
    id: str = Field(..., description="API key ID")
    key: str = Field(..., description="API key")
    name: str = Field(..., description="API key name")
    user_id: str = Field(..., description="User who owns the API key")
    created_at: datetime = Field(..., description="Creation timestamp")
    expires_at: Optional[datetime] = Field(None, description="Expiration timestamp")
    is_active: bool = Field(True, description="Whether the API key is active")
    last_used_at: Optional[datetime] = Field(None, description="Last usage timestamp")
    permissions: List[str] = Field(default=[], description="List of permissions")
    
    class Config:
        """Pydantic config."""
        from_attributes = True


class APIKeyCreate(BaseModel):
    """Schema for creating a new API key."""
    name: str = Field(..., description="API key name")
    expires_at: Optional[datetime] = Field(None, description="Expiration timestamp")
    permissions: Optional[List[str]] = Field(default=[], description="List of permissions")
</file>

<file path="app/scripts/create_admin.py">
# scripts/create_admin.py
import asyncio
import sys
from pathlib import Path

# Add parent directory to path
sys.path.append(str(Path(__file__).parent.parent))

from app.db.session import async_session_factory, initialize_database
from app.db.repositories.users import UserRepository
from app.core.security import get_password_hash

async def create_admin_user():
    """Create an admin user if none exists."""
    # Initialize database
    await initialize_database()
    
    # Use session properly with context manager
    async with async_session_factory() as session:
        # Create repository with session
        user_repo = UserRepository(session)
        
        # Check if admin exists
        admin = await user_repo.get_by_email("admin@inboxerr.com")
        
        if admin:
            print("Admin user already exists")
            return
        
        # Create admin user
        password = "Admin123!"
        hashed_password = get_password_hash(password)
        
        admin = await user_repo.create(
            email="admin@inboxerr.com",
            hashed_password=hashed_password,
            full_name="Admin User",
            is_active=True,
            role="admin"
        )
        
        print(f"Admin user created with ID: {admin.id}")
        print(f"Email: admin@inboxerr.com")
        print(f"Password: {password}")

if __name__ == "__main__":
    asyncio.run(create_admin_user())
</file>

<file path="app/services/campaigns/processor.py">
# app/services/campaigns/processor.py
import asyncio
import logging
from datetime import datetime
from typing import List, Dict, Any, Optional
import uuid

from app.core.config import settings
from app.db.repositories.campaigns import CampaignRepository
from app.db.repositories.messages import MessageRepository
from app.schemas.message import MessageStatus
from app.services.event_bus.bus import get_event_bus
from app.services.event_bus.events import EventType
from app.services.sms.sender import SMSSender

logger = logging.getLogger("inboxerr.campaigns")

class CampaignProcessor:
    """
    Service for processing SMS campaigns.
    
    Manages campaign execution, chunked processing, and status tracking.
    """
    
    def __init__(
        self,
        campaign_repository: CampaignRepository,
        message_repository: MessageRepository,
        sms_sender: SMSSender,
        event_bus: Any
    ):
        """Initialize campaign processor with required dependencies."""
        self.campaign_repository = campaign_repository
        self.message_repository = message_repository
        self.sms_sender = sms_sender
        self.event_bus = event_bus
        self._processing_campaigns = set()
        self._chunk_size = settings.BATCH_SIZE  # Default from settings
        self._semaphore = asyncio.Semaphore(5)  # Limit concurrent campaigns
    
    async def start_campaign(self, campaign_id: str, user_id: str) -> bool:
        """
        Start a campaign.
        
        Args:
            campaign_id: Campaign ID
            user_id: User ID for authorization
            
        Returns:
            bool: True if campaign was started, False otherwise
        """
        # Get campaign
        campaign = await self.campaign_repository.get_by_id(campaign_id)
        if not campaign:
            return False
        
        # Validate ownership
        if campaign.user_id != user_id:
            return False
        
        # Check if campaign can be started
        if campaign.status != "draft" and campaign.status != "paused":
            return False
        
        # Update status to active
        updated = await self.campaign_repository.update_campaign_status(
            campaign_id=campaign_id,
            status="active",
            started_at=datetime.utcnow()
        )
        
        if not updated:
            return False
        
        # Start processing in background
        asyncio.create_task(self._process_campaign(campaign_id))
        
        # Publish event
        await self.event_bus.publish(
            EventType.BATCH_CREATED,
            {
                "campaign_id": campaign_id,
                "user_id": user_id,
                "total_messages": campaign.total_messages
            }
        )
        
        return True
    
    async def pause_campaign(self, campaign_id: str, user_id: str) -> bool:
        """
        Pause a campaign.
        
        Args:
            campaign_id: Campaign ID
            user_id: User ID for authorization
            
        Returns:
            bool: True if campaign was paused, False otherwise
        """
        # Get campaign
        campaign = await self.campaign_repository.get_by_id(campaign_id)
        if not campaign:
            return False
        
        # Validate ownership
        if campaign.user_id != user_id:
            return False
        
        # Check if campaign can be paused
        if campaign.status != "active":
            return False
        
        # Update status to paused
        updated = await self.campaign_repository.update_campaign_status(
            campaign_id=campaign_id,
            status="paused"
        )
        
        return updated is not None
    
    async def cancel_campaign(self, campaign_id: str, user_id: str) -> bool:
        """
        Cancel a campaign.
        
        Args:
            campaign_id: Campaign ID
            user_id: User ID for authorization
            
        Returns:
            bool: True if campaign was cancelled, False otherwise
        """
        # Get campaign
        campaign = await self.campaign_repository.get_by_id(campaign_id)
        if not campaign:
            return False
        
        # Validate ownership
        if campaign.user_id != user_id:
            return False
        
        # Check if campaign can be cancelled
        if campaign.status in ["completed", "cancelled", "failed"]:
            return False
        
        # Update status to cancelled
        updated = await self.campaign_repository.update_campaign_status(
            campaign_id=campaign_id,
            status="cancelled",
            completed_at=datetime.utcnow()
        )
        
        return updated is not None
    
    async def _process_campaign(self, campaign_id: str) -> None:
        """
        Process a campaign in the background.
        
        Args:
            campaign_id: Campaign ID
        """
        if campaign_id in self._processing_campaigns:
            logger.warning(f"Campaign {campaign_id} is already being processed")
            return
        
        # Mark as processing
        self._processing_campaigns.add(campaign_id)
        
        try:
            # Get campaign
            campaign = await self.campaign_repository.get_by_id(campaign_id)
            if not campaign or campaign.status != "active":
                return
            
            # Process in chunks until complete
            async with self._semaphore:
                await self._process_campaign_chunks(campaign)
                
        except Exception as e:
            logger.error(f"Error processing campaign {campaign_id}: {e}", exc_info=True)
            # Update campaign status to failed
            await self.campaign_repository.update_campaign_status(
                campaign_id=campaign_id,
                status="failed",
                completed_at=datetime.utcnow()
            )
        finally:
            # Remove from processing set
            self._processing_campaigns.remove(campaign_id)
    
    async def _process_campaign_chunks(self, campaign) -> None:
        """
        Process campaign messages in chunks.
        
        Args:
            campaign: Campaign object
        """
        # Query pending messages in chunks
        offset = 0
        
        while True:
            # Check if campaign is still active
            campaign = await self.campaign_repository.get_by_id(campaign.id)
            if not campaign or campaign.status != "active":
                logger.info(f"Campaign {campaign.id} is no longer active, stopping processing")
                return
            
            # Get next chunk of messages
            messages, _ = await self.message_repository.get_messages_for_campaign(
                campaign_id=campaign.id,
                status=MessageStatus.PENDING,
                skip=offset,
                limit=self._chunk_size
            )
            
            # If no more messages, campaign is complete
            if not messages:
                logger.info(f"No more pending messages for campaign {campaign.id}")
                await self.campaign_repository.update_campaign_status(
                    campaign_id=campaign.id,
                    status="completed",
                    completed_at=datetime.utcnow()
                )
                return
            
            # Process this chunk
            await self._process_message_chunk(campaign.id, messages)
            
            # Update offset for next chunk
            offset += len(messages)
            
            # Small delay between chunks to avoid overloading
            await asyncio.sleep(0.5)
    
    async def _process_message_chunk(self, campaign_id: str, messages: List[Any]) -> None:
        """
        Process a chunk of messages.
        
        Args:
            campaign_id: Campaign ID
            messages: List of message objects
        """
        # Process each message in the chunk
        success_count = 0
        fail_count = 0
        
        for message in messages:
            try:
                # Use SMS sender to send the message
                # Note: This is not optimal for bulk processing and would be improved in future versions
                result = await self.sms_sender._send_to_gateway(
                    phone_number=message.phone_number,
                    message_text=message.message,
                    custom_id=message.custom_id or str(uuid.uuid4())
                )
                
                # Update message status
                await self.message_repository.update_message_status(
                    message_id=message.id,
                    status=result.get("status", MessageStatus.PENDING),
                    event_type="campaign_process",
                    gateway_message_id=result.get("gateway_message_id"),
                    data=result
                )
                
                success_count += 1
                
                # Add delay between messages to avoid overloading gateway
                await asyncio.sleep(settings.DELAY_BETWEEN_SMS)
                
            except Exception as e:
                logger.error(f"Error processing message {message.id}: {e}")
                
                # Update message status to failed
                await self.message_repository.update_message_status(
                    message_id=message.id,
                    status=MessageStatus.FAILED,
                    event_type="campaign_process_error",
                    reason=str(e),
                    data={"error": str(e)}
                )
                
                fail_count += 1
        
        # Update campaign stats
        await self.campaign_repository.update_campaign_stats(
            campaign_id=campaign_id,
            increment_sent=success_count,
            increment_failed=fail_count
        )
        
        logger.info(f"Processed chunk for campaign {campaign_id}: {success_count} sent, {fail_count} failed")


# Dependency injection function
async def get_campaign_processor():
    """Get campaign processor service instance."""
    from app.db.session import get_repository
    from app.db.repositories.campaigns import CampaignRepository
    from app.db.repositories.messages import MessageRepository
    from app.services.event_bus.bus import get_event_bus
    from app.services.sms.sender import get_sms_sender
    
    campaign_repository = await get_repository(CampaignRepository)
    message_repository = await get_repository(MessageRepository)
    sms_sender = await get_sms_sender()
    event_bus = get_event_bus()
    
    return CampaignProcessor(
        campaign_repository=campaign_repository,
        message_repository=message_repository,
        sms_sender=sms_sender,
        event_bus=event_bus
    )
</file>

<file path="app/services/event_bus/bus.py">
"""
Event bus implementation for asynchronous messaging between components.
"""
import asyncio
import logging
from typing import Dict, List, Callable, Any, Set, Optional
from datetime import datetime

from app.services.event_bus.events import EventType

logger = logging.getLogger("inboxerr.eventbus")


class EventBus:
    """
    Event bus for asynchronous messaging between components.
    
    Supports subscription to events and publishing events.
    """
    
    def __init__(self):
        """Initialize the event bus."""
        self._subscribers: Dict[str, List[Callable]] = {}
        self._subscriber_ids: Dict[str, Set[str]] = {}
        self._lock = asyncio.Lock()
        self._initialized = False
    
    async def initialize(self) -> None:
        """Initialize the event bus."""
        if self._initialized:
            return
        
        logger.info("Initializing event bus")
        self._initialized = True
    
    async def publish(self, event_type: str, data: Dict[str, Any]) -> None:
        """
        Publish an event to subscribers.
        
        Args:
            event_type: Type of event
            data: Event data
        """
        if not self._initialized:
            await self.initialize()
        
        subscribers = []
        
        # Get subscribers with lock
        async with self._lock:
            if event_type in self._subscribers:
                subscribers = self._subscribers[event_type].copy()
        
        if not subscribers:
            logger.debug(f"No subscribers for event: {event_type}")
            return
        
        # Add timestamp if not present
        if "timestamp" not in data:
            data["timestamp"] = datetime.utcnow().isoformat()
        
        # Add event type for reference
        data["event_type"] = event_type
        
        # Execute callbacks outside of the lock
        logger.debug(f"Publishing event {event_type} to {len(subscribers)} subscribers")
        
        for callback in subscribers:
            try:
                await callback(data)
            except Exception as e:
                logger.error(f"Error in event handler for {event_type}: {e}", exc_info=True)
                # TODO: Consider adding retry logic for failed event handling
    
    async def subscribe(
        self,
        event_type: str,
        callback: Callable,
        subscriber_id: Optional[str] = None
    ) -> str:
        """
        Subscribe to an event type.
        
        Args:
            event_type: Event type to subscribe to
            callback: Function to call when event occurs
            subscriber_id: Optional subscriber ID
            
        Returns:
            str: Subscriber ID
        """
        if not self._initialized:
            await self.initialize()
        
        # Generate subscriber ID if not provided
        subscriber_id = subscriber_id or f"{callback.__module__}.{callback.__name__}"
        
        async with self._lock:
            # Initialize event type if not exists
            if event_type not in self._subscribers:
                self._subscribers[event_type] = []
                self._subscriber_ids[event_type] = set()
            
            # Add subscriber if not already subscribed
            if subscriber_id not in self._subscriber_ids[event_type]:
                self._subscribers[event_type].append(callback)
                self._subscriber_ids[event_type].add(subscriber_id)
                logger.info(f"Subscribed to {event_type}: {subscriber_id}")
            else:
                logger.debug(f"Already subscribed to {event_type}: {subscriber_id}")
        
        return subscriber_id
    
    async def unsubscribe(self, event_type: str, subscriber_id: str) -> bool:
        """
        Unsubscribe from an event type.
        
        Args:
            event_type: Event type to unsubscribe from
            subscriber_id: Subscriber ID
            
        Returns:
            bool: True if unsubscribed, False if not found
        """
        if not self._initialized:
            await self.initialize()
        
        async with self._lock:
            if event_type not in self._subscribers:
                return False
            
            if subscriber_id not in self._subscriber_ids[event_type]:
                return False
            
            # Find the index of the callback
            idx = list(self._subscriber_ids[event_type]).index(subscriber_id)
            
            # Remove the callback and ID
            self._subscribers[event_type].pop(idx)
            self._subscriber_ids[event_type].remove(subscriber_id)
            
            logger.info(f"Unsubscribed from {event_type}: {subscriber_id}")
            return True
    
    async def unsubscribe_all(self, subscriber_id: str) -> int:
        """
        Unsubscribe from all event types.
        
        Args:
            subscriber_id: Subscriber ID
            
        Returns:
            int: Number of subscriptions removed
        """
        if not self._initialized:
            await self.initialize()
        
        count = 0
        
        async with self._lock:
            for event_type in list(self._subscribers.keys()):
                if subscriber_id in self._subscriber_ids[event_type]:
                    # Find the index of the callback
                    idx = list(self._subscriber_ids[event_type]).index(subscriber_id)
                    
                    # Remove the callback and ID
                    self._subscribers[event_type].pop(idx)
                    self._subscriber_ids[event_type].remove(subscriber_id)
                    count += 1
        
        if count > 0:
            logger.info(f"Unsubscribed {subscriber_id} from {count} event types")
        
        return count
    
    def get_subscriber_count(self, event_type: Optional[str] = None) -> int:
        """
        Get the number of subscribers.
        
        Args:
            event_type: Optional event type to count subscribers for
            
        Returns:
            int: Number of subscribers
        """
        if event_type:
            return len(self._subscribers.get(event_type, []))
        else:
            return sum(len(subscribers) for subscribers in self._subscribers.values())


# Singleton instance
_event_bus = EventBus()

def get_event_bus() -> EventBus:
    """Get the singleton event bus instance."""
    return _event_bus
</file>

<file path="app/services/rate_limiter.py">
"""
Rate limiting service for API request throttling.
"""
import asyncio
import time
from typing import Dict, Any, Optional, Tuple
import logging
from datetime import datetime

from app.core.config import settings

logger = logging.getLogger("inboxerr.rate_limiter")

class RateLimiter:
    """
    Service for enforcing rate limits on API requests.
    
    Uses a simple in-memory storage for tracking request counts.
    For production, consider using Redis or another distributed storage.
    """
    
    def __init__(self):
        """Initialize the rate limiter with default limits."""
        self._requests = {}
        self._lock = asyncio.Lock()
        
        # Default rate limits by operation type
        self._rate_limits = {
            "send_message": {"requests": 60, "period": 60},  # 60 requests per minute
            "send_batch": {"requests": 10, "period": 60},    # 10 batch requests per minute
            "import_messages": {"requests": 5, "period": 300},  # 5 imports per 5 minutes
            "default": {"requests": 100, "period": 60},      # Default: 100 requests per minute
        }
    
    async def check_rate_limit(
        self, 
        user_id: str, 
        operation: str = "default"
    ) -> bool:
        """
        Check if a request is within rate limits.
        
        Args:
            user_id: ID of the user making the request
            operation: Type of operation being performed
            
        Returns:
            bool: True if request is allowed, raises exception otherwise
            
        Raises:
            HTTPException: If rate limit is exceeded
        """
        from fastapi import HTTPException, status
        
        # Get rate limit for operation
        limit = self._rate_limits.get(operation, self._rate_limits["default"])
        
        # Create key for this user and operation
        key = f"{user_id}:{operation}"
        
        current_time = time.time()
        
        async with self._lock:
            # Initialize if not exists
            if key not in self._requests:
                self._requests[key] = {"count": 0, "reset_at": current_time + limit["period"]}
            
            # Check if we need to reset the counter
            if current_time > self._requests[key]["reset_at"]:
                self._requests[key] = {"count": 0, "reset_at": current_time + limit["period"]}
            
            # Check if we're over the limit
            if self._requests[key]["count"] >= limit["requests"]:
                reset_in = int(self._requests[key]["reset_at"] - current_time)
                logger.warning(f"Rate limit exceeded for {key}. Reset in {reset_in} seconds.")
                
                # Calculate when the rate limit will reset
                reset_at = datetime.fromtimestamp(self._requests[key]["reset_at"])
                
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail=f"Rate limit exceeded. Try again in {reset_in} seconds.",
                    headers={"Retry-After": str(reset_in)}
                )
            
            # Increment counter
            self._requests[key]["count"] += 1
            
            logger.debug(f"Rate limit for {key}: {self._requests[key]['count']}/{limit['requests']}")
            
            return True
    
    def set_limit(self, operation: str, requests: int, period: int) -> None:
        """
        Set a custom rate limit for an operation.
        
        Args:
            operation: Operation type to set limit for
            requests: Maximum number of requests allowed
            period: Time period in seconds
        """
        self._rate_limits[operation] = {"requests": requests, "period": period}
    
    async def get_limit_status(self, user_id: str, operation: str = "default") -> Dict[str, Any]:
        """
        Get current rate limit status for a user and operation.
        
        Args:
            user_id: User ID
            operation: Operation type
            
        Returns:
            Dict: Rate limit status information
        """
        # Get rate limit for operation
        limit = self._rate_limits.get(operation, self._rate_limits["default"])
        
        # Create key for this user and operation
        key = f"{user_id}:{operation}"
        
        current_time = time.time()
        
        async with self._lock:
            # Handle case where user hasn't made any requests yet
            if key not in self._requests:
                return {
                    "limit": limit["requests"],
                    "remaining": limit["requests"],
                    "reset": int(current_time + limit["period"]),
                    "used": 0
                }
            
            # Reset counter if needed
            if current_time > self._requests[key]["reset_at"]:
                self._requests[key] = {"count": 0, "reset_at": current_time + limit["period"]}
            
            # Return current status
            return {
                "limit": limit["requests"],
                "remaining": max(0, limit["requests"] - self._requests[key]["count"]),
                "reset": int(self._requests[key]["reset_at"]),
                "used": self._requests[key]["count"]
            }


# Singleton instance for dependency injection
_rate_limiter = RateLimiter()

def get_rate_limiter() -> RateLimiter:
    """Get the singleton rate limiter instance."""
    return _rate_limiter
</file>

<file path="app/services/sms/retry_engine.py">
# app/services/sms/retry_engine.py
import asyncio
import logging
import uuid
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional

from app.core.config import settings
from app.db.repositories.messages import MessageRepository
from app.schemas.message import MessageStatus
from app.services.event_bus.events import EventType
from app.services.event_bus.bus import get_event_bus
from app.core.exceptions import SMSGatewayError, RetryableError

logger = logging.getLogger("inboxerr.retry")

class RetryEngine:
    """
    Service for retrying failed messages.
    
    Periodically checks for failed messages and attempts to resend them.
    """
    
    def __init__(self, message_repository: MessageRepository, event_bus: Any, sms_sender: Any):
        """
        Initialize retry engine with required dependencies.
        
        Args:
            message_repository: Repository for message access
            event_bus: Event bus for publishing events
            sms_sender: SMS sender service for resending messages
        """
        self.message_repository = message_repository
        self.event_bus = event_bus
        self.sms_sender = sms_sender
        self._running = False
        self._semaphore = asyncio.Semaphore(5)  # Limit concurrent retries
        
    async def start(self) -> None:
        """Start the retry engine."""
        if self._running:
            return
            
        self._running = True
        logger.info("Starting retry engine")
        
        while self._running:
            try:
                await self._process_retries()
            except Exception as e:
                logger.error(f"Error in retry engine: {e}", exc_info=True)
                
            # Wait before next cycle
            await asyncio.sleep(settings.RETRY_INTERVAL_SECONDS)
            
    async def stop(self) -> None:
        """Stop the retry engine."""
        self._running = False
        logger.info("Retry engine stopped")
    
    async def _process_retries(self) -> None:
        """Process messages pending retry."""
        # Get messages that need retry
        retry_candidates = await self._get_retry_candidates()
        
        if not retry_candidates:
            logger.debug("No messages to retry")
            return
            
        logger.info(f"Found {len(retry_candidates)} messages to retry")
        
        # Process retries with concurrency limit
        tasks = []
        for message in retry_candidates:
            tasks.append(self._retry_message(message))
            
        if tasks:
            # Process retries concurrently but with limit
            for i in range(0, len(tasks), 5):  # Process in chunks of 5
                chunk = tasks[i:i+5]
                await asyncio.gather(*chunk)
                await asyncio.sleep(1)  # Short delay between chunks
    
    async def _get_retry_candidates(self) -> List[Dict[str, Any]]:
        """
        Get messages that are candidates for retry.
        
        Returns:
            List[Dict]: List of messages that should be retried
        """
        # Parameters for retry candidate selection
        now = datetime.utcnow()
        max_retries = settings.RETRY_MAX_ATTEMPTS
        
        # Query for messages that:
        # 1. Are in a failed state
        # 2. Have not exceeded max retry attempts
        # 3. Have a retryable error or no error specified
        # 4. Last retry attempt was long enough ago (based on exponential backoff)
        
        # This is a simplified implementation - in production you might want
        # more sophisticated filtering and prioritization
        failed_messages = await self.message_repository.get_retryable_messages(
            max_retries=max_retries,
            limit=50  # Limit number of messages to process in one cycle
        )
        
        # Filter messages based on retry delay (exponential backoff)
        retry_candidates = []
        
        for message in failed_messages:
            # Get retry attempt count (from message metadata or events)
            retry_count = self._get_retry_count(message)
            
            # Calculate backoff delay - 30s, 2m, 8m, 30m, 2h, etc.
            backoff_seconds = 30 * (2 ** retry_count)
            
            # Get timestamp of last attempt
            last_attempt = message.failed_at or message.updated_at
            
            # Check if enough time has passed for retry
            if now - last_attempt > timedelta(seconds=backoff_seconds):
                retry_candidates.append(message)
        
        return retry_candidates
    
    def _get_retry_count(self, message: Any) -> int:
        """
        Get the retry count for a message.
        
        Args:
            message: Message object
            
        Returns:
            int: Number of retry attempts
        """
        # Check if retry count is in metadata
        meta_data = getattr(message, 'meta_data', {}) or {}
        if isinstance(meta_data, dict) and 'retry_count' in meta_data:
            return meta_data.get('retry_count', 0)
            
        # Fallback - count events of type "retry"
        retry_events = [e for e in getattr(message, 'events', []) 
                       if getattr(e, 'event_type', '') == 'retry']
        return len(retry_events)
    
    async def _retry_message(self, message: Any) -> None:
        """
        Retry sending a message.
        
        Args:
            message: Message to retry
        """
        message_id = message.id
        phone_number = message.phone_number
        message_text = message.message
        custom_id = message.custom_id
        
        # Get current retry count
        retry_count = self._get_retry_count(message)
        
        try:
            logger.info(f"Retrying message {message_id} (attempt {retry_count + 1})")
            
            # Use semaphore to limit concurrent retries
            async with self._semaphore:
                # Reset status to pending for retry
                await self.message_repository.update_message_status(
                    message_id=message_id,
                    status=MessageStatus.PENDING,
                    event_type="retry",
                    data={
                        "retry_count": retry_count + 1,
                        "previous_error": message.reason
                    }
                )
                
                # Update metadata to track retry count
                meta_data = getattr(message, 'meta_data', {}) or {}
                if isinstance(meta_data, dict):
                    meta_data['retry_count'] = retry_count + 1
                    await self.message_repository.update(
                        id=message_id,
                        obj_in={"meta_data": meta_data}
                    )
                
                # Attempt to send again
                result = await self.sms_sender._send_to_gateway(
                    phone_number=phone_number,
                    message_text=message_text,
                    custom_id=custom_id or str(uuid.uuid4())
                )
                
                # Update message status
                await self.message_repository.update_message_status(
                    message_id=message_id,
                    status=result.get("status", MessageStatus.PENDING),
                    event_type="retry_success",
                    gateway_message_id=result.get("gateway_message_id"),
                    data=result
                )
                
                # Publish event
                await self.event_bus.publish(
                    EventType.MESSAGE_RETRIED,
                    {
                        "message_id": message_id,
                        "phone_number": phone_number,
                        "retry_count": retry_count + 1,
                        "status": result.get("status", MessageStatus.PENDING)
                    }
                )
                
                logger.info(f"Successfully retried message {message_id}")
                
        except Exception as e:
            logger.error(f"Error retrying message {message_id}: {e}")
            
            # Update status to failed with incremented retry count
            error_message = str(e)
            is_retryable = isinstance(e, RetryableError)
            
            await self.message_repository.update_message_status(
                message_id=message_id,
                status=MessageStatus.FAILED,
                event_type="retry_failed",
                reason=error_message,
                data={
                    "retry_count": retry_count + 1,
                    "retryable": is_retryable
                }
            )
            
            # Publish event
            await self.event_bus.publish(
                EventType.MESSAGE_RETRY_FAILED,
                {
                    "message_id": message_id,
                    "phone_number": phone_number,
                    "retry_count": retry_count + 1,
                    "error": error_message,
                    "retryable": is_retryable
                }
            )


# Singleton instance
_retry_engine = None

async def get_retry_engine():
    """Get the singleton retry engine instance."""
    global _retry_engine
    
    if _retry_engine is None:
        from app.db.session import get_repository
        from app.db.repositories.messages import MessageRepository
        from app.services.event_bus.bus import get_event_bus
        from app.services.sms.sender import get_sms_sender
        
        message_repository = await get_repository(MessageRepository)
        event_bus = get_event_bus()
        sms_sender = await get_sms_sender()
        
        _retry_engine = RetryEngine(
            message_repository=message_repository,
            event_bus=event_bus,
            sms_sender=sms_sender
        )
        
    return _retry_engine
</file>

<file path="app/services/webhooks/models.py">
# app/services/webhooks/models.py
"""
Pydantic models for webhook payloads from SMS Gateway.
"""
from datetime import datetime
from typing import Dict, Any, Optional, Literal
from pydantic import BaseModel, Field

class SmsReceivedPayload(BaseModel):
    """Payload for sms:received event."""
    message_id: str = Field(..., alias="messageId")
    message: str
    phone_number: str = Field(..., alias="phoneNumber")
    sim_number: Optional[int] = Field(None, alias="simNumber")
    received_at: datetime = Field(..., alias="receivedAt")
    
class SmsSentPayload(BaseModel):
    """Payload for sms:sent event."""
    message_id: str = Field(..., alias="messageId")
    phone_number: str = Field(..., alias="phoneNumber")
    sim_number: Optional[int] = Field(None, alias="simNumber")
    sent_at: datetime = Field(..., alias="sentAt")
    
class SmsDeliveredPayload(BaseModel):
    """Payload for sms:delivered event."""
    message_id: str = Field(..., alias="messageId")
    phone_number: str = Field(..., alias="phoneNumber")
    sim_number: Optional[int] = Field(None, alias="simNumber")
    delivered_at: datetime = Field(..., alias="deliveredAt")
    
class SmsFailedPayload(BaseModel):
    """Payload for sms:failed event."""
    message_id: str = Field(..., alias="messageId")
    phone_number: str = Field(..., alias="phoneNumber")
    sim_number: Optional[int] = Field(None, alias="simNumber")
    failed_at: datetime = Field(..., alias="failedAt")
    reason: str
    
class SystemPingPayload(BaseModel):
    """Payload for system:ping event."""
    health: Dict[str, Any]
    
EventType = Literal["sms:received", "sms:sent", "sms:delivered", "sms:failed", "system:ping"]

class WebhookPayload(BaseModel):
    """Base webhook payload from SMS Gateway."""
    device_id: str = Field(..., alias="deviceId")
    event: EventType
    id: str
    webhook_id: str = Field(..., alias="webhookId")
    payload: Dict[str, Any]  # Will be converted to specific payload types based on event
</file>

<file path="app/utils/pagination.py">
"""
Utilities for API pagination.
"""
from typing import List, Dict, Any, TypeVar, Generic, Optional
from fastapi import Query, Depends
from pydantic import BaseModel


class PaginationParams:
    """
    Pagination parameters for API endpoints.
    
    This class is used as a FastAPI dependency to extract pagination parameters
    from query parameters.
    """
    
    def __init__(
        self,
        page: int = Query(1, ge=1, description="Page number"),
        limit: int = Query(20, ge=1, le=100, description="Items per page"),
        sort: Optional[str] = Query(None, description="Sort field"),
        order: Optional[str] = Query("asc", description="Sort order (asc or desc)")
    ):
        """
        Initialize pagination parameters.
        
        Args:
            page: Page number (1-based)
            limit: Items per page
            sort: Field to sort by
            order: Sort order (asc or desc)
        """
        self.page = page
        self.limit = limit
        self.sort = sort
        self.order = order
        
        # Calculate skip value for database queries
        self.skip = (page - 1) * limit


class PageInfo(BaseModel):
    """
    Page information for paginated responses.
    """
    current_page: int
    total_pages: int
    page_size: int
    total_items: int
    has_previous: bool
    has_next: bool


T = TypeVar('T')

class PaginatedResponse(BaseModel, Generic[T]):
    """
    Generic paginated response model.
    
    This class is used to standardize the format of paginated responses
    across all API endpoints.
    """
    items: List[T]
    page_info: PageInfo
    
    class Config:
        """Pydantic config."""
        arbitrary_types_allowed = True


def paginate_response(
    items: List[Any],
    total: int,
    pagination: PaginationParams
) -> Dict[str, Any]:
    """
    Create a standardized paginated response.
    
    Args:
        items: List of items for the current page
        total: Total number of items across all pages
        pagination: Pagination parameters
        
    Returns:
        Dict: Standardized response with items and pagination info
    """
    # Calculate pagination values
    total_pages = (total + pagination.limit - 1) // pagination.limit
    
    # Create page info
    page_info = PageInfo(
        current_page=pagination.page,
        total_pages=total_pages,
        page_size=pagination.limit,
        total_items=total,
        has_previous=pagination.page > 1,
        has_next=pagination.page < total_pages
    )
    
    # Create response
    return {
        "items": items,
        "page_info": page_info
    }


def get_pagination_links(
    path: str,
    pagination: PaginationParams,
    total: int,
    query_params: Optional[Dict[str, Any]] = None
) -> Dict[str, Optional[str]]:
    """
    Generate pagination links for HATEOAS.
    
    Args:
        path: Base path for links
        pagination: Pagination parameters
        total: Total number of items
        query_params: Additional query parameters
        
    Returns:
        Dict: Links for first, prev, next, and last pages
    """
    # Calculate pagination values
    total_pages = (total + pagination.limit - 1) // pagination.limit
    
    # Initialize query params
    params = query_params.copy() if query_params else {}
    
    # Helper to create URL with query params
    def create_url(page: int) -> str:
        page_params = {**params, "page": page, "limit": pagination.limit}
        
        if pagination.sort:
            page_params["sort"] = pagination.sort
            page_params["order"] = pagination.order
            
        query_string = "&".join(f"{key}={value}" for key, value in page_params.items())
        return f"{path}?{query_string}"
    
    # Create links
    links = {
        "first": create_url(1),
        "last": create_url(total_pages) if total_pages > 0 else None,
        "prev": create_url(pagination.page - 1) if pagination.page > 1 else None,
        "next": create_url(pagination.page + 1) if pagination.page < total_pages else None
    }
    
    return links
</file>

<file path="app/utils/phone.py">
"""
Phone number validation and formatting utilities.
"""
import re
from typing import Tuple, Dict, Optional

try:
    import phonenumbers
    PHONENUMBERS_AVAILABLE = True
except ImportError:
    PHONENUMBERS_AVAILABLE = False


class PhoneValidationError(Exception):
    """Exception raised for phone validation errors."""
    
    def __init__(self, message: str, details: Optional[Dict] = None):
        self.message = message
        self.details = details or {}
        super().__init__(message)


def validate_phone_basic(number: str) -> Tuple[bool, str, Optional[str]]:
    """
    Basic phone number validation without external libraries.
    
    Args:
        number: Phone number to validate
        
    Returns:
        Tuple[bool, str, str]: (is_valid, formatted_number, error_message)
    """
    # Remove common formatting characters
    cleaned = re.sub(r'[\s\-\(\)\.]+', '', number)
    
    # Check if it's just digits and maybe a leading +
    if not re.match(r'^\+?\d+$', cleaned):
        return False, number, "Phone number contains invalid characters"
    
    # Ensure it starts with + for E.164 format
    if not cleaned.startswith('+'):
        cleaned = '+' + cleaned
    
    # Basic length check
    if len(cleaned) < 8:
        return False, cleaned, "Phone number too short"
    if len(cleaned) > 16:
        return False, cleaned, "Phone number too long"
    
    return True, cleaned, None


def validate_phone_advanced(number: str) -> Tuple[bool, str, Optional[str]]:
    """
    Advanced phone number validation using the phonenumbers library.
    
    Args:
        number: Phone number to validate
        
    Returns:
        Tuple[bool, str, str]: (is_valid, formatted_number, error_message)
    """
    try:
        # Parse the phone number
        parsed = phonenumbers.parse(number, None)
        
        # Check if it's a valid number
        if not phonenumbers.is_valid_number(parsed):
            return False, number, "Invalid phone number"
        
        # Format in E.164 format
        formatted = phonenumbers.format_number(
            parsed, phonenumbers.PhoneNumberFormat.E164
        )
        
        # Get the country and carrier
        country = phonenumbers.region_code_for_number(parsed)
        
        return True, formatted, None
    except phonenumbers.NumberParseException as e:
        return False, number, f"Parse error: {str(e)}"


def validate_phone(number: str) -> Tuple[bool, str, Optional[str]]:
    """
    Validate and format a phone number.
    
    Uses the phonenumbers library if available, otherwise falls back to basic validation.
    
    Args:
        number: Phone number to validate
        
    Returns:
        Tuple[bool, str, str]: (is_valid, formatted_number, error_message)
    """
    if PHONENUMBERS_AVAILABLE:
        return validate_phone_advanced(number)
    else:
        return validate_phone_basic(number)


def is_valid_phone(number: str) -> bool:
    """
    Check if a phone number is valid.
    
    Args:
        number: Phone number to validate
        
    Returns:
        bool: True if valid, False otherwise
    """
    is_valid, _, _ = validate_phone(number)
    return is_valid


def format_phone(number: str) -> str:
    """
    Format a phone number in E.164 format.
    
    Args:
        number: Phone number to format
        
    Returns:
        str: Formatted phone number or original if invalid
        
    Raises:
        PhoneValidationError: If the phone number is invalid
    """
    is_valid, formatted, error = validate_phone(number)
    if not is_valid:
        raise PhoneValidationError(error or "Invalid phone number", {"number": number})
    return formatted
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  # API service
  api:
    build: .
    container_name: inboxerr-api
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@db:5432/inboxerr
      - SMS_GATEWAY_URL=${SMS_GATEWAY_URL:-https://endpointnumber1.work.gd/api/3rdparty/v1}
      - SMS_GATEWAY_LOGIN=${SMS_GATEWAY_LOGIN:-}
      - SMS_GATEWAY_PASSWORD=${SMS_GATEWAY_PASSWORD:-}
      - SECRET_KEY=${SECRET_KEY:-CHANGEME_IN_PRODUCTION}
      - WEBHOOK_HOST=0.0.0.0
      - WEBHOOK_PORT=5000
      - LOG_LEVEL=DEBUG
    depends_on:
      - db
    networks:
      - inboxerr-network
    restart: unless-stopped

  # Database service
  db:
    image: postgres:14-alpine
    container_name: inboxerr-db
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=inboxerr
    ports:
      - "5432:5432"
    networks:
      - inboxerr-network
    restart: unless-stopped

  # Optional: Redis for caching and task queue
  redis:
    image: redis:alpine
    container_name: inboxerr-redis
    ports:
      - "6379:6379"
    networks:
      - inboxerr-network
    restart: unless-stopped

  # Optional: PgAdmin for database management
  pgadmin:
    image: dpage/pgadmin4
    container_name: inboxerr-pgadmin
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@inboxerr.com
      - PGADMIN_DEFAULT_PASSWORD=admin
    ports:
      - "5050:80"
    depends_on:
      - db
    networks:
      - inboxerr-network
    restart: unless-stopped

networks:
  inboxerr-network:
    driver: bridge

volumes:
  postgres_data:
</file>

<file path="Dockerfile">
# Use Python 3.10 slim as base image
FROM python:3.10-slim

# Set working directory
WORKDIR /app

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app

# Install system dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        build-essential \
        libpq-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN adduser --disabled-password --gecos "" appuser
RUN chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Start application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="scripts/seed_db.py">
"""
Placeholder script for seeding the database in development.
Currently not in use ‚Äî extend as needed.
Seed the database with essential data (e.g., admin user).
Currently skips message seeding ‚Äî placeholder for future use.

"""

import subprocess
import os
import sys

def run_admin_script():
    """Ensure an admin user exists by running create_admin.py."""
    try:
        subprocess.run(
            [sys.executable, "app/scripts/create_admin.py"],
            check=True,
            cwd=os.getcwd(),  # Ensures correct working directory
            env={**os.environ, "PYTHONPATH": os.getcwd()}
        )
        print("üëÆ Admin user created.")
    except subprocess.CalledProcessError:
        print("‚ö†Ô∏è Failed to create admin user. Check create_admin.py.")


def seed():
    print("üå± [SKIPPED] No seed data logic implemented yet.")

if __name__ == "__main__":
    seed()
    run_admin_script()
</file>

<file path=".gitignore">
# Python specific
__pycache__/
*.py[cod]
*.pyo
*.pyd
*.env
*.venv
env/
venv/
ENV/
.venv/
env.bak/
venv.bak/
*.egg
*.egg-info/
dist/
build/
*.log

# FastAPI specific
instance/
*.db
*.sqlite3

# IDE specific
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db

# Test and coverage reports
htmlcov/
.tox/
.nox/
.coverage
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
</file>

<file path="app/api/router.py">
"""
Main API router that includes all endpoint routers.
"""
from fastapi import APIRouter

from app.api.v1.endpoints import auth, messages, webhooks, metrics, campaigns


# Create main API router
api_router = APIRouter()

# Include all endpoint routers with appropriate tags
api_router.include_router(
    auth.router, 
    prefix="/auth", 
    tags=["Authentication"]
)
api_router.include_router(
    messages.router, 
    prefix="/messages", 
    tags=["Messages"]
)
api_router.include_router(
    campaigns.router, 
    prefix="/campaigns", 
    tags=["Campaigns"]
)
api_router.include_router(
    webhooks.router, 
    prefix="/webhooks", 
    tags=["Webhooks"]
)
api_router.include_router(
    metrics.router, 
    prefix="/metrics", 
    tags=["Metrics"]
)
</file>

<file path="app/api/v1/endpoints/metrics.py">
"""
API endpoints for metrics and reporting.
"""
from fastapi import APIRouter, Depends, HTTPException

from app.api.v1.dependencies import get_current_user
from app.schemas.user import User

router = APIRouter()

@router.get("/")
async def get_metrics(
    current_user: User = Depends(get_current_user)
):
    """
    Get system metrics and statistics.
    """
    # This is a stub - implementation will be added later
    return {
        "message_count": {
            "total": 0,
            "sent": 0,
            "delivered": 0,
            "failed": 0
        },
        "user_count": 1,
        "webhook_count": 0
    }

@router.get("/usage")
async def get_usage_metrics(
    current_user: User = Depends(get_current_user)
):
    """
    Get usage metrics for the current user.
    """
    # This is a stub - implementation will be added later
    return {
        "message_count": 0,
        "quota": {
            "used": 0,
            "total": 1000
        }
    }
</file>

<file path="app/api/v1/endpoints/webhooks.py">
# app/api/v1/endpoints/webhooks.py
"""
API endpoints for webhook management.
"""
import logging
from typing import Dict, Any
from fastapi import APIRouter, Depends, HTTPException, Request, Body, Header, status

from app.api.v1.dependencies import get_current_user
from app.schemas.user import User
from app.services.webhooks.manager import process_gateway_webhook

router = APIRouter()
logger = logging.getLogger("inboxerr.webhooks")

@router.get("/")
async def list_webhooks(
    current_user: User = Depends(get_current_user)
):
    """
    List all webhooks for the current user.
    """
    # This is a stub - implementation will be added later
    return {"message": "Webhook listing not implemented yet"}

@router.post("/gateway", status_code=status.HTTP_200_OK)
async def webhook_receiver(
    request: Request,
    x_signature: str = Header(None),
    x_timestamp: str = Header(None)
):
    """
    Receive webhooks from the SMS Gateway.
    
    This endpoint is called by the SMS Gateway when events occur.
    No authentication is required as we validate using signatures.
    """
    # Get raw body for signature validation
    body = await request.body()
    
    # Prepare headers for signature verification
    headers = {
        "X-Signature": x_signature,
        "X-Timestamp": x_timestamp
    }
    
    # Process the webhook
    success, result = await process_gateway_webhook(body, headers)
    
    if not success:
        logger.error(f"Error processing webhook: {result.get('error')}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=result.get('error', 'Error processing webhook')
        )
    
    return result
</file>

<file path="app/core/config.py">
"""
Application settings and configuration management.
"""
from typing import List, Optional, Union
from pydantic import AnyHttpUrl, validator, field_validator
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """Application settings."""
    # Base
    PROJECT_NAME: str = "Inboxerr Backend"
    PROJECT_DESCRIPTION: str = "API backend for SMS management and delivery"
    VERSION: str = "0.1.0"
    API_PREFIX: str = "/api/v1"
    DEBUG: bool = False
    
    # CORS
    BACKEND_CORS_ORIGINS: List[Union[str, AnyHttpUrl]] = []

    @field_validator("BACKEND_CORS_ORIGINS", mode='before')
    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:
        """Parse CORS origins from string or list."""
        if isinstance(v, str) and not v.startswith("["):
            return [i.strip() for i in v.split(",")]
        elif isinstance(v, (list, str)):
            return v
        raise ValueError(v)
    
    # Authentication
    SECRET_KEY: str = "CHANGEME_IN_PRODUCTION"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24  # 1 day
    API_KEY_HEADER: str = "X-API-Key"
    
    # Database
    DATABASE_URL: str = "sqlite+aiosqlite:///./inboxerr.db"
    
    # SMS Gateway
    SMS_GATEWAY_URL: str = "https://endpointnumber1.work.gd/api/3rdparty/v1"
    SMS_GATEWAY_LOGIN: str = ""
    SMS_GATEWAY_PASSWORD: str = ""
    
    # Webhook
    API_BASE_URL: str = "http://localhost:8000"  # Base URL for webhooks
    WEBHOOK_SIGNATURE_KEY: Optional[str] = None
    WEBHOOK_TIMESTAMP_TOLERANCE: int = 300  # 5 minutes
    
    # SMS Processing
    BATCH_SIZE: int = 100
    DELAY_BETWEEN_SMS: float = 0.3  # seconds
    RETRY_ENABLED: bool = True
    RETRY_MAX_ATTEMPTS: int = 3
    RETRY_INTERVAL_SECONDS: int = 60
    
    # Logging
    LOG_LEVEL: str = "INFO"
    
    class Config:
        """Pydantic config."""
        case_sensitive = True
        env_file = ".env"


# Create singleton settings instance
settings = Settings()
</file>

<file path="app/db/repositories/messages.py">
"""
Message repository for database operations related to SMS messages.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any, Tuple
from uuid import uuid4

from sqlalchemy import select, update, delete, and_, or_, desc, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.dialects.postgresql import JSONB

from app.db.repositories.base import BaseRepository
from app.models.message import Message, MessageEvent, MessageBatch, MessageTemplate
from app.schemas.message import MessageCreate, MessageStatus


class MessageRepository(BaseRepository[Message, MessageCreate, Dict[str, Any]]):
    """Message repository for database operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize with session and Message model."""
        super().__init__(session=session, model=Message)
    
    async def create_message(
        self,
        *,
        phone_number: str,
        message_text: str,
        user_id: str,
        custom_id: Optional[str] = None,
        scheduled_at: Optional[datetime] = None,
        metadata: Optional[Dict[str, Any]] = None,
        batch_id: Optional[str] = None
    ) -> Message:
        """
        Create a new message.
        
        Args:
            phone_number: Recipient phone number
            message_text: Message content
            user_id: User who is sending the message
            custom_id: Optional custom ID for tracking
            scheduled_at: Optional scheduled time
            metadata: Optional additional data
            batch_id: Optional batch ID
            
        Returns:
            Message: Created message
        """
        # Set initial status based on scheduling
        initial_status = MessageStatus.SCHEDULED if scheduled_at else MessageStatus.PENDING
        
        # Calculate SMS parts (simple calculation, can be improved)
        parts_count = (len(message_text) + 159) // 160  # 160 chars per SMS part, rounded up
        
        # Create message
        message = Message(
            id=str(uuid4()),
            custom_id=custom_id or str(uuid4()),
            phone_number=phone_number,
            message=message_text,
            status=initial_status,
            scheduled_at=scheduled_at,
            user_id=user_id,
            meta_data=metadata or {},  # Use meta_data instead of metadata
            parts_count=parts_count,
            batch_id=batch_id
        )
        
        self.session.add(message)
        
        # Create initial event
        event = MessageEvent(
            id=str(uuid4()),
            message_id=message.id,
            event_type="created",
            status=initial_status,
            data={
                "phone_number": phone_number,
                "scheduled_at": scheduled_at.isoformat() if scheduled_at else None
            }
        )
        
        self.session.add(event)
        await self.session.commit()
        await self.session.refresh(message)
        
        return message
    
    async def update_message_status(
        self,
        *,
        message_id: str,
        status: str,
        event_type: str,
        reason: Optional[str] = None,
        gateway_message_id: Optional[str] = None,
        data: Optional[Dict[str, Any]] = None
    ) -> Optional[Message]:
        """
        Update message status.
        
        Args:
            message_id: Message ID
            status: New status
            event_type: Event type triggering this update
            reason: Optional reason for status change
            gateway_message_id: Optional gateway message ID
            data: Optional additional data
            
        Returns:
            Message: Updated message or None
        """
        # Get the message
        message = await self.get_by_id(message_id)
        if not message:
            return None
        
        # Update status-specific timestamp
        now = datetime.utcnow()
        update_data = {
            "status": status,
            "updated_at": now,
        }
        
        if status == MessageStatus.SENT:
            update_data["sent_at"] = now
        elif status == MessageStatus.DELIVERED:
            update_data["delivered_at"] = now
        elif status == MessageStatus.FAILED:
            update_data["failed_at"] = now
            update_data["reason"] = reason
        
        # Set gateway message ID if provided
        if gateway_message_id:
            update_data["gateway_message_id"] = gateway_message_id
        
        # Update the message
        await self.session.execute(
            update(Message)
            .where(Message.id == message_id)
            .values(**update_data)
        )
        
        # Create event for status change
        event = MessageEvent(
            id=str(uuid4()),
            message_id=message_id,
            event_type=event_type,
            status=status,
            data=data or {}
        )
        
        self.session.add(event)
        await self.session.commit()
        
        # Refresh the message
        await self.session.refresh(message)
        
        return message

    async def create_batch(
        self,
        *,
        user_id: str,
        name: str,
        total: int
    ) -> MessageBatch:
        """
        Create a new message batch.
        
        Args:
            user_id: User ID
            name: Batch name
            total: Total number of messages
            
        Returns:
            MessageBatch: Created batch
        """
        batch = MessageBatch(
            id=str(uuid4()),
            name=name,
            total=total,
            processed=0,
            successful=0,
            failed=0,
            status=MessageStatus.PENDING,
            user_id=user_id
        )
        
        self.session.add(batch)
        await self.session.commit()
        await self.session.refresh(batch)
        
        return batch

    async def update_batch_progress(
        self,
        *,
        batch_id: str,
        increment_processed: int = 0,
        increment_successful: int = 0,
        increment_failed: int = 0,
        status: Optional[str] = None
    ) -> Optional[MessageBatch]:
        """
        Update batch progress.
        
        Args:
            batch_id: Batch ID
            increment_processed: Increment processed count
            increment_successful: Increment successful count
            increment_failed: Increment failed count
            status: Optional new status
            
        Returns:
            MessageBatch: Updated batch or None
        """
        batch = await self.get_by_id(batch_id)
        if not batch:
            return None
        
        # Update counts
        batch.processed += increment_processed
        batch.successful += increment_successful
        batch.failed += increment_failed
        
        # Update status if provided
        if status:
            batch.status = status
            
        # If all messages processed, update status and completion time
        if batch.processed >= batch.total:
            batch.status = MessageStatus.PROCESSED if batch.failed == 0 else "partial"
            batch.completed_at = datetime.utcnow()
        
        self.session.add(batch)
        await self.session.commit()
        await self.session.refresh(batch)
        
        return batch

    async def get_by_custom_id(self, custom_id: str) -> Optional[Message]:
        """
        Get message by custom ID.
        
        Args:
            custom_id: Custom ID
            
        Returns:
            Message: Found message or None
        """
        return await self.get_by_attribute("custom_id", custom_id)

    async def get_by_gateway_id(self, gateway_id: str) -> Optional[Message]:
        """
        Get message by gateway ID.
        
        Args:
            gateway_id: Gateway message ID
            
        Returns:
            Message: Found message or None
        """
        return await self.get_by_attribute("gateway_message_id", gateway_id)

    async def list_messages_for_user(
        self,
        *,
        user_id: str,
        status: Optional[str] = None,
        phone_number: Optional[str] = None,
        from_date: Optional[str] = None,
        to_date: Optional[str] = None,
        campaign_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Message], int]:
        """
        List messages for user with filtering.
        
        Args:
            user_id: User ID
            status: Optional status filter
            phone_number: Optional phone number filter
            from_date: Optional from date filter
            to_date: Optional to date filter
            campaign_id: Optional campaign ID filter
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Message], int]: List of messages and total count
        """
        # Base query
        query = select(Message).where(Message.user_id == user_id)
        count_query = select(func.count()).select_from(Message).where(Message.user_id == user_id)
        
        # Apply filters
        if status:
            query = query.where(Message.status == status)
            count_query = count_query.where(Message.status == status)
        
        if phone_number:
            query = query.where(Message.phone_number == phone_number)
            count_query = count_query.where(Message.phone_number == phone_number)

        if campaign_id:
            query = query.where(Message.campaign_id == campaign_id)
            count_query = count_query.where(Message.campaign_id == campaign_id)
        
        if from_date:
            try:
                from_date_obj = datetime.fromisoformat(from_date.replace('Z', '+00:00'))
                query = query.where(Message.created_at >= from_date_obj)
                count_query = count_query.where(Message.created_at >= from_date_obj)
            except ValueError:
                pass
        
        if to_date:
            try:
                to_date_obj = datetime.fromisoformat(to_date.replace('Z', '+00:00'))
                query = query.where(Message.created_at <= to_date_obj)
                count_query = count_query.where(Message.created_at <= to_date_obj)
            except ValueError:
                pass
        
        # Order by created_at desc
        query = query.order_by(desc(Message.created_at))
        
        # Pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await self.session.execute(query)
        count_result = await self.session.execute(count_query)
        
        messages = result.scalars().all()
        total = count_result.scalar_one()
        
        return messages, total

    async def get_messages_for_batch(
        self,
        *,
        batch_id: str,
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Message], int]:
        """
        Get messages for a batch.
        
        Args:
            batch_id: Batch ID
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Message], int]: List of messages and total count
        """
        # Base query
        query = select(Message).where(Message.batch_id == batch_id)
        count_query = select(func.count()).select_from(Message).where(Message.batch_id == batch_id)
        
        # Order by created_at desc
        query = query.order_by(desc(Message.created_at))
        
        # Pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await self.session.execute(query)
        count_result = await self.session.execute(count_query)
        
        messages = result.scalars().all()
        total = count_result.scalar_one()
        
        return messages, total
    
    async def get_messages_for_campaign(
        self,
        *,
        campaign_id: str,
        status: Optional[str] = None,
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Message], int]:
        """
        Get messages for a campaign.
        
        Args:
            campaign_id: Campaign ID
            status: Optional status filter
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Message], int]: List of messages and total count
        """
        # Base query
        query = select(Message).where(Message.campaign_id == campaign_id)
        count_query = select(func.count()).select_from(Message).where(Message.campaign_id == campaign_id)
        
        # Apply status filter
        if status:
            query = query.where(Message.status == status)
            count_query = count_query.where(Message.status == status)
        
        # Order by created_at desc
        query = query.order_by(desc(Message.created_at))
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await self.session.execute(query)
        count_result = await self.session.execute(count_query)
        
        messages = result.scalars().all()
        total = count_result.scalar_one()
        
        return messages, total

    async def get_retryable_messages(
        self,
        *,
        max_retries: int = 3,
        limit: int = 50
    ) -> List[Message]:
        """
        Get messages that can be retried.
        
        Args:
            max_retries: Maximum number of retry attempts
            limit: Maximum number of messages to return
            
        Returns:
            List[Message]: List of retryable messages
        """
        # Query for failed messages that can be retried
        query = select(Message).where(
            and_(
                Message.status == MessageStatus.FAILED,
                or_(
                    Message.meta_data.is_(None),  # No metadata at all
                    ~Message.meta_data.contains({"retry_count": 0}),  # retry_count key is absent
                    Message.meta_data["retry_count"].as_integer() < max_retries  # retry_count too low
                )
            )
        ).order_by(Message.failed_at).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
</file>

<file path="app/models/message.py">
"""
Database models for SMS messages.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any

from sqlalchemy import Column, String, DateTime, Boolean, JSON, Integer, ForeignKey, Text
from sqlalchemy.orm import relationship

from app.models.base import Base


class Message(Base):
    """SMS message model."""
    
    # Core message data
    custom_id = Column(String, unique=True, index=True, nullable=True)
    phone_number = Column(String, nullable=False, index=True)
    message = Column(Text, nullable=False)
    status = Column(String, nullable=False, default="pending", index=True)

    # Campaign relationship
    campaign_id = Column(String, ForeignKey("campaign.id"), nullable=True, index=True)
    campaign = relationship("Campaign", back_populates="messages")
    
    # Timestamps for status tracking
    scheduled_at = Column(DateTime, nullable=True, index=True)
    sent_at = Column(DateTime, nullable=True)
    delivered_at = Column(DateTime, nullable=True)
    failed_at = Column(DateTime, nullable=True)
    
    # Additional data
    reason = Column(String, nullable=True)
    gateway_message_id = Column(String, nullable=True, index=True)
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    meta_data = Column(JSON, nullable=True)  # Changed from 'metadata' to 'meta_data'
    
    # SMS parts tracking
    parts_count = Column(Integer, default=1, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="messages")
    events = relationship("MessageEvent", back_populates="message", cascade="all, delete-orphan")
    batch_id = Column(String, ForeignKey("messagebatch.id"), nullable=True, index=True)
    batch = relationship("MessageBatch", back_populates="messages")


class MessageEvent(Base):
    """Model for tracking message events and status changes."""
    
    message_id = Column(String, ForeignKey("message.id"), nullable=False, index=True)
    event_type = Column(String, nullable=False, index=True)
    status = Column(String, nullable=False)
    data = Column(JSON, nullable=True)
    
    # Relationships
    message = relationship("Message", back_populates="events")


class MessageBatch(Base):
    """Model for tracking message batches."""
    
    name = Column(String, nullable=True)
    total = Column(Integer, default=0, nullable=False)
    processed = Column(Integer, default=0, nullable=False)
    successful = Column(Integer, default=0, nullable=False)
    failed = Column(Integer, default=0, nullable=False)
    status = Column(String, nullable=False, default="pending", index=True)
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    completed_at = Column(DateTime, nullable=True)
    
    # Relationships
    messages = relationship("Message", back_populates="batch")
    user = relationship("User")


class MessageTemplate(Base):
    """Model for storing reusable message templates."""
    
    name = Column(String, nullable=False, index=True)
    content = Column(Text, nullable=False)
    description = Column(String, nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    variables = Column(JSON, nullable=True)  # Define expected variables in the template
    
    # Relationships
    user = relationship("User")
</file>

<file path="app/services/event_bus/events.py">
"""
Event type definitions for the event bus.
"""
from enum import Enum, auto
from typing import Dict, Any, Optional
from datetime import datetime


class EventType(str, Enum):
    """Event types for the event bus."""
    
    # System events
    SYSTEM_STARTUP = "system:startup"
    SYSTEM_SHUTDOWN = "system:shutdown"
    
    # Message events
    MESSAGE_CREATED = "message:created"
    MESSAGE_UPDATED = "message:updated"
    MESSAGE_SENT = "message:sent"
    MESSAGE_DELIVERED = "message:delivered"
    MESSAGE_FAILED = "message:failed"
    MESSAGE_SCHEDULED = "message:scheduled"
    MESSAGE_RETRIED = "message:retried"
    MESSAGE_RETRY_FAILED = "message:retry_failed"
    
    # Batch events
    BATCH_CREATED = "batch:created"
    BATCH_UPDATED = "batch:updated"
    BATCH_COMPLETED = "batch:completed"

    # Campaign events
    CAMPAIGN_CREATED = "campaign:created"
    CAMPAIGN_UPDATED = "campaign:updated"
    CAMPAIGN_STARTED = "campaign:started"
    CAMPAIGN_PAUSED = "campaign:paused"
    CAMPAIGN_COMPLETED = "campaign:completed"
    CAMPAIGN_CANCELLED = "campaign:cancelled"
    CAMPAIGN_FAILED = "campaign:failed"
    
    # SMS Gateway events
    SMS_RECEIVED = "sms:received"
    SMS_SENT = "sms:sent"
    SMS_DELIVERED = "sms:delivered"
    SMS_FAILED = "sms:failed"
    
    # Webhook events
    WEBHOOK_RECEIVED = "webhook:received"
    WEBHOOK_PROCESSED = "webhook:processed"
    
    # User events
    USER_CREATED = "user:created"
    USER_UPDATED = "user:updated"
    USER_DELETED = "user:deleted"
    
    # API events
    API_REQUEST = "api:request"
    API_RESPONSE = "api:response"
    API_ERROR = "api:error"


class Event:
    """
    Base event class.
    
    Contains common event data and helper methods.
    """
    
    def __init__(
        self,
        event_type: EventType,
        data: Dict[str, Any],
        timestamp: Optional[datetime] = None
    ):
        """
        Initialize event.
        
        Args:
            event_type: Event type
            data: Event data
            timestamp: Event timestamp
        """
        self.event_type = event_type
        self.data = data
        self.timestamp = timestamp or datetime.utcnow()
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert event to dictionary.
        
        Returns:
            Dict: Event data
        """
        return {
            "event_type": self.event_type,
            "data": self.data,
            "timestamp": self.timestamp.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Event":
        """
        Create event from dictionary.
        
        Args:
            data: Event data
            
        Returns:
            Event: Event instance
        """
        event_type = data.get("event_type")
        if isinstance(event_type, str):
            event_type = EventType(event_type)
        
        timestamp = data.get("timestamp")
        if isinstance(timestamp, str):
            timestamp = datetime.fromisoformat(timestamp)
        
        return cls(
            event_type=event_type,
            data=data.get("data", {}),
            timestamp=timestamp
        )


class MessageEvent(Event):
    """
    Message event class.
    
    Contains message-specific event data.
    """
    
    def __init__(
        self,
        event_type: EventType,
        message_id: str,
        user_id: str,
        data: Dict[str, Any],
        timestamp: Optional[datetime] = None
    ):
        """
        Initialize message event.
        
        Args:
            event_type: Event type
            message_id: Message ID
            user_id: User ID
            data: Event data
            timestamp: Event timestamp
        """
        # Add message ID and user ID to data
        data = data.copy()
        data["message_id"] = message_id
        data["user_id"] = user_id
        
        super().__init__(event_type, data, timestamp)
    
    @property
    def message_id(self) -> str:
        """Get message ID."""
        return self.data.get("message_id", "")
    
    @property
    def user_id(self) -> str:
        """Get user ID."""
        return self.data.get("user_id", "")


class WebhookEvent(Event):
    """
    Webhook event class.
    
    Contains webhook-specific event data.
    """
    
    def __init__(
        self,
        event_type: EventType,
        webhook_id: str,
        payload: Dict[str, Any],
        data: Dict[str, Any],
        timestamp: Optional[datetime] = None
    ):
        """
        Initialize webhook event.
        
        Args:
            event_type: Event type
            webhook_id: Webhook ID
            payload: Webhook payload
            data: Event data
            timestamp: Event timestamp
        """
        # Add webhook ID and payload to data
        data = data.copy()
        data["webhook_id"] = webhook_id
        data["payload"] = payload
        
        super().__init__(event_type, data, timestamp)
    
    @property
    def webhook_id(self) -> str:
        """Get webhook ID."""
        return self.data.get("webhook_id", "")
    
    @property
    def payload(self) -> Dict[str, Any]:
        """Get webhook payload."""
        return self.data.get("payload", {})
</file>

<file path="app/services/metrics/collector.py">
# app/services/metrics/collector.py
import logging
from typing import Dict, Any, Optional

from app.services.event_bus.bus import get_event_bus
from app.services.event_bus.events import EventType

logger = logging.getLogger("inboxerr.metrics")

# Global metrics store (in-memory for MVP)
_metrics = {
    "messages": {
        "total": 0,
        "sent": 0,
        "delivered": 0,
        "failed": 0
    },
    "users": {
        "total": 0,
        "active": 0
    },
    "webhooks": {
        "total": 0,
        "delivered": 0,
        "failed": 0
    }
}

async def initialize_metrics() -> None:
    """Initialize metrics collector."""
    logger.info("Initializing metrics collector")
    
    # Subscribe to events
    event_bus = get_event_bus()
    
    # Message events
    await event_bus.subscribe(
        EventType.MESSAGE_CREATED,
        _handle_message_created,
        "metrics.message_created"
    )
    
    await event_bus.subscribe(
        EventType.MESSAGE_SENT,
        _handle_message_sent,
        "metrics.message_sent"
    )
    
    await event_bus.subscribe(
        EventType.MESSAGE_DELIVERED,
        _handle_message_delivered,
        "metrics.message_delivered"
    )
    
    await event_bus.subscribe(
        EventType.MESSAGE_FAILED,
        _handle_message_failed,
        "metrics.message_failed"
    )
    
    logger.info("Metrics collector initialized")

async def get_metrics() -> Dict[str, Any]:
    """Get current metrics."""
    return _metrics

async def _handle_message_created(data: Dict[str, Any]) -> None:
    """Handle message created event."""
    _metrics["messages"]["total"] += 1

async def _handle_message_sent(data: Dict[str, Any]) -> None:
    """Handle message sent event."""
    _metrics["messages"]["sent"] += 1

async def _handle_message_delivered(data: Dict[str, Any]) -> None:
    """Handle message delivered event."""
    _metrics["messages"]["delivered"] += 1

async def _handle_message_failed(data: Dict[str, Any]) -> None:
    """Handle message failed event."""
    _metrics["messages"]["failed"] += 1
</file>

<file path="app/services/sms/sender.py">
"""
SMS sender service for interacting with the Android SMS Gateway.
"""
import asyncio
import logging
import uuid
import time
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple, Union

from app.core.config import settings
from app.core.exceptions import ValidationError, SMSGatewayError, RetryableError
from app.utils.phone import validate_phone
from app.db.repositories.messages import MessageRepository
from app.schemas.message import MessageCreate, MessageStatus, BatchMessageRequest, BatchOptions
from app.services.event_bus.events import EventType

# Lazy import of android_sms_gateway to avoid import errors if not installed
try:
    from android_sms_gateway import client, domain
    SMS_GATEWAY_AVAILABLE = True
except ImportError:
    SMS_GATEWAY_AVAILABLE = False


logger = logging.getLogger("inboxerr.sms")


class SMSSender:
    """
    Service for sending SMS messages through the Android SMS Gateway.
    """
    
    def __init__(
        self,
        message_repository: MessageRepository,
        event_bus: Any
    ):
        """
        Initialize SMS sender service.
        
        Args:
            message_repository: Repository for message storage
            event_bus: Event bus for publishing events
        """
        self.message_repository = message_repository
        self.event_bus = event_bus
        self._semaphore = asyncio.Semaphore(10)  # Limit concurrent requests
        self._last_send_time = 0
        
        # Check if gateway client is available
        if not SMS_GATEWAY_AVAILABLE:
            logger.warning("Android SMS Gateway client not installed. SMS sending will be simulated.")
    
    async def send_message(
        self,
        *,
        phone_number: str,
        message_text: str,
        user_id: str,
        scheduled_at: Optional[datetime] = None,
        custom_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        campaign_id: Optional[str] = None,
        priority: int = 0,
        ttl: Optional[int] = None,
        sim_number: Optional[int] = None,
        is_encrypted: bool = False
    ) -> Dict[str, Any]:
        """
        Send a single SMS message.
        
        Args:
            phone_number: Recipient phone number
            message_text: Message content
            user_id: User ID
            scheduled_at: Optional scheduled delivery time
            custom_id: Optional custom ID for tracking
            metadata: Optional additional data
            campaign_id: Optional campaign ID
            priority: Message priority (0-127, ‚â•100 bypasses limits)
            ttl: Time-to-live in seconds
            sim_number: SIM card to use (1-3)
            is_encrypted: Whether message is encrypted
            
        Returns:
            Dict: Message details with status
            
        Raises:
            ValidationError: If phone number is invalid
            SMSGatewayError: If there's an error sending the message
        """
        # Validate phone number
        is_valid, formatted_number, error = validate_phone(phone_number)
        if not is_valid:
            raise ValidationError(message=f"Invalid phone number: {error}")
        
        # Create message in database
        db_message = await self.message_repository.create_message(
            phone_number=formatted_number,
            message_text=message_text,
            user_id=user_id,
            custom_id=custom_id,
            scheduled_at=scheduled_at,
            metadata=metadata or {},
            campaign_id=campaign_id
        )
        
        # If scheduled for future, return message details
        if scheduled_at and scheduled_at > datetime.utcnow():
            logger.info(f"Message {db_message.id} scheduled for {scheduled_at}")
            
            # Publish event
            await self.event_bus.publish(
                EventType.MESSAGE_SCHEDULED,
                {
                    "message_id": db_message.id,
                    "phone_number": formatted_number,
                    "scheduled_at": scheduled_at.isoformat(),
                    "user_id": user_id
                }
            )
            
            return db_message.dict()
        
        # Otherwise, send immediately
        try:
            # Send to gateway - use db_message.id as custom_id for 1:1 mapping
            # This ensures webhooks can easily find the corresponding message
            result = await self._send_to_gateway(
                phone_number=formatted_number,
                message_text=message_text,
                custom_id=db_message.id,  # Use our database ID directly
                priority=priority,
                ttl=ttl,
                sim_number=sim_number,
                is_encrypted=is_encrypted
            )
            
            # Update message status
            await self.message_repository.update_message_status(
                message_id=db_message.id,
                status=result.get("status", MessageStatus.PENDING),
                event_type="gateway_response",
                gateway_message_id=result.get("gateway_message_id"),
                data=result
            )
            
            # Get updated message
            updated_message = await self.message_repository.get_by_id(db_message.id)
            return updated_message.dict()
            
        except Exception as e:
            # Handle error
            error_status = MessageStatus.FAILED
            error_message = str(e)
            logger.error(f"Error sending message {db_message.id}: {error_message}")
            
            # Update message status
            await self.message_repository.update_message_status(
                message_id=db_message.id,
                status=error_status,
                event_type="send_error",
                reason=error_message,
                data={"error": error_message}
            )
            
            # Re-raise as SMSGatewayError
            if isinstance(e, RetryableError):
                raise SMSGatewayError(message=error_message, code="GATEWAY_ERROR", status_code=503)
            else:
                raise SMSGatewayError(message=error_message, code="GATEWAY_ERROR")
    
    async def send_batch(
        self,
        *,
        messages: List[MessageCreate],
        user_id: str,
        options: Optional[BatchOptions] = None,
        campaign_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Send a batch of SMS messages.
        
        Args:
            messages: List of messages to send
            user_id: User ID
            options: Optional batch processing options
            campaign_id: Optional campaign ID
            
        Returns:
            Dict: Batch details with status
            
        Raises:
            ValidationError: If any phone number is invalid
            SMSGatewayError: If there's an error sending the messages
        """
        if not messages:
            raise ValidationError(message="No messages provided")
        
        # Set default options
        if not options:
            options = BatchOptions(
                delay_between_messages=0.3,
                fail_on_first_error=False,
                retry_failed=True
            )
        
        # Create batch in database
        batch = await self.message_repository.create_batch(
            user_id=user_id,
            name=f"Batch {datetime.utcnow().isoformat()}",
            total=len(messages)
        )
        
        # Process in background
        asyncio.create_task(
            self._process_batch(
                messages=messages,
                user_id=user_id,
                batch_id=batch.id,
                campaign_id=campaign_id,
                options=options
            )
        )
        
        # Return batch details
        return {
            "batch_id": batch.id,
            "total": batch.total,
            "processed": 0,
            "successful": 0,
            "failed": 0,
            "status": batch.status,
            "created_at": batch.created_at
        }
    
    async def _process_batch(
        self,
        *,
        messages: List[MessageCreate],
        user_id: str,
        batch_id: str,
        campaign_id: Optional[str] = None,
        options: BatchOptions
    ) -> None:
        """
        Process a batch of messages in background.
        
        Args:
            messages: List of messages to send
            user_id: User ID
            batch_id: Batch ID
            campaign_id: Optional campaign ID
            options: Batch processing options
        """
        processed = 0
        successful = 0
        failed = 0
        
        # Calculate chunk size based on total messages
        # Use smaller chunks for larger batches to avoid overwhelming the system
        total_messages = len(messages)
        if total_messages <= 100:
            chunk_size = 10
        elif total_messages <= 1000:
            chunk_size = 25
        else:
            chunk_size = 50
            
        # Process in chunks for better performance
        for i in range(0, total_messages, chunk_size):
            chunk = messages[i:i+chunk_size]
            
            # Process chunk with concurrent tasks
            tasks = []
            for message in chunk:
                # Create task for each message
                task = asyncio.create_task(
                    self._process_single_message(
                        message=message,
                        user_id=user_id,
                        batch_id=batch_id,
                        campaign_id=campaign_id
                    )
                )
                tasks.append(task)
            
            # Wait for all tasks to complete
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Process results
            for result in results:
                processed += 1
                
                if isinstance(result, Exception):
                    # Failed message
                    failed += 1
                    logger.error(f"Error in batch {batch_id}: {str(result)}")
                    
                    # Stop on first error if configured
                    if options.fail_on_first_error:
                        break
                else:
                    # Successful message
                    successful += 1
            
            # Update batch progress
            await self.message_repository.update_batch_progress(
                batch_id=batch_id,
                increment_processed=len(chunk),
                increment_successful=sum(1 for r in results if not isinstance(r, Exception)),
                increment_failed=sum(1 for r in results if isinstance(r, Exception))
            )
            
            # Check if we should stop due to first error
            if options.fail_on_first_error and failed > 0:
                break
                
            # Delay between chunks to avoid overwhelming gateway
            if i + chunk_size < total_messages:
                await asyncio.sleep(options.delay_between_messages * 2)  # Double delay between chunks
        
        # Update batch status
        status = MessageStatus.PROCESSED
        if processed == 0:
            status = MessageStatus.FAILED
        elif failed > 0:
            status = "partial"
        
        await self.message_repository.update_batch_progress(
            batch_id=batch_id,
            status=status
        )
        
        # Publish event
        await self.event_bus.publish(
            EventType.BATCH_COMPLETED,
            {
                "batch_id": batch_id,
                "campaign_id": campaign_id,
                "total": len(messages),
                "processed": processed,
                "successful": successful,
                "failed": failed,
                "status": status,
                "user_id": user_id
            }
        )
    
    async def _process_single_message(
        self,
        *,
        message: MessageCreate,
        user_id: str,
        batch_id: Optional[str] = None,
        campaign_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Process a single message within a batch.
        
        Args:
            message: Message to send
            user_id: User ID
            batch_id: Optional batch ID
            campaign_id: Optional campaign ID
            
        Returns:
            Dict: Result of message processing
            
        Raises:
            Exception: Any error during processing
        """
        # Build metadata
        metadata = {}
        if batch_id:
            metadata["batch_id"] = batch_id
        if campaign_id:
            metadata["campaign_id"] = campaign_id
            
        # Set priority based on campaign
        # Campaigns get slightly higher priority but still below urgent messages
        priority = 50 if campaign_id else 0
            
        # Send message
        return await self.send_message(
            phone_number=message.phone_number,
            message_text=message.message,
            user_id=user_id,
            scheduled_at=message.scheduled_at,
            custom_id=message.custom_id,
            metadata=metadata,
            campaign_id=campaign_id,
            priority=priority
        )
    
    async def send_messages_bulk(
        self,
        *,
        messages: List[Dict[str, Any]],
        user_id: str,
        campaign_id: Optional[str] = None,
        batch_id: Optional[str] = None,
        chunk_size: int = 50
    ) -> List[Dict[str, Any]]:
        """
        Send multiple messages efficiently in bulk.
        
        Args:
            messages: List of message dictionaries with recipient and content
            user_id: User ID
            campaign_id: Optional campaign ID
            batch_id: Optional batch ID
            chunk_size: Number of messages to process in each chunk
            
        Returns:
            List[Dict]: List of results for each message
        """
        results = []
        
        # Process in chunks
        for i in range(0, len(messages), chunk_size):
            chunk = messages[i:i+chunk_size]
            chunk_results = await self._process_message_chunk(
                messages=chunk,
                user_id=user_id,
                campaign_id=campaign_id,
                batch_id=batch_id
            )
            results.extend(chunk_results)
            
            # Small delay between chunks to prevent overloading
            if i + chunk_size < len(messages):
                await asyncio.sleep(1)
        
        return results
    
    async def _process_message_chunk(
        self, 
        messages: List[Dict[str, Any]],
        user_id: str,
        campaign_id: Optional[str] = None,
        batch_id: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Process a chunk of messages concurrently.
        
        Args:
            messages: List of message dictionaries to process
            user_id: User ID
            campaign_id: Optional campaign ID
            batch_id: Optional batch ID
            
        Returns:
            List[Dict]: Results for each message
        """
        # Create tasks for all messages
        tasks = []
        for msg in messages:
            # Create database entries first to get IDs
            db_message = await self.message_repository.create_message(
                phone_number=msg["phone_number"],
                message_text=msg["message_text"],
                user_id=user_id,
                custom_id=msg.get("custom_id"),
                scheduled_at=msg.get("scheduled_at"),
                metadata=msg.get("metadata", {}),
                campaign_id=campaign_id
            )
            
            # Skip if scheduled for the future
            if db_message.scheduled_at and db_message.scheduled_at > datetime.utcnow():
                tasks.append(asyncio.create_task(
                    asyncio.sleep(0)  # Dummy task for scheduled messages
                ))
                continue
                
            # Create task to send via gateway
            task = asyncio.create_task(
                self._send_message_with_error_handling(
                    db_message=db_message,
                    phone_number=msg["phone_number"],
                    message_text=msg["message_text"],
                    priority=msg.get("priority", 0),
                    ttl=msg.get("ttl"),
                    sim_number=msg.get("sim_number"),
                    is_encrypted=msg.get("is_encrypted", False)
                )
            )
            tasks.append(task)
        
        # Wait for all tasks to complete
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            return [r for r in results if not isinstance(r, Exception)]
        
        return []
    
    async def _send_message_with_error_handling(
        self,
        *,
        db_message: Any,
        phone_number: str,
        message_text: str,
        priority: int = 0,
        ttl: Optional[int] = None,
        sim_number: Optional[int] = None,
        is_encrypted: bool = False
    ) -> Dict[str, Any]:
        """
        Send message with error handling and status updates.
        
        Args:
            db_message: Database message object
            phone_number: Recipient phone number
            message_text: Message content
            priority: Message priority
            ttl: Time-to-live in seconds
            sim_number: SIM card to use
            is_encrypted: Whether message is encrypted
            
        Returns:
            Dict: Result of message sending
        """
        try:
            # Send to gateway
            result = await self._send_to_gateway(
                phone_number=phone_number,
                message_text=message_text,
                custom_id=db_message.id,  # Use database ID directly
                priority=priority,
                ttl=ttl,
                sim_number=sim_number,
                is_encrypted=is_encrypted
            )
            
            # Update message status
            await self.message_repository.update_message_status(
                message_id=db_message.id,
                status=result.get("status", MessageStatus.PENDING),
                event_type="gateway_response",
                gateway_message_id=result.get("gateway_message_id"),
                data=result
            )
            
            return result
            
        except Exception as e:
            # Handle error
            error_status = MessageStatus.FAILED
            error_message = str(e)
            logger.error(f"Error sending message {db_message.id}: {error_message}")
            
            # Update message status
            await self.message_repository.update_message_status(
                message_id=db_message.id,
                status=error_status,
                event_type="send_error",
                reason=error_message,
                data={"error": error_message}
            )
            
            # Re-raise to be caught by caller
            raise
    
    async def schedule_batch_from_numbers(
        self,
        *,
        phone_numbers: List[str],
        message_text: str,
        user_id: str,
        scheduled_at: Optional[datetime] = None,
        campaign_id: Optional[str] = None
    ) -> str:
        """
        Schedule a batch of messages from a list of phone numbers.
        
        Args:
            phone_numbers: List of phone numbers
            message_text: Message content
            user_id: User ID
            scheduled_at: Optional scheduled delivery time
            campaign_id: Optional campaign ID
            
        Returns:
            str: Batch ID
            
        Raises:
            ValidationError: If any phone number is invalid
        """
        if not phone_numbers:
            raise ValidationError(message="No phone numbers provided")
        
        # Create messages
        messages = []
        for phone in phone_numbers:
            # Basic validation
            is_valid, formatted_number, error = validate_phone(phone)
            if is_valid:
                messages.append(
                    MessageCreate(
                        phone_number=formatted_number,
                        message=message_text,
                        scheduled_at=scheduled_at,
                        custom_id=str(uuid.uuid4())
                    )
                )
        
        if not messages:
            raise ValidationError(message="No valid phone numbers found")
        
        # Create and process batch
        result = await self.send_batch(
            messages=messages,
            user_id=user_id,
            campaign_id=campaign_id,
            options=BatchOptions(
                delay_between_messages=settings.DELAY_BETWEEN_SMS,
                fail_on_first_error=False,
                retry_failed=True
            )
        )
        
        return result["batch_id"]
    
    async def get_message(self, message_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """
        Get message details.
        
        Args:
            message_id: Message ID or custom ID
            user_id: User ID for authorization
            
        Returns:
            Dict: Message details or None if not found
        """
        # Try to get by ID first
        message = await self.message_repository.get_by_id(message_id)
        
        # If not found, try custom ID
        if not message:
            message = await self.message_repository.get_by_custom_id(message_id)
            
        # If not found, try gateway ID
        if not message:
            message = await self.message_repository.get_by_gateway_id(message_id)
        
        # Check authorization
        if message and str(message.user_id) != str(user_id):
            return None
        
        return message.dict() if message else None
    
    async def list_messages(
        self,
        *,
        filters: Dict[str, Any],
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Dict[str, Any]], int]:
        """
        List messages with filtering and pagination.
        
        Args:
            filters: Filter criteria
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Dict], int]: List of messages and total count
        """
        # Extract user_id from filters
        user_id = filters.pop("user_id", None)
        if not user_id:
            return [], 0
        
        # Get messages
        messages, total = await self.message_repository.list_messages_for_user(
            user_id=user_id,
            status=filters.get("status"),
            phone_number=filters.get("phone_number"),
            from_date=filters.get("from_date"),
            to_date=filters.get("to_date"),
            campaign_id=filters.get("campaign_id"),  # Support filtering by campaign
            skip=skip,
            limit=limit
        )
        
        # Convert to dict
        message_dicts = [message.dict() for message in messages]
        
        return message_dicts, total
    
    async def update_message_status(
        self,
        *,
        message_id: str,
        status: str,
        reason: Optional[str] = None,
        user_id: str
    ) -> Optional[Dict[str, Any]]:
        """
        Update message status.
        
        Args:
            message_id: Message ID
            status: New status
            reason: Reason for status change
            user_id: User ID for authorization
            
        Returns:
            Dict: Updated message or None if not found
        """
        # Get message
        message = await self.message_repository.get_by_id(message_id)
        if not message:
            return None
        
        # Check authorization
        if str(message.user_id) != str(user_id):
            return None
        
        # Update status
        updated = await self.message_repository.update_message_status(
            message_id=message_id,
            status=status,
            event_type="manual_update",
            reason=reason,
            data={"updated_by": user_id}
        )
        
        return updated.dict() if updated else None
    
    async def delete_message(self, message_id: str, user_id: str) -> bool:
        """
        Delete a message.
        
        Args:
            message_id: Message ID
            user_id: User ID for authorization
            
        Returns:
            bool: True if deleted, False otherwise
        """
        # Get message
        message = await self.message_repository.get_by_id(message_id)
        if not message:
            return False
        
        # Check authorization
        if str(message.user_id) != str(user_id):
            return False
        
        # Delete message
        return await self.message_repository.delete(id=message_id)
    
    async def get_task_status(self, task_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """
        Get status of a background task (batch).
        
        Args:
            task_id: Task/batch ID
            user_id: User ID for authorization
            
        Returns:
            Dict: Task status or None if not found
        """
        # Get batch
        batch = await self.message_repository.get_by_id(task_id)
        if not batch:
            return None
        
        # Check authorization
        if str(batch.user_id) != str(user_id):
            return None
        
        # Get message stats
        messages, total = await self.message_repository.get_messages_for_batch(
            batch_id=task_id,
            limit=5  # Just get the first few for preview
        )
        
        # Convert to dict
        message_previews = [message.dict() for message in messages]
        
        return {
            "id": batch.id,
            "status": batch.status,
            "total": batch.total,
            "processed": batch.processed,
            "successful": batch.successful,
            "failed": batch.failed,
            "created_at": batch.created_at,
            "completed_at": batch.completed_at,
            "message_previews": message_previews
        }
    
    async def _send_to_gateway(
        self,
        *,
        phone_number: str,
        message_text: str,
        custom_id: str,
        priority: int = 0,
        ttl: Optional[int] = None,
        sim_number: Optional[int] = None,
        is_encrypted: bool = False
    ) -> Dict[str, Any]:
        """
        Send message to SMS gateway.
        
        Args:
            phone_number: Recipient phone number
            message_text: Message content
            custom_id: Custom ID for tracking (usually our database ID)
            priority: Message priority (0-127, ‚â•100 bypasses limits)
            ttl: Time-to-live in seconds
            sim_number: SIM card to use (1-3)
            is_encrypted: Whether message is encrypted
            
        Returns:
            Dict: Gateway response
            
        Raises:
            SMSGatewayError: If there's an error sending the message
            RetryableError: If the error is temporary and can be retried
        """
        # Enforce rate limit (only for non-high-priority messages)
        if priority < 100:
            await self._enforce_rate_limit()
        
        # Check if gateway client is available
        if not SMS_GATEWAY_AVAILABLE:
            # Simulate sending for development
            logger.warning("Simulating SMS send to %s: %s", phone_number, message_text[:30])
            await asyncio.sleep(0.5)  # Simulate API delay
            
            # Return simulated response
            return {
                "status": MessageStatus.SENT,
                "gateway_message_id": f"sim_{uuid.uuid4()}",
                "phone_number": phone_number,
                "timestamp": datetime.utcnow().isoformat()
            }
        
        # Use semaphore to limit concurrent requests
        async with self._semaphore:
            try:
                # Create client
                async with client.AsyncAPIClient(
                    login=settings.SMS_GATEWAY_LOGIN,
                    password=settings.SMS_GATEWAY_PASSWORD,
                    base_url=settings.SMS_GATEWAY_URL
                ) as sms_client:
                    # Build message with additional parameters
                    message_params = {
                        "id": custom_id,
                        "message": message_text,
                        "phone_numbers": [phone_number],
                        "with_delivery_report": True,
                        "priority": priority
                    }
                    
                    # Add optional parameters if provided
                    if ttl is not None:
                        message_params["ttl"] = ttl
                    if sim_number is not None:
                        message_params["sim_number"] = sim_number
                    if is_encrypted:
                        message_params["is_encrypted"] = True
                    
                    # Create message
                    message = domain.Message(**message_params)
                    
                    # Send message
                    logger.debug(f"Sending to gateway: {phone_number}, message: {message_text[:30]}...")
                    response = await sms_client.send(message)
                    logger.debug(f"Gateway response: {response}")
                    
                    # Check for errors in recipients
                    recipient_state = response.recipients[0] if response.recipients else None
                    if recipient_state and recipient_state.error:
                        raise SMSGatewayError(message=recipient_state.error)
                    
                    # Extract status
                    status = str(response.state.value).lower() if hasattr(response, 'state') else MessageStatus.PENDING
                    gateway_id = getattr(response, 'id', None)
                    
                    # Return result
                    return {
                        "status": status,
                        "gateway_message_id": gateway_id,
                        "phone_number": phone_number,
                        "timestamp": datetime.utcnow().isoformat()
                    }
                    
            except client.ClientError as e:
                logger.error(f"SMS gateway client error: {str(e)}")
                raise RetryableError(
                    message=f"SMS gateway client error: {str(e)}",
                    retry_after=30.0
                )
            except Exception as e:
                logger.error(f"SMS gateway error: {str(e)}")
                raise SMSGatewayError(message=f"SMS gateway error: {str(e)}")
    
    async def _enforce_rate_limit(self) -> None:
        """
        Enforce rate limiting for SMS sending.
        
        Adds dynamic delay based on settings.DELAY_BETWEEN_SMS.
        """
        current_time = asyncio.get_event_loop().time()
        elapsed = current_time - self._last_send_time
        remaining_delay = max(0, settings.DELAY_BETWEEN_SMS - elapsed)
        
        if remaining_delay > 0:
            await asyncio.sleep(remaining_delay)
        
        self._last_send_time = asyncio.get_event_loop().time()


# Dependency injection function
async def get_sms_sender():
    """Get SMS sender service instance."""
    from app.db.session import get_repository
    from app.db.repositories.messages import MessageRepository
    from app.services.event_bus.bus import get_event_bus
    
    message_repository = await get_repository(MessageRepository)
    event_bus = get_event_bus()
    
    return SMSSender(message_repository, event_bus)
</file>

<file path="app/services/webhooks/manager.py">
# app/services/webhooks/manager.py
import logging
import hmac
import hashlib
import time
import json
from typing import Dict, Any, Optional, List, Tuple
import httpx
from fastapi.encoders import jsonable_encoder

from app.core.config import settings
from app.db.repositories.messages import MessageRepository
from app.schemas.message import MessageStatus
from app.services.event_bus.bus import get_event_bus
from app.services.event_bus.events import EventType
from app.services.webhooks.models import (
    WebhookPayload, SmsReceivedPayload, SmsSentPayload, 
    SmsDeliveredPayload, SmsFailedPayload, SystemPingPayload
)

logger = logging.getLogger("inboxerr.webhooks")

# Track registered webhooks
_registered_webhooks: Dict[str, str] = {}  # event_type -> webhook_id
_initialized = False

async def initialize_webhook_manager() -> None:
    """Initialize the webhook manager and register with SMS Gateway."""
    global _initialized
    
    if _initialized:
        return
        
    logger.info("Initializing webhook manager")
    
    # Register webhooks for each event type
    events_to_register = [
        "sms:sent", 
        "sms:delivered", 
        "sms:failed"
    ]
    
    for event_type in events_to_register:
        webhook_id = await register_webhook_with_gateway(event_type)
        if webhook_id:
            _registered_webhooks[event_type] = webhook_id
    
    _initialized = True
    logger.info(f"Webhook manager initialized, registered webhooks: {len(_registered_webhooks)}")

async def shutdown_webhook_manager() -> None:
    """Clean up webhook manager resources."""
    logger.info("Shutting down webhook manager")
    
    # Unregister all webhooks
    for event_type, webhook_id in _registered_webhooks.items():
        await unregister_webhook_from_gateway(webhook_id)
    
    _registered_webhooks.clear()
    logger.info("Webhook manager shutdown complete")

async def register_webhook_with_gateway(event_type: str) -> Optional[str]:
    """
    Register a webhook for a specific event type.
    
    Args:
        event_type: Event type to register for
        
    Returns:
        str: Webhook ID if registration successful
    """
    if not settings.SMS_GATEWAY_URL or not settings.SMS_GATEWAY_LOGIN or not settings.SMS_GATEWAY_PASSWORD:
        logger.warning("SMS Gateway credentials not configured, skipping webhook registration")
        return None
    
    # Webhook URL for the Gateway to call
    webhook_url = f"{settings.API_BASE_URL}{settings.API_PREFIX}/webhooks/gateway"
    
    try:
        # Create httpx client with authentication
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{settings.SMS_GATEWAY_URL}/webhooks",
                auth=(settings.SMS_GATEWAY_LOGIN, settings.SMS_GATEWAY_PASSWORD),
                json={
                    "id": f"inboxerr-{event_type}",  # Custom ID for tracking
                    "url": webhook_url,
                    "event": event_type
                },
                timeout=10.0
            )
            
            if response.status_code in (200, 201):
                webhook_data = response.json()
                webhook_id = webhook_data.get("id")
                logger.info(f"Successfully registered webhook for {event_type}: {webhook_id}")
                return webhook_id
            else:
                logger.error(f"Failed to register webhook for {event_type}: {response.status_code} - {response.text}")
                return None
                
    except Exception as e:
        logger.error(f"Error registering webhook for {event_type}: {e}")
        return None

async def unregister_webhook_from_gateway(webhook_id: str) -> bool:
    """
    Unregister a webhook from SMS Gateway.
    
    Args:
        webhook_id: Webhook ID
        
    Returns:
        bool: True if unregistration successful
    """
    if not settings.SMS_GATEWAY_URL or not settings.SMS_GATEWAY_LOGIN or not settings.SMS_GATEWAY_PASSWORD:
        logger.warning("SMS Gateway credentials not configured, skipping webhook unregistration")
        return False
    
    try:
        # Create httpx client with authentication
        async with httpx.AsyncClient() as client:
            response = await client.delete(
                f"{settings.SMS_GATEWAY_URL}/webhooks/{webhook_id}",
                auth=(settings.SMS_GATEWAY_LOGIN, settings.SMS_GATEWAY_PASSWORD),
                timeout=10.0
            )
            
            if response.status_code in (200, 204):
                logger.info(f"Successfully unregistered webhook: {webhook_id}")
                return True
            else:
                logger.error(f"Failed to unregister webhook: {response.status_code} - {response.text}")
                return False
                
    except Exception as e:
        logger.error(f"Error unregistering webhook: {e}")
        return False

async def process_gateway_webhook(raw_body: bytes, headers: Dict[str, str]) -> Tuple[bool, Dict[str, Any]]:
    """
    Process a webhook received from the SMS Gateway.
    
    Args:
        raw_body: Raw request body
        headers: Request headers
        
    Returns:
        Tuple[bool, Dict]: (success, processed_data)
    """
    # Decode raw body for payload processing
    payload_str = raw_body.decode('utf-8')
    
    try:
        # Parse JSON
        payload_dict = json.loads(payload_str)
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in webhook: {e}")
        return False, {"error": "Invalid JSON"}
    
    # Verify webhook signature if enabled
    if settings.WEBHOOK_SIGNATURE_KEY:
        if not verify_webhook_signature(payload_str, headers):
            logger.warning("Invalid webhook signature")
            return False, {"error": "Invalid signature"}
    
    # Validate basic payload structure
    try:
        base_payload = WebhookPayload(**payload_dict)
    except Exception as e:
        logger.error(f"Invalid webhook payload structure: {e}")
        return False, {"error": "Invalid payload structure"}
    
    event_type = base_payload.event
    gateway_id = base_payload.id
    
    logger.info(f"Processing webhook event: {event_type}, gateway ID: {gateway_id}")
    
    # Process based on event type
    try:
        if event_type == "sms:received":
            payload = SmsReceivedPayload(**payload_dict["payload"])
            result = await process_sms_received(base_payload, payload)
        elif event_type == "sms:sent":
            payload = SmsSentPayload(**payload_dict["payload"])
            result = await process_sms_sent(base_payload, payload)
        elif event_type == "sms:delivered":
            payload = SmsDeliveredPayload(**payload_dict["payload"])
            result = await process_sms_delivered(base_payload, payload)
        elif event_type == "sms:failed":
            payload = SmsFailedPayload(**payload_dict["payload"])
            result = await process_sms_failed(base_payload, payload)
        elif event_type == "system:ping":
            payload = SystemPingPayload(**payload_dict["payload"])
            result = await process_system_ping(base_payload, payload)
        else:
            logger.warning(f"Unknown webhook event type: {event_type}")
            return False, {"error": "Unknown event type"}
            
        return True, result
        
    except Exception as e:
        logger.error(f"Error processing webhook: {e}", exc_info=True)
        return False, {"error": str(e)}

def verify_webhook_signature(payload: str, headers: Dict[str, str]) -> bool:
    """
    Verify webhook signature from SMS Gateway.
    
    Args:
        payload: Webhook payload string
        headers: Request headers
        
    Returns:
        bool: True if signature is valid
    """
    signature = headers.get("X-Signature")
    timestamp = headers.get("X-Timestamp")
    
    if not signature or not timestamp:
        logger.warning("Missing signature headers")
        return False
    
    # Verify timestamp is recent (within tolerance)
    try:
        ts = int(timestamp)
        current_time = int(time.time())
        if abs(current_time - ts) > settings.WEBHOOK_TIMESTAMP_TOLERANCE:
            logger.warning(f"Webhook timestamp too old: {timestamp}")
            return False
    except (ValueError, TypeError):
        logger.warning(f"Invalid timestamp: {timestamp}")
        return False
    
    # Calculate expected signature
    message = (payload + timestamp).encode()
    expected_signature = hmac.new(
        settings.WEBHOOK_SIGNATURE_KEY.encode(),
        message,
        hashlib.sha256
    ).hexdigest()
    
    # Compare signatures (constant-time comparison)
    return hmac.compare_digest(expected_signature, signature)

async def process_sms_received(base_payload: WebhookPayload, payload: SmsReceivedPayload) -> Dict[str, Any]:
    """Process SMS received event."""
    # For inbound messages - not the main focus for now
    logger.info(f"Received SMS: {payload.phone_number} -> '{payload.message}'")
    
    # Publish event for other components
    event_bus = get_event_bus()
    await event_bus.publish(
        EventType.SMS_RECEIVED,
        {
            "gateway_id": base_payload.id,
            "device_id": base_payload.device_id,
            "phone_number": payload.phone_number,
            "message": payload.message,
            "timestamp": payload.received_at.isoformat()
        }
    )
    
    return {
        "status": "processed",
        "event": "sms:received",
        "phone_number": payload.phone_number
    }

async def process_sms_sent(base_payload: WebhookPayload, payload: SmsSentPayload) -> Dict[str, Any]:
    """Process SMS sent event."""
    logger.info(f"SMS sent to {payload.phone_number}, gateway ID: {base_payload.id}")
    
    # Get message repository
    from app.db.session import get_repository
    message_repo = await get_repository(MessageRepository)
    
    # Extract gateway message ID
    gateway_id = base_payload.id
    
    # Find message by gateway ID
    message = await message_repo.get_by_gateway_id(gateway_id)
    if not message:
        # This could be normal if we didn't originate this message
        logger.info(f"No matching message found for gateway ID: {gateway_id}")
        return {
            "status": "acknowledged",
            "event": "sms:sent",
            "message_found": False
        }
    
    # Update message status
    updated_message = await message_repo.update_message_status(
        message_id=message.id,
        status=MessageStatus.SENT,
        event_type="webhook",
        gateway_message_id=gateway_id,
        data=jsonable_encoder(base_payload)
    )
    
    if not updated_message:
        logger.warning(f"Failed to update message status for ID: {message.id}")
        return {
            "status": "error",
            "event": "sms:sent",
            "message_id": message.id,
            "error": "Failed to update message status"
        }
    
    # Publish event
    event_bus = get_event_bus()
    await event_bus.publish(
        EventType.MESSAGE_SENT,
        {
            "message_id": message.id,
            "gateway_id": gateway_id,
            "phone_number": payload.phone_number,
            "user_id": message.user_id,
            "timestamp": payload.sent_at.isoformat()
        }
    )
    
    return {
        "status": "processed",
        "event": "sms:sent",
        "message_id": message.id,
        "phone_number": payload.phone_number
    }

async def process_sms_delivered(base_payload: WebhookPayload, payload: SmsDeliveredPayload) -> Dict[str, Any]:
    """Process SMS delivered event."""
    logger.info(f"SMS delivered to {payload.phone_number}, gateway ID: {base_payload.id}")
    
    # Get message repository
    from app.db.session import get_repository
    message_repo = await get_repository(MessageRepository)
    
    # Extract gateway message ID
    gateway_id = base_payload.id
    
    # Find message by gateway ID
    message = await message_repo.get_by_gateway_id(gateway_id)
    if not message:
        logger.info(f"No matching message found for gateway ID: {gateway_id}")
        return {
            "status": "acknowledged",
            "event": "sms:delivered",
            "message_found": False
        }
    
    # Update message status
    updated_message = await message_repo.update_message_status(
        message_id=message.id,
        status=MessageStatus.DELIVERED,
        event_type="webhook",
        gateway_message_id=gateway_id,
        data=jsonable_encoder(base_payload)
    )
    
    if not updated_message:
        logger.warning(f"Failed to update message status for ID: {message.id}")
        return {
            "status": "error",
            "event": "sms:delivered",
            "message_id": message.id,
            "error": "Failed to update message status"
        }
    
    # Publish event
    event_bus = get_event_bus()
    await event_bus.publish(
        EventType.MESSAGE_DELIVERED,
        {
            "message_id": message.id,
            "gateway_id": gateway_id,
            "phone_number": payload.phone_number,
            "user_id": message.user_id,
            "timestamp": payload.delivered_at.isoformat()
        }
    )
    
    return {
        "status": "processed",
        "event": "sms:delivered",
        "message_id": message.id,
        "phone_number": payload.phone_number
    }

async def process_sms_failed(base_payload: WebhookPayload, payload: SmsFailedPayload) -> Dict[str, Any]:
    """Process SMS failed event."""
    logger.info(f"SMS failed for {payload.phone_number}, reason: {payload.reason}, gateway ID: {base_payload.id}")
    
    # Get message repository
    from app.db.session import get_repository
    message_repo = await get_repository(MessageRepository)
    
    # Extract gateway message ID and failure reason
    gateway_id = base_payload.id
    reason = payload.reason
    
    # Find message by gateway ID
    message = await message_repo.get_by_gateway_id(gateway_id)
    if not message:
        logger.info(f"No matching message found for gateway ID: {gateway_id}")
        return {
            "status": "acknowledged",
            "event": "sms:failed",
            "message_found": False
        }
    
    # Update message status
    updated_message = await message_repo.update_message_status(
        message_id=message.id,
        status=MessageStatus.FAILED,
        event_type="webhook",
        reason=reason,
        gateway_message_id=gateway_id,
        data=jsonable_encoder(base_payload)
    )
    
    if not updated_message:
        logger.warning(f"Failed to update message status for ID: {message.id}")
        return {
            "status": "error",
            "event": "sms:failed",
            "message_id": message.id,
            "error": "Failed to update message status"
        }
    
    # Publish event
    event_bus = get_event_bus()
    await event_bus.publish(
        EventType.MESSAGE_FAILED,
        {
            "message_id": message.id,
            "gateway_id": gateway_id,
            "phone_number": payload.phone_number,
            "user_id": message.user_id,
            "reason": reason,
            "timestamp": payload.failed_at.isoformat()
        }
    )
    
    return {
        "status": "processed",
        "event": "sms:failed",
        "message_id": message.id,
        "phone_number": payload.phone_number,
        "reason": reason
    }

async def process_system_ping(base_payload: WebhookPayload, payload: SystemPingPayload) -> Dict[str, Any]:
    """Process system ping event."""
    logger.info(f"System ping received from device: {base_payload.device_id}")
    
    # Simple acknowledgment
    return {
        "status": "acknowledged",
        "event": "system:ping",
        "device_id": base_payload.device_id
    }
</file>

<file path="project_structure.md">
# Inboxerr Backend Project Structure

```
/inboxerr-backend/
‚îÇ
‚îú‚îÄ‚îÄ /app/                      # Application package
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py            # Package initializer
‚îÇ   ‚îú‚îÄ‚îÄ main.py                # FastAPI application entry point
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /api/                  # API endpoints and routing
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router.py          # Main API router
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ /v1/               # API version 1
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ endpoints/     # API endpoints by resource
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py    # Authentication endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ messages.py # SMS message endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webhooks.py # Webhook endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metrics.py  # Metrics and reporting endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.py # API-specific dependencies
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /core/                 # Core application components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py          # Application configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.py        # Security utilities (auth, encryption)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py          # Event handlers for application lifecycle
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exceptions.py      # Custom exception classes
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /db/                   # Database related code
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py            # Base DB session setup
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.py         # DB session management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repositories/      # Repository pattern implementations
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ base.py        # Base repository class
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ messages.py    # Message repository
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ users.py       # User repository
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /models/               # Database models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py            # Base model class
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ message.py         # SMS message model
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py            # User model
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook.py         # Webhook model
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /schemas/              # Pydantic schemas for API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py            # Base schema
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ message.py         # Message schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py            # User schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webhook.py         # Webhook schemas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metrics.py         # Metrics schemas
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /services/             # Business logic services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sms/               # SMS related services
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sender.py      # SMS sender implementation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validator.py   # Phone/message validation
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gateway.py     # SMS gateway client
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event_bus/         # Event management
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bus.py         # Event bus implementation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py      # Event definitions
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handlers/      # Event handlers
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ message_handlers.py
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ system_handlers.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webhooks/          # Webhook handling
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handler.py     # Webhook processor
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ manager.py     # Webhook registration/management
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metrics/           # Metrics collection
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ collector.py   # Metrics collector
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ /utils/                # Utility functions and helpers
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ phone.py           # Phone number utilities
‚îÇ       ‚îú‚îÄ‚îÄ logging.py         # Logging configuration
‚îÇ       ‚îî‚îÄ‚îÄ pagination.py      # Pagination utilities
‚îÇ
‚îú‚îÄ‚îÄ /alembic/                  # Database migrations
‚îÇ   ‚îú‚îÄ‚îÄ env.py                 # Alembic environment
‚îÇ   ‚îú‚îÄ‚îÄ README                 # Alembic readme
‚îÇ   ‚îú‚îÄ‚îÄ script.py.mako         # Migration script template
‚îÇ   ‚îî‚îÄ‚îÄ /versions/             # Migration scripts
‚îÇ
‚îú‚îÄ‚îÄ /tests/                    # Test suite
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py            # Test configuration and fixtures
‚îÇ   ‚îú‚îÄ‚îÄ /unit/                 # Unit tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ /services/         # Tests for services
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ /api/              # Tests for API endpoints
‚îÇ   ‚îî‚îÄ‚îÄ /integration/          # Integration tests
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îî‚îÄ‚îÄ /api/              # API integration tests
‚îÇ
‚îú‚îÄ‚îÄ /scripts/                  # Utility scripts
‚îÇ   ‚îú‚îÄ‚îÄ seed_db.py             # Database seeding script
‚îÇ   ‚îî‚îÄ‚îÄ generate_keys.py       # Generate security keys
‚îÇ
‚îú‚îÄ‚îÄ .env.example               # Example environment variables
‚îú‚îÄ‚îÄ .gitignore                 # Git ignore file
‚îú‚îÄ‚îÄ docker-compose.yml         # Docker Compose configuration
‚îú‚îÄ‚îÄ Dockerfile                 # Docker build configuration
‚îú‚îÄ‚îÄ pyproject.toml             # Python project metadata
‚îú‚îÄ‚îÄ requirements.txt           # Python dependencies
‚îú‚îÄ‚îÄ requirements-dev.txt       # Development dependencies
‚îî‚îÄ‚îÄ README.md                  # Project documentation
```
</file>

<file path="README.md">
# Inboxerr Backend

API backend for SMS management and delivery.

## Features

- ‚úÖ Send individual and batch SMS messages
- ‚úÖ Track message delivery status
- ‚úÖ Import contacts from CSV
- ‚úÖ Scheduled message delivery
- ‚úÖ Webhook integration for real-time updates
- ‚úÖ User authentication and API key management
- ‚úÖ Message templates
- ‚úÖ Comprehensive retry handling
- ‚úÖ Event-driven architecture

## Technology Stack

- **Framework**: FastAPI
- **Database**: PostgreSQL with SQLAlchemy (async)
- **Authentication**: JWT and API keys
- **Containerization**: Docker & Docker Compose
- **API Documentation**: OpenAPI/Swagger
- **Testing**: pytest
- **SMS Gateway Integration**: Android SMS Gateway

## Getting Started

### Prerequisites

- Docker and Docker Compose
- Python 3.10+
- Android SMS Gateway credentials

### Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/inboxerr-backend.git
   cd inboxerr-backend
   ```

2. Copy the example environment file:
   ```bash
   cp .env.example .env
   ```
   
3. Update the `.env` file with your configuration:
   ```
   SMS_GATEWAY_URL=https://endpointnumber1.work.gd/api/3rdparty/v1
   SMS_GATEWAY_LOGIN=your_login
   SMS_GATEWAY_PASSWORD=your_password
   SECRET_KEY=your_secret_key
   ```

4. Start the application with Docker Compose:
   ```bash
   docker-compose up -d
   ```

5. Run database migrations:
   ```bash
   docker-compose exec api alembic upgrade head
   ```

6. Access the API at `http://localhost:8000/api/docs`

### Development Setup

For local development without Docker:

1. Create a virtual environment:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   pip install -r requirements-dev.txt
   ```

3. Set up environment variables:
   ```bash
   export DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/inboxerr
   export SMS_GATEWAY_URL=https://endpointnumber1.work.gd/api/3rdparty/v1
   export SMS_GATEWAY_LOGIN=your_login
   export SMS_GATEWAY_PASSWORD=your_password
   ```

4. Run the application:
   ```bash
   uvicorn app.main:app --reload
   ```

## API Endpoints

### Authentication

- `POST /api/v1/auth/token` - Get access token
- `POST /api/v1/auth/register` - Register new user
- `GET /api/v1/auth/me` - Get current user info
- `POST /api/v1/auth/keys` - Create API key
- `GET /api/v1/auth/keys` - List API keys

### Messages

- `POST /api/v1/messages/send` - Send a single message
- `POST /api/v1/messages/batch` - Send batch of messages
- `POST /api/v1/messages/import` - Import contacts and send messages
- `GET /api/v1/messages/{message_id}` - Get message details
- `GET /api/v1/messages` - List messages
- `PUT /api/v1/messages/{message_id}/status` - Update message status
- `DELETE /api/v1/messages/{message_id}` - Delete message

### Webhooks

- `GET /api/v1/webhooks` - List webhooks
- `POST /api/v1/webhooks` - Register webhook
- `DELETE /api/v1/webhooks/{webhook_id}` - Delete webhook
- `GET /api/v1/webhooks/logs` - Get webhook delivery logs

## Project Structure

```
/inboxerr-backend/
‚îÇ
‚îú‚îÄ‚îÄ /app/                      # Application package
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py            # Package initializer
‚îÇ   ‚îú‚îÄ‚îÄ main.py                # FastAPI application entry point
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /api/                  # API endpoints and routing
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router.py          # Main API router
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ /v1/               # API version 1
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ endpoints/     # API endpoints by resource
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py    # Authentication endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ messages.py # SMS message endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webhooks.py # Webhook endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metrics.py  # Metrics and reporting endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.py # API-specific dependencies
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /core/                 # Core application components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py          # Application configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.py        # Security utilities (auth, encryption)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py          # Event handlers for application lifecycle
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exceptions.py      # Custom exception classes
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /db/                   # Database related code
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py            # Base DB session setup
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.py         # DB session management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repositories/      # Repository pattern implementations
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ base.py        # Base repository class
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ messages.py    # Message repository
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ users.py       # User repository
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /models/               # Database models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py            # Base model class
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ message.py         # SMS message model
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py            # User model
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook.py         # Webhook model
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /schemas/              # Pydantic schemas for API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py            # Base schema
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ message.py         # Message schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py            # User schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webhook.py         # Webhook schemas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metrics.py         # Metrics schemas
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ /services/             # Business logic services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sms/               # SMS related services
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sender.py      # SMS sender implementation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validator.py   # Phone/message validation
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gateway.py     # SMS gateway client
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event_bus/         # Event management
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bus.py         # Event bus implementation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py      # Event definitions
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handlers/      # Event handlers
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ message_handlers.py
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ system_handlers.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webhooks/          # Webhook handling
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handler.py     # Webhook processor
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ manager.py     # Webhook registration/management
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metrics/           # Metrics collection
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ collector.py   # Metrics collector
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ /utils/                # Utility functions and helpers
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ phone.py           # Phone number utilities
‚îÇ       ‚îú‚îÄ‚îÄ logging.py         # Logging configuration
‚îÇ       ‚îî‚îÄ‚îÄ pagination.py      # Pagination utilities
‚îÇ
‚îú‚îÄ‚îÄ /alembic/                  # Database migrations
‚îÇ   ‚îú‚îÄ‚îÄ env.py                 # Alembic environment
‚îÇ   ‚îú‚îÄ‚îÄ README                 # Alembic readme
‚îÇ   ‚îú‚îÄ‚îÄ script.py.mako         # Migration script template
‚îÇ   ‚îî‚îÄ‚îÄ /versions/             # Migration scripts
‚îÇ
‚îú‚îÄ‚îÄ /tests/                    # Test suite
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py            # Test configuration and fixtures
‚îÇ   ‚îú‚îÄ‚îÄ /unit/                 # Unit tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ /services/         # Tests for services
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ /api/              # Tests for API endpoints
‚îÇ   ‚îî‚îÄ‚îÄ /integration/          # Integration tests
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îî‚îÄ‚îÄ /api/              # API integration tests
‚îÇ
‚îú‚îÄ‚îÄ /scripts/                  # Utility scripts
‚îÇ   ‚îú‚îÄ‚îÄ seed_db.py             # Database seeding script
‚îÇ   ‚îî‚îÄ‚îÄ generate_keys.py       # Generate security keys
‚îÇ
‚îú‚îÄ‚îÄ .env.example               # Example environment variables
‚îú‚îÄ‚îÄ .gitignore                 # Git ignore file
‚îú‚îÄ‚îÄ docker-compose.yml         # Docker Compose configuration
‚îú‚îÄ‚îÄ Dockerfile                 # Docker build configuration
‚îú‚îÄ‚îÄ pyproject.toml             # Python project metadata
‚îú‚îÄ‚îÄ requirements.txt           # Python dependencies
‚îú‚îÄ‚îÄ requirements-dev.txt       # Development dependencies
‚îî‚îÄ‚îÄ README.md                  # Project documentation
```

## Usage Examples

### Sending a Single SMS

```python
import requests
import json

url = "http://localhost:8000/api/v1/messages/send"
headers = {
    "Authorization": "Bearer YOUR_ACCESS_TOKEN",
    "Content-Type": "application/json"
}
data = {
    "phone_number": "+1234567890",
    "message": "Hello from Inboxerr!"
}

response = requests.post(url, headers=headers, data=json.dumps(data))
print(response.json())
```

### Importing Contacts from CSV

```python
import requests

url = "http://localhost:8000/api/v1/messages/import"
headers = {
    "Authorization": "Bearer YOUR_ACCESS_TOKEN"
}
files = {
    "file": open("contacts.csv", "rb")
}
data = {
    "message_template": "Hello {{name}}, this is a test message!"
}

response = requests.post(url, headers=headers, files=files, data=data)
print(response.json())
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
</file>

<file path="requirements.txt">
# FastAPI and ASGI server
fastapi>=0.103.1
uvicorn[standard]>=0.23.2
python-multipart>=0.0.6
email-validator>=2.0.0

# Database
sqlalchemy>=2.0.20
alembic>=1.12.0
asyncpg>=0.28.0
aiosqlite>=0.21.0

# Authentication
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
pyjwt>=2.8.0

# Settings management
pydantic>=2.3.0
pydantic-settings>=2.0.3

# Phone number validation
phonenumbers>=8.13.20

# SMS Gateway client
android-sms-gateway>=1.0.0

# HTTP client for webhook delivery
httpx>=0.25.0

# Utilities
python-dateutil>=2.8.2
pytz>=2023.3
</file>

</files>
