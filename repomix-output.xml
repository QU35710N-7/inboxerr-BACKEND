This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
alembic.ini
alembic/env.py
alembic/README
alembic/script.py.mako
alembic/versions/65b12145bf1a_add_message_templates_table.py
alembic/versions/a5a3f106534b_make_datetime_fields_timezone_aware.py
app/api/router.py
app/api/v1/dependencies.py
app/api/v1/endpoints/auth.py
app/api/v1/endpoints/campaigns.py
app/api/v1/endpoints/messages.py
app/api/v1/endpoints/metrics.py
app/api/v1/endpoints/templates.py
app/api/v1/endpoints/webhooks.py
app/core/config.py
app/core/events.py
app/core/exceptions.py
app/core/security.py
app/db/base.py
app/db/repositories/base.py
app/db/repositories/campaigns.py
app/db/repositories/messages.py
app/db/repositories/templates.py
app/db/repositories/users.py
app/db/repositories/webhooks.py
app/db/session.py
app/main.py
app/models/base.py
app/models/campaign.py
app/models/message.py
app/models/user.py
app/models/webhook.py
app/schemas/campaign.py
app/schemas/message.py
app/schemas/template.py
app/schemas/user.py
app/scripts/create_admin.py
app/services/campaigns/processor.py
app/services/event_bus/bus.py
app/services/event_bus/events.py
app/services/metrics/collector.py
app/services/rate_limiter.py
app/services/sms/retry_engine.py
app/services/sms/sender.py
app/services/webhooks/manager.py
app/services/webhooks/models.py
app/utils/datetime.py
app/utils/error_handling.py
app/utils/pagination.py
app/utils/phone.py
database-schema.md
docker-compose.yml
Dockerfile
docs/FRONTEND_API_SETUP.md
docs/FRONTEND_DEVELOPER_GUIDE.md
docs/Message Template System - User Guide.md
project_structure.md
README.md
requirements.txt
scripts/generate_migration.py
scripts/mvp.sh
scripts/reset_db.py
scripts/run_tests.py
scripts/seed_db.py
scripts/seed_frontend_data.py
scripts/setup_test_db.py
tests/conftest.py
tests/core_functionality_test.py
tests/unit/api/messages/test_messages_endpoints.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="alembic/versions/a5a3f106534b_make_datetime_fields_timezone_aware.py">
"""Make datetime fields timezone-aware

Revision ID: a5a3f106534b
Revises: 65b12145bf1a
Create Date: 2025-04-29 21:44:26.340452

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'a5a3f106534b'
down_revision: Union[str, None] = '65b12145bf1a'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('apikey', 'expires_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('apikey', 'last_used_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('apikey', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('apikey', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('campaign', 'scheduled_start_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('campaign', 'scheduled_end_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('campaign', 'started_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('campaign', 'completed_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('campaign', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('campaign', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('message', 'scheduled_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('message', 'sent_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('message', 'delivered_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('message', 'failed_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('message', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('message', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('messagebatch', 'completed_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('messagebatch', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('messagebatch', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('messageevent', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('messageevent', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('messagetemplate', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('messagetemplate', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('user', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('user', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('webhook', 'last_triggered_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('webhook', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('webhook', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('webhookdelivery', 'next_retry_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('webhookdelivery', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('webhookdelivery', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('webhookevent', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('webhookevent', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('webhookevent', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('webhookevent', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('webhookdelivery', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('webhookdelivery', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('webhookdelivery', 'next_retry_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('webhook', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('webhook', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('webhook', 'last_triggered_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('user', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('user', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('messagetemplate', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('messagetemplate', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('messageevent', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('messageevent', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('messagebatch', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('messagebatch', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('messagebatch', 'completed_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('message', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('message', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('message', 'failed_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('message', 'delivered_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('message', 'sent_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('message', 'scheduled_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('campaign', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('campaign', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('campaign', 'completed_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('campaign', 'started_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('campaign', 'scheduled_end_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('campaign', 'scheduled_start_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('apikey', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('apikey', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('apikey', 'last_used_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('apikey', 'expires_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    # ### end Alembic commands ###
</file>

<file path="alembic.ini">
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
version_path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="alembic/versions/65b12145bf1a_add_message_templates_table.py">
"""Add message templates table

Revision ID: 65b12145bf1a
Revises: 
Create Date: 2025-04-24 15:52:34.696386

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '65b12145bf1a'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
</file>

<file path="app/api/v1/endpoints/campaigns.py">
# app/api/v1/endpoints/campaigns.py
import csv
import io
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, UploadFile, File, Query, Path, status
from fastapi.responses import JSONResponse

from app.api.v1.dependencies import get_current_user, get_rate_limiter
from app.core.exceptions import ValidationError, NotFoundError
from app.schemas.campaign import (
    CampaignCreate,
    CampaignCreateFromCSV,
    CampaignUpdate,
    CampaignResponse,
    CampaignStatus,
    CampaignListResponse
)
from app.schemas.user import User
from app.utils.pagination import PaginationParams, paginate_response
from app.services.campaigns.processor import get_campaign_processor

router = APIRouter()


@router.post("/", response_model=CampaignResponse, status_code=status.HTTP_201_CREATED)
async def create_campaign(
    campaign: CampaignCreate,
    current_user: User = Depends(get_current_user),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Create a new campaign.
    
    This creates a campaign in draft status. Messages can be added later.
    """
    # Check rate limits
    await rate_limiter.check_rate_limit(current_user.id, "create_campaign")
    
    try:
        # Get repository
        from app.db.session import get_repository
        from app.db.repositories.campaigns import CampaignRepository
        
        campaign_repo = await get_repository(CampaignRepository)
        
        # Create campaign
        result = await campaign_repo.create_campaign(
            name=campaign.name,
            description=campaign.description,
            user_id=current_user.id,
            scheduled_start_at=campaign.scheduled_start_at,
            scheduled_end_at=campaign.scheduled_end_at,
            settings=campaign.settings
        )
        
        return result
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating campaign: {str(e)}")


@router.post("/from-csv", response_model=CampaignResponse, status_code=status.HTTP_201_CREATED)
async def create_campaign_from_csv(
    file: UploadFile = File(...),
    campaign_data: str = Query(..., description="Campaign data as JSON string"),
    delimiter: str = Query(",", description="CSV delimiter"),
    has_header: bool = Query(True, description="Whether CSV has a header row"),
    phone_column: str = Query("phone", description="Column name containing phone numbers"),
    current_user: User = Depends(get_current_user),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Create a campaign and add phone numbers from CSV.
    
    This creates a campaign and immediately adds all phone numbers from the CSV.
    The campaign will remain in draft status until explicitly started.
    """
    import json
    
    # Check rate limits
    await rate_limiter.check_rate_limit(current_user.id, "create_campaign")
    
    try:
        # Parse campaign data
        campaign_dict = json.loads(campaign_data)
        campaign_data = CampaignCreateFromCSV(**campaign_dict)
        
        # Get repositories
        from app.db.session import get_repository
        from app.db.repositories.campaigns import CampaignRepository
        
        campaign_repo = await get_repository(CampaignRepository)
        
        # Create campaign
        campaign = await campaign_repo.create_campaign(
            name=campaign_data.name,
            description=campaign_data.description,
            user_id=current_user.id,
            scheduled_start_at=campaign_data.scheduled_start_at,
            scheduled_end_at=campaign_data.scheduled_end_at,
            settings=campaign_data.settings
        )
        
        # Read CSV file
        contents = await file.read()
        csv_file = io.StringIO(contents.decode('utf-8'))
        
        # Parse CSV
        csv_reader = csv.reader(csv_file, delimiter=delimiter)
        
        # Skip header if present
        if has_header:
            header = next(csv_reader)
            try:
                phone_index = header.index(phone_column)
            except ValueError:
                raise ValidationError(
                    message=f"Column '{phone_column}' not found in CSV header",
                    details={"available_columns": header}
                )
        else:
            phone_index = 0  # Assume first column has phone numbers
        
        # Extract phone numbers
        phone_numbers = []
        for row in csv_reader:
            if row and len(row) > phone_index:
                phone = row[phone_index].strip()
                if phone:
                    phone_numbers.append(phone)
        
        if not phone_numbers:
            raise ValidationError(message="No valid phone numbers found in CSV")
        
        # Add phone numbers to campaign
        added_count = await campaign_repo.add_messages_to_campaign(
            campaign_id=campaign.id,
            phone_numbers=phone_numbers,
            message_text=campaign_data.message_template,
            user_id=current_user.id
        )
        
        # Refresh campaign
        campaign = await campaign_repo.get_by_id(campaign.id)
        
        return campaign
        
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid campaign data JSON")
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating campaign: {str(e)}")


@router.get("/", response_model=CampaignListResponse)
async def list_campaigns(
    pagination: PaginationParams = Depends(),
    status: Optional[str] = Query(None, description="Filter by campaign status"),
    current_user: User = Depends(get_current_user),
):
    """
    List campaigns for the current user.
    
    Returns a paginated list of campaigns.
    """
    try:
        # Get repository
        from app.db.session import get_repository
        from app.db.repositories.campaigns import CampaignRepository
        
        campaign_repo = await get_repository(CampaignRepository)
        
        # Get campaigns with pagination
        campaigns, total = await campaign_repo.get_campaigns_for_user(
            user_id=current_user.id,
            status=status,
            skip=pagination.skip,
            limit=pagination.limit
        )
        
        # Calculate pagination info
        total_pages = (total + pagination.limit - 1) // pagination.limit
        
        # Return paginated response
        return {
            "items": campaigns,
            "total": total,
            "page": pagination.page,
            "size": pagination.limit,
            "pages": total_pages
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error listing campaigns: {str(e)}")


@router.get("/{campaign_id}", response_model=CampaignResponse)
async def get_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
):
   """
   Get details of a specific campaign.
   """
   try:
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       
       # Get campaign
       campaign = await campaign_repo.get_by_id(campaign_id)
       if not campaign:
           raise NotFoundError(message=f"Campaign {campaign_id} not found")
       
       # Check authorization
       if campaign.user_id != current_user.id:
           raise HTTPException(status_code=403, detail="Not authorized to access this campaign")
       
       return campaign
       
   except NotFoundError as e:
       raise HTTPException(status_code=404, detail=str(e))
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error retrieving campaign: {str(e)}")


@router.put("/{campaign_id}", response_model=CampaignResponse)
async def update_campaign(
   campaign_update: CampaignUpdate,
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
):
   """
   Update campaign details.
   
   Only draft campaigns can be fully updated. Active campaigns can only have their description updated.
   """
   try:
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       
       # Get campaign
       campaign = await campaign_repo.get_by_id(campaign_id)
       if not campaign:
           raise NotFoundError(message=f"Campaign {campaign_id} not found")
       
       # Check authorization
       if campaign.user_id != current_user.id:
           raise HTTPException(status_code=403, detail="Not authorized to update this campaign")
       
       # Check if campaign can be updated
       if campaign.status != "draft" and any([
           campaign_update.scheduled_start_at is not None,
           campaign_update.scheduled_end_at is not None,
           campaign_update.name is not None
       ]):
           raise HTTPException(
               status_code=400, 
               detail="Only draft campaigns can have name or schedule updated"
           )
       
       # Convert to dict and remove None values
       update_data = {k: v for k, v in campaign_update.dict().items() if v is not None}
       
       # Update campaign
       updated = await campaign_repo.update(id=campaign_id, obj_in=update_data)
       if not updated:
           raise HTTPException(status_code=500, detail="Failed to update campaign")
       
       return updated
       
   except NotFoundError as e:
       raise HTTPException(status_code=404, detail=str(e))
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error updating campaign: {str(e)}")


@router.post("/{campaign_id}/start", response_model=CampaignResponse)
async def start_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
   campaign_processor = Depends(get_campaign_processor),
):
   """
   Start a campaign.
   
   This will change the campaign status to active and begin sending messages.
   """
   try:
       # Start campaign
       success = await campaign_processor.start_campaign(
           campaign_id=campaign_id,
           user_id=current_user.id
       )
       
       if not success:
           raise HTTPException(status_code=400, detail="Failed to start campaign")
       
       # Get updated campaign
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       campaign = await campaign_repo.get_by_id(campaign_id)
       
       return campaign
       
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error starting campaign: {str(e)}")


@router.post("/{campaign_id}/pause", response_model=CampaignResponse)
async def pause_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
   campaign_processor = Depends(get_campaign_processor),
):
   """
   Pause a campaign.
   
   This will change the campaign status to paused and stop sending messages.
   The campaign can be resumed later.
   """
   try:
       # Pause campaign
       success = await campaign_processor.pause_campaign(
           campaign_id=campaign_id,
           user_id=current_user.id
       )
       
       if not success:
           raise HTTPException(status_code=400, detail="Failed to pause campaign")
       
       # Get updated campaign
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       campaign = await campaign_repo.get_by_id(campaign_id)
       
       return campaign
       
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error pausing campaign: {str(e)}")


@router.post("/{campaign_id}/cancel", response_model=CampaignResponse)
async def cancel_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
   campaign_processor = Depends(get_campaign_processor),
):
   """
   Cancel a campaign.
   
   This will change the campaign status to cancelled and stop sending messages.
   The campaign cannot be resumed after cancellation.
   """
   try:
       # Cancel campaign
       success = await campaign_processor.cancel_campaign(
           campaign_id=campaign_id,
           user_id=current_user.id
       )
       
       if not success:
           raise HTTPException(status_code=400, detail="Failed to cancel campaign")
       
       # Get updated campaign
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       campaign = await campaign_repo.get_by_id(campaign_id)
       
       return campaign
       
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error cancelling campaign: {str(e)}")


@router.get("/{campaign_id}/messages", response_model=dict)
async def get_campaign_messages(
   campaign_id: str = Path(..., description="Campaign ID"),
   pagination: PaginationParams = Depends(),
   status: Optional[str] = Query(None, description="Filter by message status"),
   current_user: User = Depends(get_current_user),
):
   """
   Get messages for a campaign.
   
   Returns a paginated list of messages for the specified campaign.
   """
   try:
       # First check if campaign exists and belongs to user
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       from app.db.repositories.messages import MessageRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       campaign = await campaign_repo.get_by_id(campaign_id)
       
       if not campaign:
           raise NotFoundError(message=f"Campaign {campaign_id} not found")
       
       if campaign.user_id != current_user.id:
           raise HTTPException(status_code=403, detail="Not authorized to access this campaign")
       
       # Get messages for campaign
       message_repo = await get_repository(MessageRepository)
       messages, total = await message_repo.get_messages_for_campaign(
           campaign_id=campaign_id,
           status=status,
           skip=pagination.skip,
           limit=pagination.limit
       )
       
       # Return paginated response
       return paginate_response(
           items=[message.dict() for message in messages],
           total=total,
           pagination=pagination
       )
       
   except NotFoundError as e:
       raise HTTPException(status_code=404, detail=str(e))
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error retrieving campaign messages: {str(e)}")


@router.delete("/{campaign_id}", status_code=204)
async def delete_campaign(
   campaign_id: str = Path(..., description="Campaign ID"),
   current_user: User = Depends(get_current_user),
):
   """
   Delete a campaign.
   
   Only draft campaigns can be deleted. Active, paused, or completed campaigns cannot be deleted.
   """
   try:
       from app.db.session import get_repository
       from app.db.repositories.campaigns import CampaignRepository
       
       campaign_repo = await get_repository(CampaignRepository)
       
       # Get campaign
       campaign = await campaign_repo.get_by_id(campaign_id)
       if not campaign:
           raise NotFoundError(message=f"Campaign {campaign_id} not found")
       
       # Check authorization
       if campaign.user_id != current_user.id:
           raise HTTPException(status_code=403, detail="Not authorized to delete this campaign")
       
       # Check if campaign can be deleted
       if campaign.status != "draft":
           raise HTTPException(
               status_code=400, 
               detail="Only draft campaigns can be deleted"
           )
       
       # Delete campaign
       success = await campaign_repo.delete(id=campaign_id)
       if not success:
           raise HTTPException(status_code=500, detail="Failed to delete campaign")
       
       return JSONResponse(status_code=204, content=None)
       
   except NotFoundError as e:
       raise HTTPException(status_code=404, detail=str(e))
   except Exception as e:
       raise HTTPException(status_code=500, detail=f"Error deleting campaign: {str(e)}")
</file>

<file path="app/api/v1/endpoints/templates.py">
# app/api/v1/endpoints/templates.py
"""
API endpoints for message templates.
"""
from typing import List, Optional, Dict, Any
from fastapi import APIRouter, Depends, HTTPException, Path, Query, status, Body
from fastapi.responses import JSONResponse
from pydantic import BaseModel

from app.api.v1.dependencies import get_current_user
from app.core.exceptions import ValidationError, NotFoundError
from app.schemas.template import (
    MessageTemplateCreate,
    MessageTemplateUpdate,
    MessageTemplateResponse,
    MessageWithTemplate
)
from app.schemas.user import User
from app.utils.pagination import PaginationParams, paginate_response
from app.services.sms.sender import get_sms_sender

router = APIRouter()


@router.post("/", response_model=MessageTemplateResponse, status_code=status.HTTP_201_CREATED)
async def create_template(
    template: MessageTemplateCreate,
    current_user: User = Depends(get_current_user)
):
    """
    Create a new message template.
    
    Templates can include variables in the format {{variable_name}} which will
    be replaced when sending messages.
    """
    try:
        # Get template repository
        from app.db.session import get_repository
        from app.db.repositories.templates import TemplateRepository
        
        template_repo = await get_repository(TemplateRepository)
        
        # Create template
        result = await template_repo.create_template(
            name=template.name,
            content=template.content,
            description=template.description,
            variables=template.variables,
            is_active=template.is_active,
            user_id=current_user.id
        )
        
        return result
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating template: {str(e)}")


@router.get("/", response_model=Dict[str, Any])
async def list_templates(
    pagination: PaginationParams = Depends(),
    active_only: bool = Query(False, description="Return only active templates"),
    current_user: User = Depends(get_current_user)
):
    """
    List message templates for the current user.
    
    Returns a paginated list of templates.
    """
    try:
        # Get template repository
        from app.db.session import get_repository
        from app.db.repositories.templates import TemplateRepository
        
        template_repo = await get_repository(TemplateRepository)
        
        # Get templates
        templates, total = await template_repo.get_templates_for_user(
            user_id=current_user.id,
            active_only=active_only,
            skip=pagination.skip,
            limit=pagination.limit
        )
        
        # Return paginated response
        return paginate_response(
            items=[template.dict() for template in templates],
            total=total,
            pagination=pagination
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error listing templates: {str(e)}")


@router.get("/{template_id}", response_model=MessageTemplateResponse)
async def get_template(
    template_id: str = Path(..., description="Template ID"),
    current_user: User = Depends(get_current_user)
):
    """
    Get a specific message template.
    """
    try:
        # Get template repository
        from app.db.session import get_repository
        from app.db.repositories.templates import TemplateRepository
        
        template_repo = await get_repository(TemplateRepository)
        
        # Get template
        template = await template_repo.get_by_id(template_id)
        
        # Check if template exists
        if not template:
            raise NotFoundError(message=f"Template {template_id} not found")
        
        # Check authorization
        if template.user_id != current_user.id:
            raise HTTPException(status_code=403, detail="Not authorized to access this template")
        
        return template
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error getting template: {str(e)}")


@router.put("/{template_id}", response_model=MessageTemplateResponse)
async def update_template(
    template_update: MessageTemplateUpdate,
    template_id: str = Path(..., description="Template ID"),
    current_user: User = Depends(get_current_user)
):
    """
    Update a message template.
    """
    try:
        # Get template repository
        from app.db.session import get_repository
        from app.db.repositories.templates import TemplateRepository
        
        template_repo = await get_repository(TemplateRepository)
        
        # Get template
        template = await template_repo.get_by_id(template_id)
        
        # Check if template exists
        if not template:
            raise NotFoundError(message=f"Template {template_id} not found")
        
        # Check authorization
        if template.user_id != current_user.id:
            raise HTTPException(status_code=403, detail="Not authorized to update this template")
        
        # Extract variables from content if content was updated
        update_data = template_update.dict(exclude_unset=True)
        if "content" in update_data:
            import re
            pattern = r"{{([a-zA-Z0-9_]+)}}"
            update_data["variables"] = list(set(re.findall(pattern, update_data["content"])))
        
        # Update template
        updated_template = await template_repo.update(id=template_id, obj_in=update_data)
        
        return updated_template
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error updating template: {str(e)}")


@router.delete("/{template_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_template(
    template_id: str = Path(..., description="Template ID"),
    current_user: User = Depends(get_current_user)
):
    """
    Delete a message template.
    """
    try:
        # Get template repository
        from app.db.session import get_repository
        from app.db.repositories.templates import TemplateRepository
        
        template_repo = await get_repository(TemplateRepository)
        
        # Get template
        template = await template_repo.get_by_id(template_id)
        
        # Check if template exists
        if not template:
            raise NotFoundError(message=f"Template {template_id} not found")
        
        # Check authorization
        if template.user_id != current_user.id:
            raise HTTPException(status_code=403, detail="Not authorized to delete this template")
        
        # Delete template
        success = await template_repo.delete(id=template_id)
        
        if not success:
            raise HTTPException(status_code=500, detail="Failed to delete template")
        
        # Return no content
        return None
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error deleting template: {str(e)}")


# Create a Pydantic model for the apply request
class TemplateApplyRequest(BaseModel):
    """Request model for applying a template."""
    template_id: str
    variables: Dict[str, str]


@router.post("/apply")
async def apply_template(
    request: TemplateApplyRequest = Body(...),
    current_user: User = Depends(get_current_user)
):
    """
    Apply variables to a template and return the result.
    
    This endpoint is useful for previewing how a template will look with specific variables.
    """
    try:
        # Get template repository
        from app.db.session import get_repository
        from app.db.repositories.templates import TemplateRepository
        
        template_repo = await get_repository(TemplateRepository)
        
        # Get template
        template = await template_repo.get_by_id(request.template_id)
        
        # Check if template exists
        if not template:
            raise NotFoundError(message=f"Template {request.template_id} not found")
        
        # Check authorization
        if template.user_id != current_user.id:
            raise HTTPException(status_code=403, detail="Not authorized to access this template")
        
        # Apply template
        result = await template_repo.apply_template(
            template_id=request.template_id,
            variables=request.variables
        )
        
        # Check for missing variables
        import re
        missing_vars = re.findall(r"{{([a-zA-Z0-9_]+)}}", result)
        
        return {
            "result": result,
            "missing_variables": missing_vars
        }
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error applying template: {str(e)}")


@router.post("/send", status_code=status.HTTP_202_ACCEPTED)
async def send_with_template(
    message: MessageWithTemplate,
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender)
):
    """
    Send a message using a template.
    
    Applies the provided variables to the template and sends the resulting message.
    """
    try:
        # Get template repository
        from app.db.session import get_repository
        from app.db.repositories.templates import TemplateRepository
        
        template_repo = await get_repository(TemplateRepository)
        
        # Get template
        template = await template_repo.get_by_id(message.template_id)
        
        # Check if template exists
        if not template:
            raise NotFoundError(message=f"Template {message.template_id} not found")
        
        # Check authorization
        if template.user_id != current_user.id:
            raise HTTPException(status_code=403, detail="Not authorized to use this template")
        
        # Apply template
        message_text = await template_repo.apply_template(
            template_id=message.template_id,
            variables=message.variables
        )
        
        # Check for missing variables
        import re
        missing_vars = re.findall(r"{{([a-zA-Z0-9_]+)}}", message_text)
        if missing_vars:
            raise ValidationError(
                message="Missing template variables", 
                details={"missing_variables": missing_vars}
            )
        
        # Send message
        result = await sms_sender.send_message(
            phone_number=message.phone_number,
            message_text=message_text,
            user_id=current_user.id,
            scheduled_at=message.scheduled_at,
            custom_id=message.custom_id,
            metadata={"template_id": message.template_id, "template_variables": message.variables}
        )
        
        return result
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error sending message: {str(e)}")
</file>

<file path="app/core/exceptions.py">
"""
Custom exception classes for Inboxerr Backend.
"""
from typing import Any, Dict, Optional


class InboxerrException(Exception):
    """Base exception class for Inboxerr application."""
    
    def __init__(
        self,
        message: str,
        code: str = "INTERNAL_ERROR",
        status_code: int = 500,
        details: Optional[Dict[str, Any]] = None,
    ):
        self.message = message
        self.code = code
        self.status_code = status_code
        self.details = details or {}
        super().__init__(message)


class AuthenticationError(InboxerrException):
    """Raised when authentication fails."""
    
    def __init__(
        self,
        message: str = "Authentication failed",
        code: str = "AUTHENTICATION_ERROR",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=401, details=details)


class AuthorizationError(InboxerrException):
    """Raised when a user doesn't have permission."""
    
    def __init__(
        self,
        message: str = "Not authorized",
        code: str = "AUTHORIZATION_ERROR",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=403, details=details)


class ValidationError(InboxerrException):
    """Raised for validation errors."""
    
    def __init__(
        self,
        message: str = "Validation error",
        code: str = "VALIDATION_ERROR",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=422, details=details)


class NotFoundError(InboxerrException):
    """Raised when a resource is not found."""
    
    def __init__(
        self,
        message: str = "Resource not found",
        code: str = "NOT_FOUND",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=404, details=details)


class SMSGatewayError(InboxerrException):
    """Raised when there's an error with the SMS gateway."""
    
    def __init__(
        self,
        message: str = "SMS Gateway error",
        code: str = "SMS_GATEWAY_ERROR",
        details: Optional[Dict[str, Any]] = None,
        status_code: int = 502,
    ):
        super().__init__(message=message, code=code, status_code=status_code, details=details)


class RetryableError(InboxerrException):
    """Error that can be retried."""
    
    def __init__(
        self,
        message: str = "Retryable error",
        code: str = "RETRYABLE_ERROR",
        details: Optional[Dict[str, Any]] = None,
        retry_after: int = 60,
    ):
        details = details or {}
        details["retry_after"] = retry_after
        super().__init__(message=message, code=code, status_code=503, details=details)


class WebhookError(InboxerrException):
    """Raised when there's an issue with webhook processing."""
    
    def __init__(
        self,
        message: str = "Webhook error",
        code: str = "WEBHOOK_ERROR",
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message=message, code=code, status_code=400, details=details)


class SMSAuthError(SMSGatewayError):
    """Raised when SMS gateway credentials are invalid."""
    def __init__(
        self,
        message: str = "Invalid SMS gateway credentials",
        details: Optional[Dict[str, Any]] = None
    ):
        super().__init__(
            message=message,
            code="SMS_AUTH_ERROR",
            status_code=401,
            details=details
        )
</file>

<file path="app/db/repositories/base.py">
"""
Base repository with common database operations.
"""
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union
from uuid import uuid4

from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel
from sqlalchemy import select, update, delete
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.base import Base

# Define generic types for models
ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)


class BaseRepository(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    """
    Base repository with common CRUD operations.
    
    Generic repository pattern implementation for database access.
    """
    
    def __init__(self, session: AsyncSession, model: Type[ModelType]):
        """
        Initialize repository with session and model.
        
        Args:
            session: Database session
            model: SQLAlchemy model class
        """
        self.session = session
        self.model = model
    
    async def get_by_id(self, id: str) -> Optional[ModelType]:
        """
        Get a record by ID.
        
        Args:
            id: Record ID
            
        Returns:
            ModelType: Found record or None
        """
        query = select(self.model).where(self.model.id == id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_attribute(self, attr_name: str, attr_value: Any) -> Optional[ModelType]:
        """
        Get a record by a specific attribute.
        
        Args:
            attr_name: Attribute name
            attr_value: Attribute value
            
        Returns:
            ModelType: Found record or None
        """
        query = select(self.model).where(getattr(self.model, attr_name) == attr_value)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def list(
        self, 
        *,
        filters: Optional[Dict[str, Any]] = None,
        skip: int = 0, 
        limit: int = 100
    ) -> List[ModelType]:
        """
        Get a list of records with optional filtering.
        
        Args:
            filters: Optional filters as dict
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            List[ModelType]: List of records
        """
        query = select(self.model)
        
        # Apply filters if provided
        if filters:
            for attr_name, attr_value in filters.items():
                if hasattr(self.model, attr_name) and attr_value is not None:
                    query = query.where(getattr(self.model, attr_name) == attr_value)
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def create(self, *, obj_in: Union[CreateSchemaType, Dict[str, Any]]) -> ModelType:
        """
        Create a new record.
        
        Args:
            obj_in: Data to create record with
            
        Returns:
            ModelType: Created record
        """
        # Convert to dict if it's a Pydantic model
        obj_in_data = obj_in if isinstance(obj_in, dict) else obj_in.dict(exclude_unset=True)
        
        # Create model instance
        db_obj = self.model(**obj_in_data)
        
        # Generate ID if not provided
        if not db_obj.id:
            db_obj.id = str(uuid4())
        
        # Add to session
        self.session.add(db_obj)
        await self.session.commit()
        await self.session.refresh(db_obj)
        
        return db_obj
    
    async def update(
        self, 
        *,
        id: str,
        obj_in: Union[UpdateSchemaType, Dict[str, Any]]
    ) -> Optional[ModelType]:
        """
        Update a record.
        
        Args:
            id: Record ID
            obj_in: Data to update record with
            
        Returns:
            ModelType: Updated record or None
        """
        # Get current record
        db_obj = await self.get_by_id(id)
        if not db_obj:
            return None
        
        # Convert to dict if it's a Pydantic model
        update_data = obj_in if isinstance(obj_in, dict) else obj_in.dict(exclude_unset=True)
        
        # Remove None values
        update_data = {k: v for k, v in update_data.items() if v is not None}
        
        # Update record
        for field, value in update_data.items():
            if hasattr(db_obj, field):
                setattr(db_obj, field, value)
        
        # Save changes
        self.session.add(db_obj)
        await self.session.commit()
        await self.session.refresh(db_obj)
        
        return db_obj
    
    async def delete(self, *, id: str) -> bool:
        """
        Delete a record.
        
        Args:
            id: Record ID
            
        Returns:
            bool: True if deleted, False if not found
        """
        # Check if record exists
        db_obj = await self.get_by_id(id)
        if not db_obj:
            return False
        
        # Delete record
        await self.session.delete(db_obj)
        await self.session.commit()
        
        return True
    
    async def count(self, *, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        Count records with optional filtering.
        
        Args:
            filters: Optional filters as dict
            
        Returns:
            int: Number of records
        """
        from sqlalchemy import func
        
        query = select(func.count()).select_from(self.model)
        
        # Apply filters if provided
        if filters:
            for attr_name, attr_value in filters.items():
                if hasattr(self.model, attr_name) and attr_value is not None:
                    query = query.where(getattr(self.model, attr_name) == attr_value)
        
        result = await self.session.execute(query)
        return result.scalar_one()
</file>

<file path="app/db/repositories/templates.py">
# app/db/repositories/templates.py
"""
Repository for message template operations.
"""
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any, Tuple
from uuid import uuid4
import re

from sqlalchemy import select, update, and_, or_, desc, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.db.repositories.base import BaseRepository
from app.models.message import MessageTemplate
from app.schemas.template import MessageTemplateCreate, MessageTemplateUpdate


class TemplateRepository(BaseRepository[MessageTemplate, MessageTemplateCreate, MessageTemplateUpdate]):
    """Repository for message template operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with session."""
        super().__init__(session=session, model=MessageTemplate)
    
    async def create_template(
        self,
        *,
        name: str,
        content: str,
        user_id: str,
        description: Optional[str] = None,
        variables: Optional[List[str]] = None,
        is_active: bool = True
    ) -> MessageTemplate:
        """
        Create a new message template.
        
        Args:
            name: Template name
            content: Template content with placeholders
            user_id: User ID
            description: Optional template description
            variables: Optional list of variables
            is_active: Whether the template is active
            
        Returns:
            MessageTemplate: Created template
        """
        # Extract variables from content if not provided
        if variables is None:
            pattern = r"{{([a-zA-Z0-9_]+)}}"
            variables = list(set(re.findall(pattern, content)))
        
        # Create template
        template = MessageTemplate(
            id=str(uuid4()),
            name=name,
            content=content,
            description=description,
            is_active=is_active,
            user_id=user_id,
            variables=variables
        )
        
        self.session.add(template)
        await self.session.commit()
        await self.session.refresh(template)
        
        return template
    
    async def get_templates_for_user(
        self,
        *,
        user_id: str,
        active_only: bool = False,
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[MessageTemplate], int]:
        """
        Get message templates for a user.
        
        Args:
            user_id: User ID
            active_only: Whether to return only active templates
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[MessageTemplate], int]: List of templates and total count
        """
        # Base query
        query = select(MessageTemplate).where(MessageTemplate.user_id == user_id)
        count_query = select(func.count()).select_from(MessageTemplate).where(MessageTemplate.user_id == user_id)
        
        # Filter active templates if requested
        if active_only:
            query = query.where(MessageTemplate.is_active == True)
            count_query = count_query.where(MessageTemplate.is_active == True)
        
        # Order by name
        query = query.order_by(MessageTemplate.name)
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await self.session.execute(query)
        count_result = await self.session.execute(count_query)
        
        templates = result.scalars().all()
        total = count_result.scalar_one()
        
        return templates, total
    
    async def apply_template(
        self,
        *,
        template_id: str,
        variables: Dict[str, str]
    ) -> Optional[str]:
        """
        Apply variables to a template.
        
        Args:
            template_id: Template ID
            variables: Dictionary of variable values
            
        Returns:
            str: Processed template content or None if template not found
        """
        # Get template
        template = await self.get_by_id(template_id)
        if not template:
            return None
        
        # Apply variables to template
        content = template.content
        
        for key, value in variables.items():
            # Replace {{key}} with value
            content = content.replace(f"{{{{{key}}}}}", value)
        
        return content
</file>

<file path="app/db/session.py">
"""
Database session management.
"""
import logging
from typing import AsyncGenerator, Type

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

from app.core.config import settings
from app.db.base import Base

# Create async engine
engine = create_async_engine(
    settings.DATABASE_URL,
    echo=settings.DEBUG,
    future=True
)

# Create async session factory
async_session_factory = sessionmaker(
    engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)

logger = logging.getLogger("inboxerr.db")


async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Dependency for getting async database session.
    
    Yields:
        AsyncSession: Database session
    """
    async with async_session_factory() as session:
        logger.debug("Database session created")
        try:
            yield session
            await session.commit()
            logger.debug("Database session committed")
        except Exception as e:
            await session.rollback()
            logger.error(f"Database session rolled back due to: {str(e)}")
            raise
        finally:
            await session.close()
            logger.debug("Database session closed")


async def initialize_database() -> None:
    """
    Initialize database by creating all tables.
    
    This should be called during application startup.
    """
    logger.info("Initializing database")
    async with engine.begin() as conn:
        # Create all tables
        await conn.run_sync(Base.metadata.create_all)
    logger.info("Database initialized successfully")


async def close_database_connections() -> None:
    """
    Close all database connections.
    
    This should be called during application shutdown.
    """
    logger.info("Closing database connections")
    await engine.dispose()
    logger.info("Database connections closed")


async def get_repository(repo_type: Type):
    """
    Get repository instance.
    
    Args:
        repo_type: Repository class
        
    Returns:
        Repository instance
    """
    async with async_session_factory() as session:
        return repo_type(session)
</file>

<file path="app/main.py">
"""
Main FastAPI application entry point for Inboxerr Backend.
"""
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging

from app.api.router import api_router
from app.core.config import settings
from app.core.exceptions import InboxerrException
from app.core.events import startup_event_handler, shutdown_event_handler

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger("inboxerr")

# Create FastAPI app
app = FastAPI(
    title=settings.PROJECT_NAME,
    description=settings.PROJECT_DESCRIPTION,
    version=settings.VERSION,
    docs_url="/api/docs",
    redoc_url="/api/redoc",
    openapi_url="/api/openapi.json",
)

# Set up CORS middleware
if settings.BACKEND_CORS_ORIGINS:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# Register event handlers
app.add_event_handler("startup", startup_event_handler)
app.add_event_handler("shutdown", shutdown_event_handler)

# Register exception handlers
@app.exception_handler(InboxerrException)
async def inboxerr_exception_handler(request: Request, exc: InboxerrException):
    """Custom exception handler for InboxerrException."""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "status": "error",
            "code": exc.code,
            "message": exc.message,
            "details": exc.details,
        },
    )

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Enhanced HTTP exception handler with consistent format."""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "status": "error",
            "code": f"HTTP_{exc.status_code}",
            "message": exc.detail,
            "details": None,
        },
    )

# Register routers
app.include_router(api_router, prefix=settings.API_PREFIX)

# Root endpoint
@app.get("/", tags=["Health"])
async def root():
    """Root endpoint for health checks."""
    return {
        "status": "ok",
        "service": settings.PROJECT_NAME,
        "version": settings.VERSION,
    }

if __name__ == "__main__":
    # For debugging only - use uvicorn for production
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
</file>

<file path="app/schemas/template.py">
# app/schemas/template.py
from typing import List, Optional, Dict, Any
from datetime import datetime, timezone
from pydantic import BaseModel, Field, validator


class MessageTemplateBase(BaseModel):
    """Base schema for message templates."""
    name: str = Field(..., description="Template name")
    content: str = Field(..., description="Template content with placeholders")
    description: Optional[str] = Field(None, description="Template description")
    is_active: bool = Field(True, description="Whether the template is active")


class MessageTemplateCreate(MessageTemplateBase):
    """Schema for creating a new message template."""
    variables: Optional[List[str]] = Field(default=[], description="List of variables in the template")
    
    @validator("content")
    def validate_content(cls, v):
        """Validate template content."""
        if not v or len(v.strip()) == 0:
            raise ValueError("Template content cannot be empty")
        if len(v) > 1600:  # Max length for multi-part SMS
            raise ValueError("Template exceeds maximum length of 1600 characters")
        return v
    
    @validator("variables", pre=True)
    def validate_variables(cls, v, values):
        """Extract variables from content if not provided."""
        import re
        
        if not v and "content" in values:
            # Extract variables like {{variable_name}} from content
            pattern = r"{{([a-zA-Z0-9_]+)}}"
            matches = re.findall(pattern, values["content"])
            if matches:
                return list(set(matches))  # Return unique variables
        return v or []


class MessageTemplateUpdate(BaseModel):
    """Schema for updating a message template."""
    name: Optional[str] = Field(None, description="Template name")
    content: Optional[str] = Field(None, description="Template content with placeholders")
    description: Optional[str] = Field(None, description="Template description")
    is_active: Optional[bool] = Field(None, description="Whether the template is active")
    variables: Optional[List[str]] = Field(None, description="List of variables in the template")
    
    @validator("content")
    def validate_content(cls, v):
        """Validate template content if provided."""
        if v is not None:
            if len(v.strip()) == 0:
                raise ValueError("Template content cannot be empty")
            if len(v) > 1600:
                raise ValueError("Template exceeds maximum length of 1600 characters")
        return v


class MessageTemplateResponse(MessageTemplateBase):
    """Schema for message template response."""
    id: str = Field(..., description="Template ID")
    variables: List[str] = Field(..., description="List of variables in the template")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    user_id: str = Field(..., description="User who created the template")
    
    class Config:
        """Pydantic config."""
        from_attributes = True


class MessageWithTemplate(BaseModel):
    """Schema for sending a message using a template."""
    template_id: str = Field(..., description="Template ID")
    phone_number: str = Field(..., description="Recipient phone number in E.164 format")
    variables: Dict[str, str] = Field(..., description="Values for template variables")
    scheduled_at: Optional[datetime] = Field(None, description="Schedule message for future delivery")
    custom_id: Optional[str] = Field(None, description="Custom ID for tracking")
    
    @validator("phone_number")
    def validate_phone_number(cls, v):
        """Validate phone number format."""
        if not v or not (v.startswith("+") and len(v) >= 8):
            raise ValueError("Phone number must be in E.164 format (e.g. +1234567890)")
        return v
</file>

<file path="app/scripts/create_admin.py">
# scripts/create_admin.py
import asyncio
import sys
from pathlib import Path

# Add parent directory to path
sys.path.append(str(Path(__file__).parent.parent))

from app.db.session import async_session_factory, initialize_database
from app.db.repositories.users import UserRepository
from app.core.security import get_password_hash

async def create_admin_user():
    """Create an admin user if none exists."""
    # Initialize database
    await initialize_database()
    
    # Use session properly with context manager
    async with async_session_factory() as session:
        # Create repository with session
        user_repo = UserRepository(session)
        
        # Check if admin exists
        admin = await user_repo.get_by_email("admin@inboxerr.com")
        
        if admin:
            print("Admin user already exists")
            return
        
        # Create admin user
        password = "Admin123!"
        hashed_password = get_password_hash(password)
        
        admin = await user_repo.create(
            email="admin@inboxerr.com",
            hashed_password=hashed_password,
            full_name="Admin User",
            is_active=True,
            role="admin"
        )
        
        print(f"Admin user created with ID: {admin.id}")
        print(f"Email: admin@inboxerr.com")
        print(f"Password: {password}")

if __name__ == "__main__":
    asyncio.run(create_admin_user())
</file>

<file path="app/utils/datetime.py">
"""
Utilities for standardized datetime handling.
"""
from datetime import datetime, timedelta, timezone
from typing import Optional, Union
import re

def utc_now() -> datetime:
    """
    Get current UTC time as timezone-aware datetime.
    
    Returns:
        datetime: Current UTC time
    """
    return datetime.now(timezone.utc)

def format_datetime(dt: Optional[datetime] = None) -> str:
    """
    Format datetime as ISO 8601 string.
    
    Args:
        dt: Datetime to format (defaults to current UTC time)
        
    Returns:
        str: ISO 8601 formatted string
    """
    if dt is None:
        dt = utc_now()
    
    # Ensure datetime is timezone-aware
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
        
    return dt.isoformat()

def parse_datetime(date_string: str) -> Optional[datetime]:
    """
    Parse datetime from string.
    
    Args:
        date_string: Datetime string to parse
        
    Returns:
        datetime: Parsed datetime or None if invalid
    """
    try:
        # Handle common formats
        if 'T' in date_string:
            # ISO format
            if date_string.endswith('Z'):
                date_string = date_string[:-1] + '+00:00'
            return datetime.fromisoformat(date_string)
        else:
            # Try common date formats
            date_patterns = [
                # YYYY-MM-DD
                r'^(\d{4})-(\d{2})-(\d{2})$',
                # MM/DD/YYYY
                r'^(\d{1,2})/(\d{1,2})/(\d{4})$',
                # DD/MM/YYYY
                r'^(\d{1,2})-(\d{1,2})-(\d{4})$',
            ]
            
            for pattern in date_patterns:
                match = re.match(pattern, date_string)
                if match:
                    if pattern == date_patterns[0]:
                        year, month, day = match.groups()
                    else:
                        if pattern == date_patterns[1]:
                            month, day, year = match.groups()
                        else:
                            day, month, year = match.groups()
                    
                    return datetime(int(year), int(month), int(day), tzinfo=timezone.utc)
            
            # If all patterns fail, try direct parsing
            return datetime.fromisoformat(date_string)
            
    except (ValueError, TypeError):
        return None

def add_time(dt: datetime, *, 
            days: int = 0, 
            hours: int = 0, 
            minutes: int = 0, 
            seconds: int = 0) -> datetime:
    """
    Add time to datetime.
    
    Args:
        dt: Base datetime
        days: Days to add
        hours: Hours to add
        minutes: Minutes to add
        seconds: Seconds to add
        
    Returns:
        datetime: New datetime
    """
    # Ensure datetime is timezone-aware
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
        
    return dt + timedelta(days=days, hours=hours, minutes=minutes, seconds=seconds)

def subtract_time(dt: datetime, *, 
                days: int = 0, 
                hours: int = 0, 
                minutes: int = 0, 
                seconds: int = 0) -> datetime:
    """
    Subtract time from datetime.
    
    Args:
        dt: Base datetime
        days: Days to subtract
        hours: Hours to subtract
        minutes: Minutes to subtract
        seconds: Seconds to subtract
        
    Returns:
        datetime: New datetime
    """
    return add_time(dt, days=-days, hours=-hours, minutes=-minutes, seconds=-seconds)

def is_future(dt: datetime) -> bool:
    """
    Check if datetime is in the future.
    
    Args:
        dt: Datetime to check
        
    Returns:
        bool: True if datetime is in the future
    """
    # Ensure datetime is timezone-aware
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
        
    return dt > utc_now()

def is_past(dt: datetime) -> bool:
    """
    Check if datetime is in the past.
    
    Args:
        dt: Datetime to check
        
    Returns:
        bool: True if datetime is in the past
    """
    # Ensure datetime is timezone-aware
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
        
    return dt < utc_now()

def ensure_utc(dt: datetime) -> datetime:
    """
    Ensure datetime is UTC timezone-aware.
    
    Args:
        dt: Datetime to process
        
    Returns:
        datetime: UTC timezone-aware datetime
    """
    # If timezone-naive, assume it's already UTC and add timezone
    if dt.tzinfo is None:
        return dt.replace(tzinfo=timezone.utc)
    
    # If it has a different timezone, convert to UTC
    return dt.astimezone(timezone.utc)
</file>

<file path="app/utils/error_handling.py">
"""
Utilities for standardized error handling across API endpoints.
"""
from typing import Any, Dict, Optional, Type, Union, List
import logging
from fastapi import HTTPException, status
from pydantic import ValidationError as PydanticValidationError

from app.core.exceptions import (
    InboxerrException, 
    ValidationError, 
    NotFoundError, 
    AuthenticationError,
    AuthorizationError,
    SMSGatewayError,
    RetryableError,
    WebhookError
)

logger = logging.getLogger("inboxerr.errors")

class ErrorResponse:
    """Standard error response format."""
    
    @staticmethod
    def model(
        status_code: int,
        code: str,
        message: str,
        details: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Create a standardized error response model.
        
        Args:
            status_code: HTTP status code
            code: Error code
            message: Error message
            details: Additional error details
            
        Returns:
            Dict: Standardized error response
        """
        return {
            "status": "error",
            "code": code,
            "message": message,
            "details": details or {}
        }
    
    @staticmethod
    def from_exception(exception: Union[Exception, InboxerrException]) -> Dict[str, Any]:
        """
        Create error response from exception.
        
        Args:
            exception: Exception to process
            
        Returns:
            Dict: Standardized error response
        """
        if isinstance(exception, InboxerrException):
            # Use attributes from custom exception
            return ErrorResponse.model(
                status_code=exception.status_code,
                code=exception.code,
                message=exception.message,
                details=exception.details
            )
        elif isinstance(exception, HTTPException):
            # Convert FastAPI HTTPException
            return ErrorResponse.model(
                status_code=exception.status_code,
                code=f"HTTP_{exception.status_code}",
                message=exception.detail,
                details=getattr(exception, "details", None)
            )
        elif isinstance(exception, PydanticValidationError):
            # Convert Pydantic validation error
            return ErrorResponse.model(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                code="VALIDATION_ERROR",
                message="Validation error",
                details={"errors": exception.errors()}
            )
        else:
            # Generic exception
            return ErrorResponse.model(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                code="INTERNAL_ERROR",
                message=str(exception),
                details={"type": type(exception).__name__}
            )


def handle_exception(exception: Exception) -> HTTPException:
    """
    Convert any exception to appropriate HTTPException.
    
    Args:
        exception: Exception to handle
        
    Returns:
        HTTPException: FastAPI HTTP exception
    """
    # Log all exceptions
    if isinstance(exception, (ValidationError, NotFoundError)):
        logger.info(f"Expected exception: {exception}")
    else:
        logger.error(f"Exception: {exception}", exc_info=True)
    
    # Map custom exceptions to status codes
    if isinstance(exception, ValidationError):
        status_code = status.HTTP_422_UNPROCESSABLE_ENTITY
    elif isinstance(exception, NotFoundError):
        status_code = status.HTTP_404_NOT_FOUND
    elif isinstance(exception, AuthenticationError):
        status_code = status.HTTP_401_UNAUTHORIZED
    elif isinstance(exception, AuthorizationError):
        status_code = status.HTTP_403_FORBIDDEN
    elif isinstance(exception, SMSGatewayError):
        status_code = status.HTTP_502_BAD_GATEWAY
    elif isinstance(exception, RetryableError):
        status_code = status.HTTP_503_SERVICE_UNAVAILABLE
    elif isinstance(exception, WebhookError):
        status_code = status.HTTP_400_BAD_REQUEST
    elif isinstance(exception, PydanticValidationError):
        status_code = status.HTTP_422_UNPROCESSABLE_ENTITY
    elif isinstance(exception, HTTPException):
        # Already a FastAPI HTTPException, just return it
        return exception
    else:
        # Default to internal server error
        status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
    
    # Get error response
    error_response = ErrorResponse.from_exception(exception)
    
    # Create FastAPI HTTPException
    http_exception = HTTPException(
        status_code=status_code,
        detail=error_response
    )
    
    # Add authentication headers if needed
    if isinstance(exception, AuthenticationError):
        http_exception.headers = {"WWW-Authenticate": "Bearer"}
    
    # Add retry headers if needed
    if isinstance(exception, RetryableError):
        retry_after = getattr(exception, "details", {}).get("retry_after", 60)
        http_exception.headers = {"Retry-After": str(retry_after)}
    
    return http_exception


def validation_error(message: str, details: Optional[Dict[str, Any]] = None) -> HTTPException:
    """
    Create a validation error response.
    
    Args:
        message: Error message
        details: Additional error details
        
    Returns:
        HTTPException: FastAPI HTTP exception
    """
    return handle_exception(ValidationError(message=message, details=details))


def not_found_error(message: str, details: Optional[Dict[str, Any]] = None) -> HTTPException:
    """
    Create a not found error response.
    
    Args:
        message: Error message
        details: Additional error details
        
    Returns:
        HTTPException: FastAPI HTTP exception
    """
    return handle_exception(NotFoundError(message=message, details=details))


def auth_error(message: str, details: Optional[Dict[str, Any]] = None) -> HTTPException:
    """
    Create an authentication error response.
    
    Args:
        message: Error message
        details: Additional error details
        
    Returns:
        HTTPException: FastAPI HTTP exception
    """
    return handle_exception(AuthenticationError(message=message, details=details))


def permission_error(message: str, details: Optional[Dict[str, Any]] = None) -> HTTPException:
    """
    Create an authorization error response.
    
    Args:
        message: Error message
        details: Additional error details
        
    Returns:
        HTTPException: FastAPI HTTP exception
    """
    return handle_exception(AuthorizationError(message=message, details=details))


def server_error(message: str, details: Optional[Dict[str, Any]] = None) -> HTTPException:
    """
    Create a server error response.
    
    Args:
        message: Error message
        details: Additional error details
        
    Returns:
        HTTPException: FastAPI HTTP exception
    """
    return HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail=ErrorResponse.model(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            code="INTERNAL_ERROR",
            message=message,
            details=details
        )
    )
</file>

<file path="app/utils/pagination.py">
"""
Utilities for API pagination.
"""
from typing import List, Dict, Any, TypeVar, Generic, Optional
from fastapi import Query, Depends
from pydantic import BaseModel


class PaginationParams:
    """
    Pagination parameters for API endpoints.
    
    This class is used as a FastAPI dependency to extract pagination parameters
    from query parameters.
    """
    
    def __init__(
        self,
        page: int = Query(1, ge=1, description="Page number"),
        limit: int = Query(20, ge=1, le=100, description="Items per page"),
        sort: Optional[str] = Query(None, description="Sort field"),
        order: Optional[str] = Query("asc", description="Sort order (asc or desc)")
    ):
        """
        Initialize pagination parameters.
        
        Args:
            page: Page number (1-based)
            limit: Items per page
            sort: Field to sort by
            order: Sort order (asc or desc)
        """
        self.page = page
        self.limit = limit
        self.sort = sort
        self.order = order
        
        # Calculate skip value for database queries
        self.skip = (page - 1) * limit


class PageInfo(BaseModel):
    """
    Page information for paginated responses.
    """
    current_page: int
    total_pages: int
    page_size: int
    total_items: int
    has_previous: bool
    has_next: bool


T = TypeVar('T')

class PaginatedResponse(BaseModel, Generic[T]):
    """
    Generic paginated response model.
    
    This class is used to standardize the format of paginated responses
    across all API endpoints.
    """
    items: List[T]
    page_info: PageInfo
    
    class Config:
        """Pydantic config."""
        arbitrary_types_allowed = True


def paginate_response(
    items: List[Any],
    total: int,
    pagination: PaginationParams
) -> Dict[str, Any]:
    """
    Create a standardized paginated response.
    
    Args:
        items: List of items for the current page
        total: Total number of items across all pages
        pagination: Pagination parameters
        
    Returns:
        Dict: Standardized response with items and pagination info
    """
    # Calculate pagination values
    total_pages = (total + pagination.limit - 1) // pagination.limit
    
    # Create page info
    page_info = PageInfo(
        current_page=pagination.page,
        total_pages=total_pages,
        page_size=pagination.limit,
        total_items=total,
        has_previous=pagination.page > 1,
        has_next=pagination.page < total_pages
    )
    
    # Create response
    return {
        "items": items,
        "page_info": page_info
    }


def get_pagination_links(
    path: str,
    pagination: PaginationParams,
    total: int,
    query_params: Optional[Dict[str, Any]] = None
) -> Dict[str, Optional[str]]:
    """
    Generate pagination links for HATEOAS.
    
    Args:
        path: Base path for links
        pagination: Pagination parameters
        total: Total number of items
        query_params: Additional query parameters
        
    Returns:
        Dict: Links for first, prev, next, and last pages
    """
    # Calculate pagination values
    total_pages = (total + pagination.limit - 1) // pagination.limit
    
    # Initialize query params
    params = query_params.copy() if query_params else {}
    
    # Helper to create URL with query params
    def create_url(page: int) -> str:
        page_params = {**params, "page": page, "limit": pagination.limit}
        
        if pagination.sort:
            page_params["sort"] = pagination.sort
            page_params["order"] = pagination.order
            
        query_string = "&".join(f"{key}={value}" for key, value in page_params.items())
        return f"{path}?{query_string}"
    
    # Create links
    links = {
        "first": create_url(1),
        "last": create_url(total_pages) if total_pages > 0 else None,
        "prev": create_url(pagination.page - 1) if pagination.page > 1 else None,
        "next": create_url(pagination.page + 1) if pagination.page < total_pages else None
    }
    
    return links
</file>

<file path="database-schema.md">
# Inboxerr Database Schema Overview

This document outlines the structure of the PostgreSQL database used by the Inboxerr backend service. It includes all tables, relationships, and index/foreign key mappings, aligned with the SQLAlchemy models defined in the codebase.

---

##  Tables & Relationships

| **Table**           | **Primary Keys** | **Foreign Keys**                             | **Relationships**                             |
|---------------------|------------------|-----------------------------------------------|------------------------------------------------|
| `user`              | `id`             |                                              | Referenced by many tables                      |
| `apikey`            | `id`             | `user_id`  `user(id)`                     | Each API key belongs to a user                 |
| `campaign`          | `id`             | `user_id`  `user(id)`                     | One user owns many campaigns                   |
| `message`           | `id`             | `user_id`  `user(id)`<br>`campaign_id`  `campaign(id)`<br>`batch_id`  `messagebatch(id)` | Messages belong to a campaign and batch        |
| `messagebatch`      | `id`             | `user_id`  `user(id)`                     | Groups messages sent together                  |
| `messageevent`      | `id`             | `message_id`  `message(id)`              | Tracks status updates for a message            |
| `messagetemplate`   | `id`             | `user_id`  `user(id)`                     | Message content templates                      |
| `webhook`           | `id`             | `user_id`  `user(id)`                     | Defines external callbacks                     |
| `webhookdelivery`   | `id`             | `webhook_id`  `webhook(id)`<br>`message_id`  `message(id)` | Stores actual webhook attempts                 |
| `webhookevent`      | `id`             |                                              | Events that can trigger webhooks               |
| `alembic_version`   |                 |                                              | Managed by Alembic for schema migrations       |

---

##  Indexes & Performance

Each table includes relevant indexes, such as:
- `id` (primary key, indexed by default)
- Frequently queried fields like `user_id`, `campaign_id`, `status`, and `scheduled_at`

---

##  Data Types Overview

| **Field**            | **Type**                       |
|----------------------|---------------------------------|
| `id`                 | `character varying` (UUIDs)     |
| `user_id`            | `character varying` (FK)        |
| `campaign_id`        | `character varying` (FK)        |
| `message`            | `text`                          |
| `status`             | `character varying`             |
| `scheduled_at`       | `timestamp without time zone`   |
| `settings`, `data`   | `json`                          |

---

##  How to Inspect the Schema

From inside `psql`:
```bash
\c inboxerr        -- Connect to DB
\dt                 -- List tables
\d tablename       -- Describe table structure
SELECT * FROM tablename LIMIT 5;  -- Preview data
```

To see all foreign keys:
```sql
SELECT conname AS constraint_name, conrelid::regclass AS table,
       a.attname AS column, confrelid::regclass AS referenced_table
FROM pg_constraint
JOIN pg_class ON conrelid = pg_class.oid
JOIN pg_attribute a ON a.attrelid = conrelid AND a.attnum = ANY(conkey)
WHERE contype = 'f';
```
</file>

<file path="Dockerfile">
# Use Python 3.10 slim as base image
FROM python:3.10-slim

# Set working directory
WORKDIR /app

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app

# Install system dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        build-essential \
        libpq-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN adduser --disabled-password --gecos "" appuser
RUN chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Start application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="docs/FRONTEND_API_SETUP.md">
# Inboxerr Backend - Frontend Developer Setup

This guide will help frontend developers set up and interact with the Inboxerr backend API.

## Quick Start

1. Clone the repository
```bash
git clone https://github.com/your-org/inboxerr-backend.git
cd inboxerr-backend
```

2. Set up a virtual environment
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies
```bash
pip install -r requirements.txt
```

4. Create a local config file
```bash
cp .env.example .env
```

5. Set up the database
```bash
# Make sure PostgreSQL is running on your system
# Create database
psql -U postgres -c "CREATE DATABASE inboxerr;"

# Run migrations
alembic upgrade head
```

6. Seed sample data for frontend development
```bash
python scripts/seed_frontend_data.py
```

7. Start the server
```bash
uvicorn app.main:app --reload
```

8. Access the API at http://localhost:8000/api/docs

## Sample Account

After running the seed script, you can use these credentials:
- Email: `test@example.com`
- Password: `Test1234!`

## Key Features Ready for Frontend Integration

-  User authentication (JWT)
-  Send individual and batch SMS messages
-  Message templates with variable substitution
-  Campaign management
-  Message status tracking
-  Webhook handling for status updates

## API Documentation

See the [Inboxerr API Frontend Developer Guide](FRONTEND_API_GUIDE.md) for complete documentation of all available endpoints.

## Mock SMS Gateway

For frontend development, the backend can operate without real SMS Gateway credentials. Messages will be processed normally but not actually sent:

1. In development mode, the backend will simulate sending messages
2. All webhook events can be manually triggered for testing
3. All message statuses can be updated through the API

## Using with Docker (Alternative)

If you prefer using Docker:

```bash
# Start all services
docker-compose up -d

# Seed sample data
docker-compose exec api python scripts/seed_frontend_data.py
```

## Testing Webhooks

To test webhook events for message status updates:

```bash
# Replace EVENT_TYPE with: sms:sent, sms:delivered, or sms:failed
curl -X POST http://localhost:8000/api/v1/webhooks/test/{EVENT_TYPE} \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"message_id": "YOUR_MESSAGE_ID"}'
```

## Troubleshooting

- **Database connection issues**: Ensure PostgreSQL is running and credentials are correct in `.env`
- **Authentication errors**: Check that you're using the correct bearer token format
- **CORS errors**: Add your frontend URL to `BACKEND_CORS_ORIGINS` in `.env`

## Need Help?

Contact the backend team via:
- Slack: #inboxerr-backend
- Email: backend@inboxerr.com
</file>

<file path="docs/FRONTEND_DEVELOPER_GUIDE.md">
# Inboxerr API - Frontend Developer Guide

This document provides frontend developers with essential information for integrating with the Inboxerr backend API.

## Base URL

```
http://localhost:8000/api/v1
```

For production, this will be replaced with the actual deployment URL.

## Authentication

### Getting a Token

```
POST /auth/token
```

**Request Body:**
```json
{
  "username": "your-email@example.com",
  "password": "your-password"
}
```

**Response:**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "expires_at": "2025-04-25T20:04:04.790Z"
}
```

### Using Authentication

Include the token in all subsequent requests:

```
Authorization: Bearer {access_token}
```

### Test User Credentials

For development, use the following credentials:

- Email: `test@example.com`
- Password: `Test1234!`

## Key Endpoints

### 1. Send a Single SMS

```
POST /messages/send
```

**Request Body:**
```json
{
  "phone_number": "+1234567890",
  "message": "Your message content",
  "scheduled_at": null,
  "custom_id": "optional-tracking-id"
}
```

### 2. Send Batch Messages

```
POST /messages/batch
```

**Request Body:**
```json
{
  "messages": [
    {
      "phone_number": "+1234567890",
      "message": "Message for recipient 1",
      "scheduled_at": null
    },
    {
      "phone_number": "+9876543210",
      "message": "Message for recipient 2",
      "scheduled_at": null
    }
  ],
  "options": {
    "delay_between_messages": 0.3,
    "fail_on_first_error": false
  }
}
```

### 3. List Messages

```
GET /messages?skip=0&limit=20
```

Optional query parameters:
- `status` - Filter by message status (pending, sent, delivered, failed)
- `phone_number` - Filter by phone number
- `from_date` - Filter by date (ISO format)
- `to_date` - Filter by date (ISO format)

### 4. Message Templates

#### Create Template

```
POST /templates
```

**Request Body:**
```json
{
  "name": "Welcome Template",
  "content": "Hello {{name}}, welcome to our service!",
  "description": "Welcome message for new users"
}
```

#### Send Using Template

```
POST /templates/send
```

**Request Body:**
```json
{
  "template_id": "template-uuid",
  "phone_number": "+1234567890",
  "variables": {
    "name": "John"
  }
}
```

### 5. Campaigns

#### Create Campaign

```
POST /campaigns
```

**Request Body:**
```json
{
  "name": "Marketing Campaign",
  "description": "Product launch campaign",
  "scheduled_start_at": "2025-05-01T09:00:00Z",
  "scheduled_end_at": "2025-05-01T18:00:00Z"
}
```

#### Start Campaign

```
POST /campaigns/{campaign_id}/start
```

## Status Codes

- `200` - Success
- `201` - Created
- `202` - Accepted (for async processing)
- `400` - Bad request
- `401` - Unauthorized
- `403` - Forbidden
- `404` - Not found
- `422` - Validation error
- `429` - Rate limit exceeded
- `500` - Server error

## Error Format

All API errors follow this format:

```json
{
  "status": "error",
  "code": "ERROR_CODE",
  "message": "Human-readable error message",
  "details": {}
}
```

## Pagination

Endpoints that return lists support pagination:

```
GET /messages?page=1&limit=20
```

Response includes pagination info:

```json
{
  "items": [...],
  "page_info": {
    "current_page": 1,
    "total_pages": 5,
    "page_size": 20,
    "total_items": 100,
    "has_previous": false,
    "has_next": true
  }
}
```

## Message Status Flow

Messages follow this status flow:

1. `pending` - Initial state when created
2. `scheduled` - For future delivery
3. `processed` - Submitted to SMS gateway
4. `sent` - Accepted by the carrier
5. `delivered` - Confirmed delivery to recipient
6. `failed` - Failed to deliver

## Webhooks

For development, you can test webhook events using:

```
GET /webhooks/test/{event_type}
```

Where `event_type` can be:
- `sms:sent`
- `sms:delivered`
- `sms:failed`

## Rate Limits

- Message sending: 60 requests per minute
- Batch operations: 10 requests per minute
- Template operations: 100 requests per minute

## Development Notes

- Phone numbers should be in E.164 format (e.g., +1234567890)
- Messages longer than 160 characters will be sent as multi-part SMS
- SMS templates support variable substitution using `{{variable_name}}` syntax
</file>

<file path="docs/Message Template System - User Guide.md">
# Message Template System - User Guide

## Overview

The message template system allows you to create reusable templates for your SMS messages. This is particularly useful when you need to send similar messages to multiple recipients with personalized content.

## Key Features

- Create and manage reusable message templates
- Support for variables using the `{{variable_name}}` syntax
- Preview how templates will look with specific variable values
- Send messages using templates with just a phone number and variable values
- Send batch messages using the same template with different variables for each recipient

## Creating Templates

### Via API

```http
POST /api/v1/templates
Content-Type: application/json
Authorization: Bearer YOUR_TOKEN

{
  "name": "OTP Notification",
  "content": "Your verification code is {{code}}. It will expire in {{minutes}} minutes.",
  "description": "Template for sending OTP codes",
  "is_active": true
}
```

The system will automatically detect variables in the format `{{variable_name}}` from your template content.

### Variable Format

Variables should be enclosed in double curly braces like `{{variable_name}}`. Variable names can contain letters, numbers, and underscores.

Examples:
- `{{code}}`
- `{{user_name}}`
- `{{order_123}}`

## Using Templates

### Previewing a Template

Before sending, you can preview how your template will look with specific variables:

```http
POST /api/v1/templates/apply?template_id=TEMPLATE_ID
Content-Type: application/json
Authorization: Bearer YOUR_TOKEN

{
  "variables": {
    "code": "123456",
    "minutes": "15"
  }
}
```

Response:
```json
{
  "result": "Your verification code is 123456. It will expire in 15 minutes.",
  "missing_variables": []
}
```

### Sending a Message with a Template

```http
POST /api/v1/templates/send
Content-Type: application/json
Authorization: Bearer YOUR_TOKEN

{
  "template_id": "TEMPLATE_ID",
  "phone_number": "+1234567890",
  "variables": {
    "code": "123456",
    "minutes": "15"
  },
  "scheduled_at": null,
  "custom_id": "otp-1234"
}
```

This will apply the variables to your template and send the resulting message.

### Batch Sending with Templates

For sending to multiple recipients with different variables:

```http
POST /api/v1/messages/batch
Content-Type: application/json
Authorization: Bearer YOUR_TOKEN

{
  "messages": [
    {
      "phone_number": "+1234567890",
      "message": "Your custom message using {{variable}} syntax",
      "custom_id": "batch-1"
    },
    {
      "phone_number": "+0987654321",
      "message": "Another message with {{different}} variable",
      "custom_id": "batch-2"
    }
  ],
  "options": {
    "delay_between_messages": 0.3,
    "fail_on_first_error": false
  }
}
```

## Managing Templates

### Listing Templates

```http
GET /api/v1/templates?active_only=true
Authorization: Bearer YOUR_TOKEN
```

### Getting a Specific Template

```http
GET /api/v1/templates/{template_id}
Authorization: Bearer YOUR_TOKEN
```

### Updating a Template

```http
PUT /api/v1/templates/{template_id}
Content-Type: application/json
Authorization: Bearer YOUR_TOKEN

{
  "name": "Updated OTP Template",
  "content": "Your code is {{code}}. Valid for {{minutes}} minutes.",
  "is_active": true
}
```

### Deleting a Template

```http
DELETE /api/v1/templates/{template_id}
Authorization: Bearer YOUR_TOKEN
```

## Best Practices

1. **Descriptive Variable Names**: Use clear, descriptive variable names that indicate what data should be inserted.

2. **Test Before Sending**: Always use the `/templates/apply` endpoint to test how your template will look with real data before sending messages.

3. **Handle Missing Variables**: Check the `missing_variables` field in responses to ensure all required variables are provided.

4. **Version Your Templates**: If you need to make significant changes to a template that's in use, consider creating a new version instead of updating the existing one.

5. **Keep Templates Simple**: Avoid complex formatting that might not render well on all mobile devices.

6. **Include Message Signature**: Consider including your company name or service identifier at the end of templates to help recipients identify the sender.

## Examples

### Appointment Reminder

```
Template Content:
"Hi {{name}}, this is a reminder for your appointment on {{date}} at {{time}}. Reply YES to confirm or call {{phone}} to reschedule."

Applied with:
{
  "name": "John",
  "date": "May 5, 2025",
  "time": "2:30 PM",
  "phone": "555-123-4567"
}

Result:
"Hi John, this is a reminder for your appointment on May 5, 2025 at 2:30 PM. Reply YES to confirm or call 555-123-4567 to reschedule."
```

### Order Confirmation

```
Template Content:
"Your order #{{order_id}} has been confirmed! Estimated delivery: {{delivery_date}}. Track your package at {{tracking_url}}. Thanks for shopping with {{company_name}}!"

Applied with:
{
  "order_id": "1234567",
  "delivery_date": "Apr 28-30, 2025",
  "tracking_url": "https://track.example.com/1234567",
  "company_name": "Example Shop"
}

Result:
"Your order #1234567 has been confirmed! Estimated delivery: Apr 28-30, 2025. Track your package at https://track.example.com/1234567. Thanks for shopping with Example Shop!"
```
</file>

<file path="scripts/generate_migration.py">
#!/usr/bin/env python
"""
Generate Alembic migrations.

This script parses database credentials from settings and runs alembic to generate migrations.

Usage:
    python scripts/generate_migration.py "Add message templates"
"""
import sys
import subprocess
import re
from pathlib import Path

# Add parent directory to path to allow importing from app
sys.path.append(str(Path(__file__).parent.parent))

# Import after adding to path
from app.core.config import settings

def generate_migration(message):
    """Generate an Alembic migration with the given message."""
    try:
        # Set the Alembic database URL from settings
        # Replace asyncpg with standard psycopg2 for Alembic
        db_url = settings.DATABASE_URL.replace("postgresql+asyncpg", "postgresql")
        
        # Set environment variable for Alembic
        import os
        os.environ["ALEMBIC_DB_URL"] = db_url
        
        # Run alembic command
        print(f"Generating migration: {message}")
        result = subprocess.run(
            ["alembic", "revision", "--autogenerate", "-m", message], 
            check=True,
            capture_output=True,
            text=True
        )
        
        # Parse output to find migration file path
        output = result.stdout
        file_pattern = r"Generating .*\\(.*?\.py)"
        match = re.search(file_pattern, output)
        
        if match:
            migration_file = match.group(1)
            print(f" Successfully generated migration: {migration_file}")
        else:
            print(f" Successfully generated migration")
            
        print(" Please review the generated migration file to ensure it's correct.")
        print(" To apply the migration, run: alembic upgrade head")
        
    except subprocess.CalledProcessError as e:
        print(f" Error generating migration: {e}")
        print("Error output:")
        print(e.stderr)
        print(" Make sure alembic is installed and your database is running.")
        sys.exit(1)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(" Error: Please provide a migration message.")
        print(" Example: python scripts/generate_migration.py 'Add user table'")
        sys.exit(1)
    
    message = sys.argv[1]
    generate_migration(message)
</file>

<file path="scripts/mvp.sh">
#!/bin/bash
# MVP Setup and Run Script
# This script helps set up and run all components needed for the MVP

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}=== Inboxerr MVP Setup and Run ===${NC}"
echo "This script will help you set up and run all MVP components"

# Extract database connection details from settings
get_db_info() {
  echo "Extracting database connection details..."
  
  # Run a Python script to get DB connection info from settings
  python -c "
from app.core.config import settings
import re

# Parse the connection URL
url = settings.DATABASE_URL
pattern = r'postgresql(?:\+asyncpg)?://([^:]+):([^@]+)@([^:]+):(\d+)/([^?]+)'
match = re.match(pattern, url)

if match:
    print(f'DB_USER={match.group(1)}')
    print(f'DB_PASS={match.group(2)}')
    print(f'DB_HOST={match.group(3)}')
    print(f'DB_PORT={match.group(4)}')
    print(f'DB_NAME={match.group(5)}')
else:
    print('Could not parse database URL')
  "
}

# Source the DB info (if Python script outputs variables)
eval "$(get_db_info)"

# Check if PostgreSQL is running using the extracted credentials
check_postgres() {
  if [ -z "$DB_HOST" ] || [ -z "$DB_PORT" ] || [ -z "$DB_USER" ]; then
    echo -e "${RED}Could not extract database connection details from settings.${NC}"
    return 1
  fi
  
  export PGPASSWORD=$DB_PASS
  pg_status=$(psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d postgres -c "SELECT 1;" 2>/dev/null)
  
  if [ $? -ne 0 ]; then
    echo -e "${RED}PostgreSQL is not running or connection failed.${NC}"
    echo "Please make sure PostgreSQL is running and connection details are correct:"
    echo "Host: $DB_HOST"
    echo "Port: $DB_PORT"
    echo "User: $DB_USER"
    echo "Database: $DB_NAME"
    return 1
  else
    echo -e "${GREEN}PostgreSQL connection successful.${NC}"
    return 0
  fi
}

# Check PostgreSQL connection
if ! check_postgres; then
  echo -e "${YELLOW}Would you like to continue anyway? (y/N)${NC}"
  read continue_anyway
  if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
    echo "Exiting."
    exit 1
  fi
fi

# Create directories if needed
if [ ! -d "tests" ]; then
  echo -e "${YELLOW}Creating test directories...${NC}"
  mkdir -p tests/unit
  mkdir -p tests/integration
  mkdir -p tests/unit/services
  mkdir -p tests/unit/repositories
  mkdir -p tests/unit/api
  mkdir -p tests/integration/api
  
  # Create empty __init__.py files
  touch tests/__init__.py
  touch tests/unit/__init__.py
  touch tests/integration/__init__.py
  touch tests/unit/services/__init__.py
  touch tests/unit/repositories/__init__.py
  touch tests/unit/api/__init__.py
  touch tests/integration/api/__init__.py
  
  echo -e "${GREEN}Test directory structure created!${NC}"
fi

# Function to show menu
show_menu() {
  echo ""
  echo -e "${BLUE}Available actions:${NC}"
  echo "1) Setup development database"
  echo "2) Generate database migrations"
  echo "3) Run migrations"
  echo "4) Run tests"
  echo "5) Start API server"
  echo "6) View API documentation"
  echo "q) Quit"
  echo ""
  echo -n "Enter your choice: "
}

# Main menu loop
while true; do
  show_menu
  read choice

  case $choice in
    1)
      echo -e "${YELLOW}Setting up development database...${NC}"
      python scripts/setup_test_db.py
      ;;
    2)
      echo -e "${YELLOW}Generating database migrations...${NC}"
      read -p "Enter migration description: " desc
      python scripts/generate_migration.py "$desc"
      ;;
    3)
      echo -e "${YELLOW}Running database migrations...${NC}"
      alembic upgrade head
      ;;
    4)
      echo -e "${YELLOW}Running tests...${NC}"
      python scripts/run_tests.py
      ;;
    5)
      echo -e "${YELLOW}Starting API server...${NC}"
      echo -e "${GREEN}API will be available at: http://localhost:8000${NC}"
      echo -e "${GREEN}API Docs URL: http://localhost:8000/api/docs${NC}"
      echo -e "${YELLOW}Press CTRL+C to stop the server${NC}"
      uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
      ;;
    6)
      echo -e "${YELLOW}Opening API documentation...${NC}"
      if command -v xdg-open &> /dev/null; then
        xdg-open http://localhost:8000/api/docs
      elif command -v open &> /dev/null; then
        open http://localhost:8000/api/docs
      elif command -v start &> /dev/null; then
        start http://localhost:8000/api/docs
      else
        echo -e "${RED}Cannot open browser automatically.${NC}"
        echo -e "${GREEN}Please visit: http://localhost:8000/api/docs${NC}"
      fi
      ;;
    q|Q)
      echo -e "${GREEN}Goodbye!${NC}"
      exit 0
      ;;
    *)
      echo -e "${RED}Invalid choice. Please try again.${NC}"
      ;;
  esac
done
</file>

<file path="scripts/reset_db.py">
"""
Reset the development database, run Alembic migrations, and seed initial data.
Works with PostgreSQL database.
"""
import sys
import os
import subprocess
from pathlib import Path



# Resolve project root dynamically
PROJECT_ROOT = Path(__file__).resolve().parent.parent

def reset_database() -> None:
    """
    Reset the development database, run Alembic migrations, and seed initial data.
    This should only be used in development environments.
    """
    # Reset PostgreSQL database (drop and recreate)
    print(" Resetting PostgreSQL database...")
    try:
        # Connect to default postgres database to drop/create our database
        subprocess.run(
            ["psql", "-U", "postgres", "-c", "DROP DATABASE IF EXISTS inboxerr;"],
            check=True
        )
        subprocess.run(
            ["psql", "-U", "postgres", "-c", "CREATE DATABASE inboxerr;"],
            check=True
        )
        print(" Database reset successfully")
    except subprocess.CalledProcessError as e:
        print(f" Error resetting database: {e}")
        print(" Make sure PostgreSQL is running and you have permissions")
        sys.exit(1)

    print(" Running Alembic migrations...")
    subprocess.run(["alembic", "upgrade", "head"], check=True, cwd=PROJECT_ROOT)

    print(" Seeding initial data...")
    subprocess.run(
        [sys.executable, "scripts/seed_db.py"], 
        check=True, 
        cwd=PROJECT_ROOT,
        env={**os.environ, "PYTHONPATH": str(PROJECT_ROOT)}
    )

    print(" Database reset and seeded successfully!")

if __name__ == "__main__":
    reset_database()
</file>

<file path="scripts/run_tests.py">
#!/usr/bin/env python
"""
Run application tests with pytest.

This script:
1. Creates a test database if it doesn't exist
2. Runs pytest with specified options
3. Generates a coverage report

Usage:
    python scripts/run_tests.py [pytest_args]
    
Examples:
    python scripts/run_tests.py                             # Run all tests
    python scripts/run_tests.py tests/integration           # Run integration tests
    python scripts/run_tests.py -v tests/unit/test_users.py # Run specific test with verbose output
"""
import sys
import os
import subprocess
import re
from pathlib import Path

# Add parent directory to sys.path
sys.path.append(str(Path(__file__).parent.parent))

# Import settings after adding to path
from app.core.config import settings

# Extract database connection info from the URL
def parse_db_url(url):
    """Parse database URL to extract connection information."""
    # PostgreSQL URL format: postgresql+asyncpg://user:password@host:port/dbname
    pattern = r"postgresql(?:\+asyncpg)?://([^:]+):([^@]+)@([^:]+):(\d+)/([^?]+)"
    match = re.match(pattern, url)
    
    if match:
        return {
            "user": match.group(1),
            "password": match.group(2),
            "host": match.group(3),
            "port": match.group(4),
            "dbname": match.group(5)
        }
    return None

def run_tests():
    """Run tests with pytest."""
    # Get pytest arguments from command line
    pytest_args = sys.argv[1:] if len(sys.argv) > 1 else []
    
    # Create test database name
    db_info = parse_db_url(settings.DATABASE_URL)
    if not db_info:
        print(" Could not parse database URL. Please check the format.")
        return False
    
    test_db_name = f"{db_info['dbname']}_test"
    
    # Set up test database environment variable
    os.environ["DATABASE_URL"] = f"postgresql+asyncpg://{db_info['user']}:{db_info['password']}@{db_info['host']}:{db_info['port']}/{test_db_name}"
    os.environ["TESTING"] = "1"
    
    # Print the test database URL
    print(f"Using test database: {test_db_name}")
    
    # Get environment variables for PGPASSWORD to avoid password prompt
    env = os.environ.copy()
    env["PGPASSWORD"] = db_info["password"]
    
    # Check if test database exists
    try:
        check_db = subprocess.run(
            ["psql", 
             "-h", db_info["host"], 
             "-p", db_info["port"], 
             "-U", db_info["user"], 
             "-d", "postgres", 
             "-c", f"SELECT 1 FROM pg_database WHERE datname = '{test_db_name}';"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=env
        )
        
        if "1 row" not in check_db.stdout.decode():
            print(f"Creating test database {test_db_name}...")
            create_db = subprocess.run(
                ["psql", 
                 "-h", db_info["host"], 
                 "-p", db_info["port"], 
                 "-U", db_info["user"], 
                 "-d", "postgres", 
                 "-c", f"CREATE DATABASE {test_db_name};"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env
            )
            
            if create_db.returncode != 0:
                print(f" Failed to create test database: {create_db.stderr.decode()}")
                return False
            
            print(f" Test database {test_db_name} created")
    except Exception as e:
        print(f" Could not check/create test database: {e}")
        print("Continuing with tests...")
    
    # Default pytest arguments if none provided
    if not pytest_args:
        # Run all tests with coverage
        pytest_args = [
            "--cov=app",
            "--cov-report=term-missing",
            "--cov-report=html",
            "-v",
            "tests/"
        ]
    
    # Run pytest
    print(f"Running tests with args: {' '.join(pytest_args)}")
    result = subprocess.run(["pytest"] + pytest_args)
    
    # Print results
    if result.returncode == 0:
        print(" All tests passed!")
    else:
        print(f" Tests failed with exit code: {result.returncode}")
    
    return result.returncode == 0


if __name__ == "__main__":
    sys.exit(0 if run_tests() else 1)
</file>

<file path="scripts/seed_frontend_data.py">
#!/usr/bin/env python
"""
Seed database with sample data for frontend development.

This script creates sample users, templates, messages and campaigns
to make frontend development easier.

Usage:
    python scripts/seed_frontend_data.py
"""
import asyncio
import sys
import os
from pathlib import Path
from datetime import datetime, timedelta, timezone
import random
import uuid

# Add parent directory to path
sys.path.append(str(Path(__file__).parent.parent))

# Import app modules
from app.db.session import initialize_database, async_session_factory
from app.db.repositories.users import UserRepository
from app.db.repositories.templates import TemplateRepository
from app.db.repositories.messages import MessageRepository
from app.db.repositories.campaigns import CampaignRepository
from app.core.security import get_password_hash
from app.schemas.message import MessageStatus

# Sample phone numbers
PHONE_NUMBERS = [
    "+12025550108", "+12025550112", "+12025550118", "+12025550121",
    "+12025550125", "+12025550132", "+12025550139", "+12025550144",
    "+12025550152", "+12025550158", "+12025550165", "+12025550171"
]

# Sample message templates
TEMPLATES = [
    {
        "name": "Welcome Message",
        "content": "Hi {{name}}, welcome to our service! We're glad you've joined us.",
        "description": "Template for welcoming new users"
    },
    {
        "name": "OTP Verification",
        "content": "Your verification code is {{code}}. It will expire in {{minutes}} minutes.",
        "description": "Template for sending OTP codes"
    },
    {
        "name": "Appointment Reminder",
        "content": "Hi {{name}}, this is a reminder for your appointment on {{date}} at {{time}}. Reply YES to confirm or call {{phone}} to reschedule.",
        "description": "Template for appointment reminders"
    },
    {
        "name": "Order Confirmation",
        "content": "Your order #{{order_id}} has been confirmed! Estimated delivery: {{delivery_date}}. Track your package at {{tracking_url}}",
        "description": "Order confirmation message"
    },
    {
        "name": "Payment Reminder",
        "content": "Reminder: Your payment of ${{amount}} is due on {{due_date}}. Please ensure your account has sufficient funds.",
        "description": "Payment reminder notification"
    }
]

# Sample messages
MESSAGES = [
    "Your verification code is 123456",
    "Your appointment is confirmed for tomorrow at 10:00 AM",
    "Your order #12345 has been shipped and will arrive on Friday",
    "Thank you for your payment of $99.99",
    "Your subscription will renew on May 15, 2025",
    "Your account password has been reset successfully",
    "Your flight PO491 has been delayed by 30 minutes",
    "Your table reservation at Milano Restaurant is confirmed",
    "Your prescription is ready for pickup at Central Pharmacy",
    "Reminder: You have a meeting scheduled in 1 hour"
]

# Sample campaign names
CAMPAIGN_NAMES = [
    "Spring Sale Promotion",
    "Customer Feedback Survey",
    "Product Launch Announcement",
    "Abandoned Cart Reminder",
    "Loyalty Program Update"
]

async def create_test_user():
    """Create a test user if it doesn't exist."""
    async with async_session_factory() as session:
        # Create user repository
        user_repo = UserRepository(session)
        
        # Check if user exists
        existing_user = await user_repo.get_by_email("test@example.com")
        if existing_user:
            print(f" Test user test@example.com already exists")
            return existing_user
        
        # Create user
        hashed_password = get_password_hash("Test1234!")
        user = await user_repo.create(
            email="test@example.com",
            hashed_password=hashed_password,
            full_name="Test User",
            role="user"
        )
        
        print(f" Created test user: {user.email}")
        return user

async def create_test_templates(user_id):
    """Create test message templates."""
    async with async_session_factory() as session:
        # Create template repository
        template_repo = TemplateRepository(session)
        
        created_templates = []
        # Create templates
        for template_data in TEMPLATES:
            template = await template_repo.create_template(
                name=template_data["name"],
                content=template_data["content"],
                description=template_data["description"],
                user_id=user_id
            )
            created_templates.append(template)
            print(f" Created template: {template_data['name']}")
        
        return created_templates

async def create_test_messages(user_id, template_id=None):
    """Create test messages with different statuses."""
    async with async_session_factory() as session:
        # Create message repository
        message_repo = MessageRepository(session)
        
        # Generate different message statuses
        statuses = [
            MessageStatus.PENDING,
            MessageStatus.SENT,
            MessageStatus.DELIVERED,
            MessageStatus.FAILED,
            MessageStatus.SCHEDULED
        ]
        
        created_messages = []
        # Create messages with different statuses
        for i, message_text in enumerate(MESSAGES):
            phone = random.choice(PHONE_NUMBERS)
            status = statuses[i % len(statuses)]
            
            # For scheduled messages, set a future time
            scheduled_at = None
            if status == MessageStatus.SCHEDULED:
                scheduled_at = datetime.now(timezone.utc) + timedelta(days=1)
            
            # Create message
            message = await message_repo.create_message(
                phone_number=phone,
                message_text=message_text,
                user_id=user_id,
                custom_id=f"sample-{uuid.uuid4().hex[:8]}",
                scheduled_at=scheduled_at,
                metadata={"sample": True, "template_id": template_id}
            )
            
            # If not scheduled, update to the appropriate status
            if status != MessageStatus.SCHEDULED and status != MessageStatus.PENDING:
                # Update message status
                await message_repo.update_message_status(
                    message_id=message.id,
                    status=status,
                    event_type="seeded_data",
                    reason="Sample data" if status == MessageStatus.FAILED else None,
                    gateway_message_id=f"gw-{uuid.uuid4()}" if status != MessageStatus.PENDING else None
                )
            
            created_messages.append(message)
            print(f" Created message with status {status}: {message_text[:30]}...")
        
        return created_messages

async def create_test_campaigns(user_id):
    """Create test campaigns."""
    async with async_session_factory() as session:
        # Create campaign repository
        campaign_repo = CampaignRepository(session)
        message_repo = MessageRepository(session)
        
        created_campaigns = []
        # Create campaigns with different statuses
        statuses = ["draft", "active", "paused", "completed", "cancelled"]
        
        for i, name in enumerate(CAMPAIGN_NAMES):
            status = statuses[i % len(statuses)]
            
            # Create campaign
            campaign = await campaign_repo.create_campaign(
                name=name,
                description=f"Sample campaign: {name}",
                user_id=user_id,
                scheduled_start_at=datetime.now(timezone.utc) + timedelta(days=1),
                scheduled_end_at=datetime.now(timezone.utc) + timedelta(days=2),
                settings={"sample": True}
            )
            
            # Add 3-5 messages to each campaign
            msg_count = random.randint(3, 5)
            for j in range(msg_count):
                phone = random.choice(PHONE_NUMBERS)
                message_text = f"Campaign {name}: {random.choice(MESSAGES)}"
                
                await message_repo.create_message(
                    phone_number=phone,
                    message_text=message_text,
                    user_id=user_id,
                    campaign_id=campaign.id,
                    metadata={"campaign": name}
                )
            
            # Update campaign stats
            campaign.total_messages = msg_count
            
            # Update campaign status
            if status != "draft":
                await campaign_repo.update_campaign_status(
                    campaign_id=campaign.id,
                    status=status,
                    started_at=datetime.now(timezone.utc) - timedelta(days=1) if status != "draft" else None,
                    completed_at=datetime.now(timezone.utc) if status in ["completed", "cancelled"] else None
                )
                
                # Update stats for non-draft campaigns
                if status in ["active", "paused", "completed"]:
                    sent = msg_count if status in ["completed"] else random.randint(1, msg_count)
                    delivered = random.randint(0, sent) if status in ["completed"] else 0
                    failed = random.randint(0, msg_count - sent) if status in ["completed"] else 0
                    
                    await campaign_repo.update_campaign_stats(
                        campaign_id=campaign.id,
                        increment_sent=sent,
                        increment_delivered=delivered,
                        increment_failed=failed
                    )
            
            created_campaigns.append(campaign)
            print(f" Created campaign with status {status}: {name}")
        
        return created_campaigns

async def seed_database():
    """Seed database with sample data."""
    print(" Seeding database with frontend development data...")
    
    # Initialize database
    await initialize_database()
    
    # Create test user
    user = await create_test_user()
    
    # Create templates
    templates = await create_test_templates(user.id)
    
    # Create messages
    if templates:
        await create_test_messages(user.id, templates[0].id)
    else:
        await create_test_messages(user.id)
    
    # Create campaigns
    await create_test_campaigns(user.id)
    
    print("\n Database seeded successfully with frontend development data!")
    print(f" Test user: test@example.com")
    print(f" Password: Test1234!")

if __name__ == "__main__":
    asyncio.run(seed_database())
</file>

<file path="scripts/setup_test_db.py">
#!/usr/bin/env python
"""
Setup a test database for development.

This script:
1. Checks if the test database exists
2. Creates it if it doesn't
3. Runs all migrations
4. Seeds it with test data

Usage:
    python scripts/setup_test_db.py
"""
import sys
import os
import asyncio
import subprocess
from pathlib import Path
import re

# Add parent directory to path to allow importing app
sys.path.append(str(Path(__file__).parent.parent))

# Import app modules
from app.core.config import settings
from app.db.session import initialize_database
from app.db.repositories.users import UserRepository
from app.db.repositories.templates import TemplateRepository
from app.core.security import get_password_hash

# Test data to seed
TEST_USER = {
    "email": "test@example.com",
    "password": "Test1234!",
    "full_name": "Test User",
    "role": "user"
}

TEST_TEMPLATES = [
    {
        "name": "Welcome Message",
        "content": "Hi {{name}}, welcome to our service! We're glad you've joined us.",
        "description": "Template for welcoming new users"
    },
    {
        "name": "OTP Verification",
        "content": "Your verification code is {{code}}. It will expire in {{minutes}} minutes.",
        "description": "Template for sending OTP codes"
    },
    {
        "name": "Appointment Reminder",
        "content": "Hi {{name}}, this is a reminder for your appointment on {{date}} at {{time}}. Reply YES to confirm or call {{phone}} to reschedule.",
        "description": "Template for appointment reminders"
    }
]

# Extract database connection info from the URL
def parse_db_url(url):
    """Parse database URL to extract connection information."""
    # PostgreSQL URL format: postgresql+asyncpg://user:password@host:port/dbname
    pattern = r"postgresql(?:\+asyncpg)?://([^:]+):([^@]+)@([^:]+):(\d+)/([^?]+)"
    match = re.match(pattern, url)
    
    if match:
        return {
            "user": match.group(1),
            "password": match.group(2),
            "host": match.group(3),
            "port": match.group(4),
            "dbname": match.group(5)
        }
    return None

async def create_test_user():
    """Create a test user if it doesn't exist."""
    from app.db.session import async_session_factory
    
    async with async_session_factory() as session:
        # Create user repository
        user_repo = UserRepository(session)
        
        # Check if user exists
        existing_user = await user_repo.get_by_email(TEST_USER["email"])
        if existing_user:
            print(f" Test user {TEST_USER['email']} already exists")
            return existing_user
        
        # Create user
        hashed_password = get_password_hash(TEST_USER["password"])
        user = await user_repo.create(
            email=TEST_USER["email"],
            hashed_password=hashed_password,
            full_name=TEST_USER["full_name"],
            role=TEST_USER["role"]
        )
        
        print(f" Created test user: {user.email}")
        return user

async def create_test_templates(user_id):
    """Create test message templates."""
    from app.db.session import async_session_factory
    
    async with async_session_factory() as session:
        # Create template repository
        template_repo = TemplateRepository(session)
        
        # Create templates
        for template_data in TEST_TEMPLATES:
            await template_repo.create_template(
                name=template_data["name"],
                content=template_data["content"],
                description=template_data["description"],
                user_id=user_id
            )
            print(f" Created template: {template_data['name']}")

async def setup_database():
    """Setup the test database."""
    try:
        # Get database configuration from settings
        db_info = parse_db_url(settings.DATABASE_URL)
        if not db_info:
            print(" Could not parse database URL. Please check the format.")
            return False
        
        # Extract database name and create connection to postgres database
        db_name = db_info["dbname"]
        postgres_url = f"postgresql://{db_info['user']}:{db_info['password']}@{db_info['host']}:{db_info['port']}/postgres"
        
        # Get environment variables for PGPASSWORD to avoid password prompt
        env = os.environ.copy()
        env["PGPASSWORD"] = db_info["password"]
        
        # Test connection using psql
        connection_test = subprocess.run(
            ["psql", 
             "-h", db_info["host"], 
             "-p", db_info["port"], 
             "-U", db_info["user"], 
             "-d", "postgres", 
             "-c", "SELECT 1;"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=env
        )
        
        if connection_test.returncode != 0:
            print(" Could not connect to PostgreSQL server.")
            print(connection_test.stderr.decode())
            print("Please make sure PostgreSQL is running and the credentials are correct.")
            return False
        
        # Check if database exists
        check_db = subprocess.run(
            ["psql", 
             "-h", db_info["host"], 
             "-p", db_info["port"], 
             "-U", db_info["user"], 
             "-d", "postgres", 
             "-c", f"SELECT 1 FROM pg_database WHERE datname = '{db_name}';"],
            stdout=subprocess.PIPE,
            env=env
        )
        
        if "1 row" not in check_db.stdout.decode():
            print(f"Creating database {db_name}...")
            create_db = subprocess.run(
                ["psql", 
                 "-h", db_info["host"], 
                 "-p", db_info["port"], 
                 "-U", db_info["user"], 
                 "-d", "postgres", 
                 "-c", f"CREATE DATABASE {db_name};"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env
            )
            
            if create_db.returncode != 0:
                print(f" Failed to create database {db_name}")
                print(create_db.stderr.decode())
                return False
            
            print(f" Database {db_name} created successfully")
        else:
            print(f" Database {db_name} already exists")
        
        # Run migrations
        print("Running Alembic migrations...")
        alembic = subprocess.run(
            ["alembic", "upgrade", "head"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        if alembic.returncode != 0:
            print(" Failed to run migrations")
            print(alembic.stderr.decode())
            return False
        
        print(" Migrations applied successfully")
        
        # Initialize database
        await initialize_database()
        
        # Create test user
        user = await create_test_user()
        
        # Create test templates
        await create_test_templates(user.id)
        
        print("\n Test database setup complete!")
        print(f" Test user: {TEST_USER['email']}")
        print(f" Password: {TEST_USER['password']}")
        
        return True
        
    except Exception as e:
        print(f" Error setting up test database: {e}")
        return False

if __name__ == "__main__":
    asyncio.run(setup_database())
</file>

<file path="tests/core_functionality_test.py">
import pytest
import asyncio
from datetime import datetime, timezone, timedelta
from uuid import uuid4
from unittest.mock import AsyncMock, patch, MagicMock

from app.schemas.message import MessageStatus
from app.db.repositories.messages import MessageRepository
from app.db.repositories.templates import TemplateRepository
from app.db.repositories.campaigns import CampaignRepository
from app.services.event_bus.bus import get_event_bus
from app.services.sms.sender import SMSSender
from app.utils.phone import validate_phone


@pytest.fixture
def event_loop():
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


import pytest_asyncio

@pytest_asyncio.fixture
async def event_bus():
    bus = get_event_bus()
    await bus.initialize()
    yield bus
    await bus.shutdown()


@pytest.fixture
def mock_session():
    session = AsyncMock()
    session.commit = AsyncMock()
    session.rollback = AsyncMock()
    session.close = AsyncMock()
    session.execute = AsyncMock()
    session.refresh = AsyncMock()
    session.add = MagicMock()
    session.delete = AsyncMock()
    # Mock session.begin for async context
    session.begin = MagicMock(return_value=AsyncMock(__aenter__=AsyncMock(return_value=None), __aexit__=AsyncMock(return_value=None)))
    return session


@pytest.fixture
def message_repository(mock_session):
    return MessageRepository(mock_session)


@pytest.fixture
def template_repository(mock_session):
    return TemplateRepository(mock_session)


@pytest.fixture
def campaign_repository(mock_session):
    return CampaignRepository(mock_session)


@pytest.fixture
def sms_sender(message_repository, event_bus):
    return SMSSender(message_repository, event_bus)


def test_phone_validation_valid_numbers():
    valid_numbers = ["+12025550108", "+447911123456", "+61412345678", "+33612345678"]
    for number in valid_numbers:
        is_valid, formatted, error, _ = validate_phone(number)
        assert is_valid
        assert formatted.startswith("+")


def test_phone_validation_invalid_numbers():
    invalid_numbers = ["not a number", "123", "+1234567890123456789", "+123abcd5678"]
    for number in invalid_numbers:
        is_valid, *_ = validate_phone(number)
        assert not is_valid


@pytest.mark.asyncio
async def test_create_message(message_repository):
    message_repository.session.refresh.side_effect = lambda x: x
    mock_campaign = MagicMock()
    mock_campaign.total_messages = 0
    with patch("app.db.repositories.campaigns.CampaignRepository.get_by_id", new_callable=AsyncMock, return_value=mock_campaign):
        message = await message_repository.create_message(
            phone_number="+12025550108",
            message_text="Test message",
            user_id="user-123",
            custom_id="custom-123",
            campaign_id="campaign-123"
        )
        assert message.phone_number == "+12025550108"
        assert message.status == MessageStatus.PENDING
        assert message_repository.session.add.call_count >= 1


@pytest.mark.asyncio
async def test_update_message_status(message_repository):
    message = MagicMock()
    message.id = "msg-123"
    message_repository.get_by_id = AsyncMock(return_value=message)
    message_repository.session.refresh.side_effect = lambda x: x
    updated_message = await message_repository.update_message_status(
        message_id="msg-123",
        status=MessageStatus.SENT,
        event_type="test",
        gateway_message_id="gw-123"
    )
    assert updated_message is not None
    message_repository.get_by_id.assert_awaited_with("msg-123")
    assert message_repository.session.add.call_count >= 1


@pytest.mark.asyncio
async def test_apply_template(template_repository):
    template = MagicMock()
    template.content = "Hello {{name}}, your code is {{code}}"
    template_repository.get_by_id = AsyncMock(return_value=template)
    result = await template_repository.apply_template(
        template_id="template-123",
        variables={"name": "John", "code": "123456"}
    )
    assert result == "Hello John, your code is 123456"
    template_repository.get_by_id.assert_awaited_with("template-123")


@pytest.mark.asyncio
async def test_create_template(template_repository):
    template_repository.session.refresh.side_effect = lambda x: x
    template = await template_repository.create_template(
        name="Test Template",
        content="Hello {{name}}",
        description="Test description",
        user_id="user-123"
    )
    assert template.name == "Test Template"
    template_repository.session.add.assert_called_with(template)
    template_repository.session.commit.assert_called()


@pytest.mark.asyncio
async def test_create_campaign(campaign_repository):
    campaign_repository.session.refresh.side_effect = lambda x: x
    campaign = await campaign_repository.create_campaign(
        name="Test Campaign",
        description="Test description",
        user_id="user-123",
        scheduled_start_at=datetime.now(timezone.utc) + timedelta(days=1)
    )
    assert campaign.name == "Test Campaign"
    campaign_repository.session.add.assert_called_with(campaign)
    campaign_repository.session.commit.assert_called()


@pytest.mark.asyncio
async def test_update_campaign_status(campaign_repository):
    campaign = MagicMock()
    campaign.id = "campaign-123"
    campaign.status = "draft"
    campaign_repository.get_by_id = AsyncMock(return_value=campaign)
    with patch("app.services.event_bus.bus.get_event_bus") as mock_get_bus:
        mock_bus = AsyncMock()
        mock_get_bus.return_value = mock_bus
        updated_campaign = await campaign_repository.update_campaign_status(
            campaign_id="campaign-123",
            status="active"
        )
        assert updated_campaign is not None
        assert campaign.status == "active"
        campaign_repository.session.add.assert_called_with(campaign)
        assert mock_bus.publish.called


@pytest.mark.asyncio
async def test_event_bus_subscribe_publish(event_bus):
    callback = AsyncMock()
    subscriber_id = await event_bus.subscribe("test_event", callback)
    assert event_bus.get_subscriber_count("test_event") == 1
    test_data = {"test": "data"}
    success = await event_bus.publish("test_event", test_data)
    assert success
    callback.assert_called_once()
    call_args = callback.call_args[0][0]
    assert call_args["test"] == "data"
    assert call_args["event_type"] == "test_event"
    assert "timestamp" in call_args
    assert "event_id" in call_args
    await event_bus.unsubscribe("test_event", subscriber_id)
    assert event_bus.get_subscriber_count("test_event") == 0


@pytest.mark.asyncio
async def test_sms_sender_send_message(sms_sender):
    sms_sender._send_to_gateway = AsyncMock(return_value={
        "status": MessageStatus.SENT,
        "gateway_message_id": "gw-123"
    })

    mock_message = MagicMock()
    mock_message.id = "msg-123"
    mock_message.dict = MagicMock(return_value={"id": "msg-123"})

    sms_sender.message_repository.create_message = AsyncMock(return_value=mock_message)
    sms_sender.message_repository.update_message_status = AsyncMock(return_value=mock_message)
    sms_sender.message_repository.get_by_id = AsyncMock(return_value=mock_message)  #  add this line

    result = await sms_sender.send_message(
        phone_number="+12025550108",
        message_text="Test message",
        user_id="user-123"
    )

    assert result == {"id": "msg-123"}
    assert sms_sender.message_repository.create_message.called
    assert sms_sender._send_to_gateway.called
    assert sms_sender.message_repository.update_message_status.called
</file>

<file path="tests/unit/api/messages/test_messages_endpoints.py">
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_send_valid_batch(async_client: AsyncClient, override_auth):
    payload = {
        "messages": [
            {"phone_number": "+1234567890", "message": "Batch Msg 1"},
            {"phone_number": "+1987654321", "message": "Batch Msg 2"}
        ],
        "options": {}
    }
    response = await async_client.post("/api/v1/messages/batch", json=payload)
    assert response.status_code == 202
    assert "results" in response.json()

@pytest.mark.asyncio
async def test_send_empty_batch(async_client: AsyncClient, override_auth):
    payload = {
        "messages": [],
        "options": {}
    }
    response = await async_client.post("/api/v1/messages/batch", json=payload)
    assert response.status_code == 422

@pytest.mark.asyncio
async def test_batch_with_invalid_phone(async_client: AsyncClient, override_auth):
    payload = {
        "messages": [
            {"phone_number": "invalid", "message": "Failing message"}
        ],
        "options": {}
    }
    response = await async_client.post("/api/v1/messages/batch", json=payload)
    assert response.status_code in [422, 502]


@pytest.mark.asyncio
async def test_delete_existing_message(async_client: AsyncClient, override_auth):
    message_id = "existing-msg-id"
    response = await async_client.delete(f"/api/v1/messages/{message_id}")
    assert response.status_code == 204

@pytest.mark.asyncio
async def test_delete_nonexistent_message(async_client: AsyncClient, override_auth):
    message_id = "nonexistent-msg-id"
    response = await async_client.delete(f"/api/v1/messages/{message_id}")
    assert response.status_code == 404

@pytest.mark.asyncio
async def test_get_existing_message(async_client: AsyncClient, override_auth):
    message_id = "existing-msg-id"
    response = await async_client.get(f"/api/v1/messages/{message_id}")
    assert response.status_code == 200
    assert response.json()["id"] == message_id

@pytest.mark.asyncio
async def test_get_nonexistent_message(async_client: AsyncClient, override_auth):
    message_id = "nonexistent-msg-id"
    response = await async_client.get(f"/api/v1/messages/{message_id}")
    assert response.status_code == 404


@pytest.mark.asyncio
async def test_import_valid_csv(async_client: AsyncClient, override_auth):
    csv_content = "phone\n+1234567890\n+1987654321"
    file = {"file": ("contacts.csv", csv_content, "text/csv")}
    params = {
        "message_template": "Test message",
        "delimiter": ",",
        "has_header": "true",
        "phone_column": "phone"
    }
    response = await async_client.post("/api/v1/messages/import", params=params, files=file)
    assert response.status_code == 202
    assert "task_id" in response.json()

@pytest.mark.asyncio
async def test_import_missing_column(async_client: AsyncClient, override_auth):
    csv_content = "name\nAlice\nBob"
    file = {"file": ("contacts.csv", csv_content, "text/csv")}
    params = {
        "message_template": "Hi",
        "delimiter": ",",
        "has_header": "true",
        "phone_column": "phone"
    }
    response = await async_client.post("/api/v1/messages/import", params=params, files=file)
    assert response.status_code == 422

@pytest.mark.asyncio
async def test_import_invalid_format(async_client: AsyncClient, override_auth):
    csv_content = "random|data|columns"
    file = {"file": ("contacts.csv", csv_content, "text/csv")}
    params = {
        "message_template": "Hi again",
        "delimiter": ",",
        "has_header": "true",
        "phone_column": "phone"
    }
    response = await async_client.post("/api/v1/messages/import", params=params, files=file)
    assert response.status_code == 422


@pytest.mark.asyncio
async def test_list_all_messages(async_client: AsyncClient, override_auth):
    response = await async_client.get("/api/v1/messages/")
    assert response.status_code == 200
    data = response.json()
    assert "items" in data
    assert isinstance(data["items"], list)
    assert "page_info" in data
    assert isinstance(data["page_info"], dict)

@pytest.mark.asyncio
async def test_filter_messages_by_status(async_client: AsyncClient, override_auth):
    response = await async_client.get("/api/v1/messages/?status=sent")
    assert response.status_code == 200
    data = response.json()
    assert "items" in data
    assert isinstance(data["items"], list)

@pytest.mark.asyncio
async def test_filter_messages_by_phone(async_client: AsyncClient, override_auth):
    response = await async_client.get("/api/v1/messages/?phone_number=+1234567890")
    assert response.status_code == 200
    data = response.json()
    assert "items" in data
    assert isinstance(data["items"], list)

@pytest.mark.asyncio
async def test_filter_messages_invalid_date(async_client: AsyncClient, override_auth):
    response = await async_client.get("/api/v1/messages/?from_date=invalid-date")
    assert response.status_code in [422, 500]

@pytest.mark.asyncio
async def test_send_valid_message(async_client: AsyncClient, override_auth):
    payload = {
        "phone_number": "+1234567890",
        "message": "Hello there!",
        "scheduled_at": None,
        "custom_id": "test-msg-123"
    }
    response = await async_client.post("/api/v1/messages/send", json=payload)
    assert response.status_code == 202
    assert "id" in response.json()

@pytest.mark.asyncio
async def test_send_invalid_phone(async_client: AsyncClient, override_auth):
    payload = {
        "phone_number": "invalid-phone",
        "message": "Hello there!",
        "scheduled_at": None,
        "custom_id": "test-msg-456"
    }
    response = await async_client.post("/api/v1/messages/send", json=payload)
    assert response.status_code == 422

@pytest.mark.asyncio
async def test_send_empty_message(async_client: AsyncClient, override_auth):
    payload = {
        "phone_number": "+1234567890",
        "message": "",
        "scheduled_at": None,
        "custom_id": "test-msg-789"
    }
    response = await async_client.post("/api/v1/messages/send", json=payload)
    assert response.status_code == 422

@pytest.mark.asyncio
async def test_get_existing_task_status(async_client: AsyncClient, override_auth):
    task_id = "existing-task-id"
    response = await async_client.get(f"/api/v1/messages/tasks/{task_id}")
    assert response.status_code == 200
    assert "status" in response.json()

@pytest.mark.asyncio
async def test_get_nonexistent_task_status(async_client: AsyncClient, override_auth):
    task_id = "nonexistent-task-id"
    response = await async_client.get(f"/api/v1/messages/tasks/{task_id}")
    assert response.status_code == 404

@pytest.mark.asyncio
async def test_update_valid_message_status(async_client: AsyncClient, override_auth):
    message_id = "existing-msg-id"
    payload = {
        "status": "delivered",
        "reason": "confirmed by carrier"
    }
    response = await async_client.put(f"/api/v1/messages/{message_id}/status", json=payload)
    assert response.status_code == 200
    assert response.json()["status"] == "delivered"

@pytest.mark.asyncio
async def test_update_status_message_not_found(async_client: AsyncClient, override_auth):
    message_id = "nonexistent-msg-id"
    payload = {
        "status": "failed",
        "reason": "user unreachable"
    }
    response = await async_client.put(f"/api/v1/messages/{message_id}/status", json=payload)
    assert response.status_code == 404

@pytest.mark.asyncio
async def test_update_status_invalid_value(async_client: AsyncClient, override_auth):
    message_id = "existing-msg-id"
    payload = {
        "status": "not_a_valid_status",
        "reason": "some reason"
    }
    response = await async_client.put(f"/api/v1/messages/{message_id}/status", json=payload)
    assert response.status_code == 422
</file>

<file path=".gitignore">
# Python specific
__pycache__/
*.py[cod]
*.pyo
*.pyd
*.env
*.venv
env/
venv/
ENV/
.venv/
env.bak/
venv.bak/
*.egg
*.egg-info/
dist/
build/
*.log

# FastAPI specific
instance/
*.db
*.sqlite3

# IDE specific
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db

# Test and coverage reports
htmlcov/
.tox/
.nox/
.coverage
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
</file>

<file path="alembic/README">
Generic single-database configuration.
</file>

<file path="alembic/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade schema."""
    ${downgrades if downgrades else "pass"}
</file>

<file path="app/api/v1/dependencies.py">
"""
Dependencies for API endpoints.
"""
from fastapi import Depends, HTTPException, status, Header
from fastapi.security import OAuth2PasswordBearer
from typing import Optional, List
import jwt
from datetime import datetime, timedelta, timezone

from app.core.config import settings
from app.core.exceptions import AuthenticationError, AuthorizationError
from app.schemas.user import User, TokenData, UserRole
from app.db.repositories.users import UserRepository
from app.services.rate_limiter import RateLimiter

# OAuth2 scheme for token authentication
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_PREFIX}/auth/token")


async def get_user_repository():
    """Get user repository."""
    from app.db.session import get_repository
    return await get_repository(UserRepository)


async def get_rate_limiter():
    """Get rate limiter service."""
    return RateLimiter()


async def get_current_user(
    token: str = Depends(oauth2_scheme),
    user_repository = Depends(get_user_repository)
) -> User:
    """
    Get the current authenticated user from the JWT token.
    
    Args:
        token: JWT token from Authorization header
        user_repository: User repository for database access
        
    Returns:
        User: The authenticated user
        
    Raises:
        AuthenticationError: If the token is invalid or expired
    """
    try:
        # Decode JWT token
        payload = jwt.decode(
            token, 
            settings.SECRET_KEY, 
            algorithms=["HS256"]
        )
        token_data = TokenData(**payload)
        
        # Check if token is expired
        if token_data.exp and datetime.now(timezone.utc) > token_data.exp:
            raise AuthenticationError("Token has expired")
        
        # Get user from database
        user = await user_repository.get_by_id(token_data.sub)
        if not user:
            raise AuthenticationError("User not found")
        
        # Check if user is active
        if not user.is_active:
            raise AuthenticationError("User is inactive")
        
        return user
        
    except jwt.PyJWTError:
        raise AuthenticationError("Invalid token")


async def verify_api_key(
    api_key: str = Header(..., alias=settings.API_KEY_HEADER),
    user_repository = Depends(get_user_repository)
) -> User:
    """
    Verify API key and return the associated user.
    
    Args:
        api_key: API key from header
        user_repository: User repository for database access
        
    Returns:
        User: The authenticated user
        
    Raises:
        AuthenticationError: If the API key is invalid
    """
    try:
        # Get API key from database
        api_key_record = await user_repository.get_api_key(api_key)
        if not api_key_record:
            raise AuthenticationError("Invalid API key")
        
        # Check if API key is active
        if not api_key_record.is_active:
            raise AuthenticationError("API key is inactive")
        
        # Check if API key is expired
        if api_key_record.expires_at and datetime.now(timezone.utc) > api_key_record.expires_at:
            raise AuthenticationError("API key has expired")
        
        # Get user associated with API key
        user = await user_repository.get_by_id(api_key_record.user_id)
        if not user:
            raise AuthenticationError("User not found")
        
        # Check if user is active
        if not user.is_active:
            raise AuthenticationError("User is inactive")
        
        # Update last used timestamp
        await user_repository.update_api_key_usage(api_key)
        
        return user
        
    except Exception as e:
        if isinstance(e, AuthenticationError):
            raise
        raise AuthenticationError("API key verification failed")


async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """
    Get the current active user.
    
    Args:
        current_user: Current authenticated user
        
    Returns:
        User: The authenticated active user
        
    Raises:
        AuthenticationError: If the user is inactive
    """
    if not current_user.is_active:
        raise AuthenticationError("Inactive user")
    return current_user


async def validate_permissions(
    required_permissions: List[str],
    current_user: User = Depends(get_current_user)
) -> None:
    """
    Validate that the current user has the required permissions.
    
    Args:
        required_permissions: List of required permissions
        current_user: Current authenticated user
        
    Raises:
        AuthorizationError: If the user doesn't have the required permissions
    """
    # Admin role has all permissions
    if current_user.role == UserRole.ADMIN:
        return
    
    # TODO: Implement proper permission checking
    # For now, just verify role-based access
    if current_user.role != UserRole.API and "api" in required_permissions:
        raise AuthorizationError("Insufficient permissions")
</file>

<file path="app/api/v1/endpoints/auth.py">
"""
API endpoints for authentication.
"""
from datetime import datetime, timedelta, timezone
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, status, Body
from fastapi.security import OAuth2PasswordRequestForm

from app.core.config import settings
from app.core.exceptions import AuthenticationError, AuthorizationError, NotFoundError
from app.api.v1.dependencies import (
    get_current_user,
    get_user_repository,
    validate_permissions
)
from app.schemas.user import (
    User,
    UserCreate,
    Token,
    APIKey,
    APIKeyCreate
)
from app.core.security import (
    create_access_token,
    verify_password,
    get_password_hash
)

router = APIRouter()


@router.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    user_repository = Depends(get_user_repository)
):
    """
    OAuth2 compatible token login, get an access token for future requests.
    """
    try:
        # Authenticate user
        user = await user_repository.get_by_email(form_data.username)
        if not user:
            raise AuthenticationError("Incorrect email or password")
        
        # Verify password
        if not verify_password(form_data.password, user.hashed_password):
            raise AuthenticationError("Incorrect email or password")
        
        # Check if user is active
        if not user.is_active:
            raise AuthenticationError("Inactive user")
        
        # Create access token
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        expires_at = datetime.now(timezone.utc) + access_token_expires
        
        access_token = create_access_token(
            data={
                "sub": str(user.id),
                "role": user.role,
                "exp": expires_at
            },
            expires_delta=access_token_expires
        )
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "expires_at": expires_at
        }
        
    except AuthenticationError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )


@router.post("/register", response_model=User, status_code=status.HTTP_201_CREATED)
async def register_user(
    user_data: UserCreate,
    user_repository = Depends(get_user_repository)
):
    """
    Register a new user.
    """
    # Check if user already exists
    existing_user = await user_repository.get_by_email(user_data.email)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email already registered"
        )
    
    # Create new user
    hashed_password = get_password_hash(user_data.password)
    
    user = await user_repository.create(
        email=user_data.email,
        hashed_password=hashed_password,
        full_name=user_data.full_name,
        is_active=user_data.is_active,
        role=user_data.role
    )
    
    return user


@router.get("/me", response_model=User)
async def read_users_me(
    current_user: User = Depends(get_current_user)
):
    """
    Get current user information.
    """
    return current_user


@router.post("/keys", response_model=APIKey)
async def create_api_key(
    api_key_data: APIKeyCreate,
    current_user: User = Depends(get_current_user),
    user_repository = Depends(get_user_repository)
):
    """
    Create a new API key.
    
    This is the only time the full API key will be returned.
    """
    # Create API key
    api_key = await user_repository.create_api_key(
        user_id=current_user.id,
        name=api_key_data.name,
        expires_at=api_key_data.expires_at,
        permissions=api_key_data.permissions
    )
    
    return api_key


@router.get("/keys", response_model=List[APIKey])
async def list_api_keys(
    current_user: User = Depends(get_current_user),
    user_repository = Depends(get_user_repository)
):
    """
    List all API keys for the current user.
    
    Note: The full API key value is not returned, only the ID and metadata.
    """
    # List API keys
    api_keys = await user_repository.list_api_keys(user_id=current_user.id)
    
    # Remove sensitive information
    for key in api_keys:
        key.key = f"{key.key[:8]}..." if key.key else None
    
    return api_keys


@router.delete("/keys/{key_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_api_key(
    key_id: str,
    current_user: User = Depends(get_current_user),
    user_repository = Depends(get_user_repository)
):
    """
    Delete an API key.
    """
    # Get API key
    api_key = await user_repository.get_api_key_by_id(key_id)
    if not api_key:
        raise NotFoundError(message="API key not found")
    
    # Check ownership
    if api_key.user_id != str(current_user.id) and current_user.role != "admin":
        raise AuthorizationError(message="Not authorized to delete this API key")
    
    # Delete API key
    success = await user_repository.delete_api_key(key_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete API key"
        )
    
    return None
</file>

<file path="app/api/v1/endpoints/messages.py">
"""
API endpoints for SMS message management.
"""
import csv
import io
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, UploadFile, File, Query, Path
from fastapi.responses import JSONResponse

from app.api.v1.dependencies import get_current_user, get_rate_limiter, verify_api_key
from app.core.exceptions import ValidationError, SMSGatewayError, NotFoundError
from app.schemas.message import (
    MessageCreate,
    MessageResponse, 
    BatchMessageRequest, 
    BatchMessageResponse,
    MessageStatus,
    MessageStatusUpdate
)
from app.services.sms.sender import get_sms_sender
from app.schemas.user import User
from app.utils.pagination import PaginationParams, paginate_response
from app.utils.pagination import PaginatedResponse

router = APIRouter()


@router.post("/send", response_model=MessageResponse, status_code=202)
async def send_message(
    message: MessageCreate,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Send a single SMS message.
    
    - **phone_number**: Recipient phone number in E.164 format (e.g., +1234567890)
    - **message**: Content of the SMS message
    - **scheduled_at**: Optional timestamp to schedule the message for future delivery
    """
    # Check rate limits
    await rate_limiter.check_rate_limit(current_user.id, "send_message")
    
    try:
        # Send message asynchronously
        result = await sms_sender.send_message(
            phone_number=message.phone_number,
            message_text=message.message,
            user_id=current_user.id,
            scheduled_at=message.scheduled_at,
            custom_id=message.custom_id,
        )
        
        return result
        
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except SMSGatewayError as e:
        raise HTTPException(status_code=502, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error sending message: {str(e)}")


@router.post("/batch", response_model=BatchMessageResponse, status_code=202)
async def send_batch(
    batch: BatchMessageRequest,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Send a batch of SMS messages.
    
    - **messages**: List of messages to send
    - **options**: Optional batch processing options
    """
    # Check rate limits - higher limit for batch operations
    await rate_limiter.check_rate_limit(current_user.id, "send_batch")
    
    if not batch.messages:
        raise ValidationError(message="Batch contains no messages")
    
    try:
        # Process batch asynchronously
        result = await sms_sender.send_batch(
            messages=batch.messages,
            user_id=current_user.id,
            options=batch.options,
        )
        
        return result
        
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except SMSGatewayError as e:
        raise HTTPException(status_code=502, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error processing batch: {str(e)}")


@router.post("/import", status_code=202)
async def import_messages(
    file: UploadFile = File(...),
    message_template: str = Query(..., description="Message template to send"),
    delimiter: str = Query(",", description="CSV delimiter"),
    has_header: bool = Query(True, description="Whether CSV has a header row"),
    phone_column: str = Query("phone", description="Column name containing phone numbers"),
    background_tasks: BackgroundTasks = None,
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
    rate_limiter = Depends(get_rate_limiter),
):
    """
    Import phone numbers from CSV and send messages.
    
    - **file**: CSV file with phone numbers
    - **message_template**: Template for the message to send
    - **delimiter**: CSV delimiter character
    - **has_header**: Whether the CSV has a header row
    - **phone_column**: Column name containing phone numbers (if has_header=True)
    """
    # Check rate limits
    await rate_limiter.check_rate_limit(current_user.id, "import_messages")
    
    try:
        # Read CSV file
        contents = await file.read()
        csv_file = io.StringIO(contents.decode('utf-8'))
        
        # Parse CSV
        csv_reader = csv.reader(csv_file, delimiter=delimiter)
        
        # Skip header if present
        if has_header:
            header = next(csv_reader)
            try:
                phone_index = header.index(phone_column)
            except ValueError:
                raise ValidationError(
                    message=f"Column '{phone_column}' not found in CSV header",
                    details={"available_columns": header}
                )
        else:
            phone_index = 0  # Assume first column has phone numbers
        
        # Extract phone numbers
        phone_numbers = []
        for row in csv_reader:
            if row and len(row) > phone_index:
                phone = row[phone_index].strip()
                if phone:
                    phone_numbers.append(phone)
        
        if not phone_numbers:
            raise ValidationError(message="No valid phone numbers found in CSV")
        
        # Process in background
        task_id = await sms_sender.schedule_batch_from_numbers(
            phone_numbers=phone_numbers,
            message_text=message_template,
            user_id=current_user.id,
        )
        
        return {
            "status": "accepted",
            "message": f"Processing {len(phone_numbers)} messages",
            "task_id": task_id,
        }
        
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error importing messages: {str(e)}")


@router.get("/{message_id}", response_model=MessageResponse)
async def get_message(
    message_id: str = Path(..., description="Message ID"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    Get details of a specific message.
    """
    try:
        message = await sms_sender.get_message(message_id, user_id=current_user.id)
        if not message:
            raise NotFoundError(message=f"Message {message_id} not found")
        return message
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving message: {str(e)}")


@router.get("/", response_model=PaginatedResponse[MessageResponse])
async def list_messages(
    pagination: PaginationParams = Depends(),
    status: Optional[str] = Query(None, description="Filter by message status"),
    phone_number: Optional[str] = Query(None, description="Filter by phone number"),
    from_date: Optional[str] = Query(None, description="Filter from date (ISO format)"),
    to_date: Optional[str] = Query(None, description="Filter to date (ISO format)"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    List messages with optional filtering.
    
    Returns a paginated list of messages for the current user.
    """
    try:
        filters = {
            "status": status,
            "phone_number": phone_number,
            "from_date": from_date,
            "to_date": to_date,
            "user_id": current_user.id
        }
        
        # Get messages with pagination
        messages, total = await sms_sender.list_messages(
            filters=filters,
            skip=pagination.skip,
            limit=pagination.limit
        )
        
        # Return paginated response
        return paginate_response(
            items=messages,
            total=total,
            pagination=pagination
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error listing messages: {str(e)}")


@router.put("/{message_id}/status", response_model=MessageResponse)
async def update_message_status(
    status_update: MessageStatusUpdate,
    message_id: str = Path(..., description="Message ID"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    Update the status of a message.
    
    This is primarily for administrative purposes or handling external status updates.
    """
    try:
        # Verify the user has permission to update this message
        message = await sms_sender.get_message(message_id, user_id=current_user.id)
        if not message:
            raise NotFoundError(message=f"Message {message_id} not found")
        
        # Update the status
        updated_message = await sms_sender.update_message_status(
            message_id=message_id,
            status=status_update.status,
            reason=status_update.reason,
            user_id=current_user.id
        )
        
        return updated_message
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error updating message status: {str(e)}")


@router.delete("/{message_id}", status_code=204)
async def delete_message(
    message_id: str = Path(..., description="Message ID"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    Delete a message.
    
    This will only remove it from the database, but cannot recall messages already sent.
    """
    try:
        # Verify the message exists and belongs to the user
        message = await sms_sender.get_message(message_id, user_id=current_user.id)
        if not message:
            raise NotFoundError(message=f"Message {message_id} not found")
        
        # Delete the message
        success = await sms_sender.delete_message(message_id, user_id=current_user.id)
        if not success:
            raise HTTPException(status_code=500, detail="Failed to delete message")
        
        return JSONResponse(status_code=204, content=None)
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error deleting message: {str(e)}")


@router.get("/tasks/{task_id}", response_model=dict)
async def get_task_status(
    task_id: str = Path(..., description="Task ID"),
    current_user: User = Depends(get_current_user),
    sms_sender = Depends(get_sms_sender),
):
    """
    Check the status of a background task.
    
    Used for tracking progress of batch operations and imports.
    """
    try:
        task_status = await sms_sender.get_task_status(task_id, user_id=current_user.id)
        if not task_status:
            raise NotFoundError(message=f"Task {task_id} not found")
        
        return task_status
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving task status: {str(e)}")
</file>

<file path="app/api/v1/endpoints/metrics.py">
"""
API endpoints for metrics and reporting.
"""
from fastapi import APIRouter, Depends, HTTPException

from app.api.v1.dependencies import get_current_user
from app.schemas.user import User

router = APIRouter()

@router.get("/")
async def get_metrics(
    current_user: User = Depends(get_current_user)
):
    """
    Get system metrics and statistics.
    """
    # This is a stub - implementation will be added later
    return {
        "message_count": {
            "total": 0,
            "sent": 0,
            "delivered": 0,
            "failed": 0
        },
        "user_count": 1,
        "webhook_count": 0
    }

@router.get("/usage")
async def get_usage_metrics(
    current_user: User = Depends(get_current_user)
):
    """
    Get usage metrics for the current user.
    """
    # This is a stub - implementation will be added later
    return {
        "message_count": 0,
        "quota": {
            "used": 0,
            "total": 1000
        }
    }
</file>

<file path="app/api/v1/endpoints/webhooks.py">
# app/api/v1/endpoints/webhooks.py
"""
API endpoints for webhook management.
"""
import logging
from typing import Dict, Any
from fastapi import APIRouter, Depends, HTTPException, Request, Body, Header, status

from app.api.v1.dependencies import get_current_user
from app.schemas.user import User
from app.services.webhooks.manager import process_gateway_webhook
from app.services.webhooks.manager import fetch_registered_webhooks_from_gateway


router = APIRouter()
logger = logging.getLogger("inboxerr.webhooks")

@router.get("/")
async def list_webhooks(
    current_user: User = Depends(get_current_user)
):
    """
    List all webhooks for the current user.
    """
    # This is a stub - implementation will be added later
    return {"message": "Webhook listing not implemented yet"}

@router.post("/gateway", status_code=status.HTTP_200_OK)
async def webhook_receiver(
    request: Request,
    x_signature: str = Header(None),
    x_timestamp: str = Header(None)
):
    """
    Receive webhooks from the SMS Gateway.
    
    This endpoint is called by the SMS Gateway when events occur.
    No authentication is required as we validate using signatures.
    """
    # Get raw body for signature validation
    body = await request.body()
    
    # Prepare headers for signature verification
    headers = {
        "X-Signature": x_signature,
        "X-Timestamp": x_timestamp
    }
    
    # Process the webhook
    success, result = await process_gateway_webhook(body, headers)
    
    if not success:
        logger.error(f"Error processing webhook: {result.get('error')}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=result.get('error', 'Error processing webhook')
        )
    
    return result

@router.get("/registered", tags=["Webhooks"])
async def get_registered_gateway_webhooks(current_user: User = Depends(get_current_user)):
    """
    Fetch registered webhooks from the external SMS Gateway.
    This helps confirm webhook registration status.
    """
    webhooks = await fetch_registered_webhooks_from_gateway()
    return {"registered_webhooks": webhooks}
</file>

<file path="app/core/events.py">
"""
Event handlers for application lifecycle events.
"""
import asyncio
import logging
from typing import Dict, List, Any

from app.core.config import settings
from app.services.event_bus.bus import get_event_bus
from app.services.event_bus.events import EventType

logger = logging.getLogger("inboxerr")

# Collection of background tasks to manage
background_tasks: List[asyncio.Task] = []


async def startup_event_handler() -> None:
    """
    Handle application startup.
    
    Initialize services, database connections, and start background processes.
    """
    logger.info("Starting Inboxerr Backend application")
    
    # Initialize database (async)
    try:
        # We'll implement this in the database module
        from app.db.session import initialize_database
        await initialize_database()
        logger.info("Database initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing database: {e}")
        # Don't raise error to allow startup to continue
    
    # Initialize event bus
    try:
        event_bus = get_event_bus()
        await event_bus.initialize()
        logger.info("Event bus initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing event bus: {e}")
    
    # Start retry engine if enabled
    if settings.RETRY_ENABLED:
        try:
            from app.services.sms.retry_engine import get_retry_engine
            retry_engine = await get_retry_engine()
            retry_task = asyncio.create_task(retry_engine.start())
            background_tasks.append(retry_task)
            logger.info("Retry engine started successfully")
        except Exception as e:
            logger.error(f"Error starting retry engine: {e}")
    
    # Start webhook listener if enabled
    try:
        from app.services.webhooks.manager import initialize_webhook_manager
        await initialize_webhook_manager()
        logger.info("Webhook manager initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing webhooks: {e}")
    
    # Initialize metrics collector
    try:
        from app.services.metrics.collector import initialize_metrics
        await initialize_metrics()
        logger.info("Metrics collector initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing metrics: {e}")
    
    # Log successful startup
    logger.info(f" {settings.PROJECT_NAME} v{settings.VERSION} startup complete")


async def shutdown_event_handler() -> None:
    """
    Handle application shutdown.
    
    Clean up resources and close connections properly.
    """
    logger.info("Shutting down Inboxerr Backend application")
    
    # Publish shutdown event
    try:
        event_bus = get_event_bus()
        await event_bus.publish(EventType.SYSTEM_SHUTDOWN, {
            "reason": "Application shutdown",
            "graceful": True
        })
        logger.info("Published shutdown event")
    except Exception as e:
        logger.error(f"Error publishing shutdown event: {e}")
    
    # Cancel all background tasks
    for task in background_tasks:
        if not task.done():
            task.cancel()
            try:
                # Wait briefly for task to cancel
                await asyncio.wait_for(task, timeout=5.0)
            except (asyncio.TimeoutError, asyncio.CancelledError):
                logger.warning(f"Task {task.get_name()} was cancelled")
    
    # Close database connections
    try:
        from app.db.session import close_database_connections
        await close_database_connections()
        logger.info("Database connections closed")
    except Exception as e:
        logger.error(f"Error closing database connections: {e}")
    
    # Shutdown webhook manager
    try:
        from app.services.webhooks.manager import shutdown_webhook_manager
        await shutdown_webhook_manager()
        logger.info("Webhook manager shutdown complete")
    except Exception as e:
        logger.error(f"Error shutting down webhook manager: {e}")
    
    logger.info(" Application shutdown complete")
</file>

<file path="app/core/security.py">
"""
Security utilities for authentication and authorization.
"""
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Optional, Union
import jwt
from passlib.context import CryptContext
import secrets
import string

from app.core.config import settings

# Password hashing context
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a password against a hash.
    
    Args:
        plain_password: Plain-text password
        hashed_password: Hashed password
        
    Returns:
        bool: True if password matches hash
    """
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """
    Hash a password.
    
    Args:
        password: Plain-text password
        
    Returns:
        str: Hashed password
    """
    return pwd_context.hash(password)


def create_access_token(
    data: Dict[str, Any],
    expires_delta: Optional[timedelta] = None
) -> str:
    """
    Create a JWT access token.
    
    Args:
        data: Data to encode in the token
        expires_delta: Token expiration time
        
    Returns:
        str: JWT token
    """
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    
    to_encode.update({"exp": expire})
    
    encoded_jwt = jwt.encode(
        to_encode,
        settings.SECRET_KEY,
        algorithm="HS256"
    )
    
    return encoded_jwt


def generate_api_key() -> str:
    """
    Generate a secure API key.
    
    Returns:
        str: API key
    """
    # Characters to use in API key
    alphabet = string.ascii_letters + string.digits
    
    # Generate a random string for the API key
    api_key = ''.join(secrets.choice(alphabet) for _ in range(32))
    
    # Add prefix for identification
    return f"ibx_{''.join(secrets.choice(alphabet) for _ in range(8))}_{api_key}"


def validate_api_key(api_key: str) -> bool:
    """
    Validate API key format.
    
    Args:
        api_key: API key to validate
        
    Returns:
        bool: True if format is valid
    """
    # Check format (prefix_random_key)
    parts = api_key.split('_')
    if len(parts) != 3:
        return False
    
    prefix, random_part, key = parts
    
    # Validate prefix
    if prefix != "ibx":
        return False
    
    # Validate random part length
    if len(random_part) != 8:
        return False
    
    # Validate key length
    if len(key) != 32:
        return False
    
    # Validate characters
    valid_chars = set(string.ascii_letters + string.digits)
    return all(c in valid_chars for c in random_part + key)


def generate_webhook_signing_key() -> str:
    """
    Generate a secure webhook signing key.
    
    Returns:
        str: Webhook signing key
    """
    # Generate a random string for the signing key
    return secrets.token_hex(32)  # 64 character hex string


def create_hmac_signature(payload: str, secret_key: str, timestamp: str) -> str:
    """
    Create HMAC signature for webhook payload validation.
    
    Args:
        payload: JSON payload as string
        secret_key: Secret key for signing
        timestamp: Timestamp string
        
    Returns:
        str: HMAC signature
    """
    import hmac
    import hashlib
    
    message = (payload + timestamp).encode()
    signature = hmac.new(
        secret_key.encode(),
        message,
        hashlib.sha256
    ).hexdigest()
    
    return signature


def verify_webhook_signature(
    payload: str,
    signature: str,
    secret_key: str,
    timestamp: str,
    tolerance: int = 300
) -> bool:
    """
    Verify webhook signature.
    
    Args:
        payload: JSON payload as string
        signature: Signature to verify
        secret_key: Secret key for signing
        timestamp: Timestamp used in signature
        tolerance: Timestamp tolerance in seconds
        
    Returns:
        bool: True if signature is valid
    """
    import hmac
    import time
    
    # Verify timestamp is within tolerance
    try:
        ts = int(timestamp)
        current_time = int(time.time())
        if abs(current_time - ts) > tolerance:
            return False
    except (ValueError, TypeError):
        return False
    
    # Calculate expected signature
    expected = create_hmac_signature(payload, secret_key, timestamp)
    
    # Compare signatures (constant-time comparison)
    return hmac.compare_digest(expected, signature)
</file>

<file path="app/db/base.py">
"""
Import all models here to ensure they are registered with SQLAlchemy.
"""
# Import Base
from app.models.base import Base

# Import all models
from app.models.user import User, APIKey
from app.models.campaign import Campaign
from app.models.message import Message, MessageEvent, MessageBatch, MessageTemplate
from app.models.webhook import Webhook, WebhookDelivery, WebhookEvent

# This allows alembic to auto-discover all models when creating migrations
</file>

<file path="app/db/repositories/campaigns.py">
# app/db/repositories/campaigns.py
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any, Tuple
from uuid import uuid4

from sqlalchemy import select, update, and_, or_, desc, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.db.repositories.base import BaseRepository
from app.models.campaign import Campaign
from app.models.message import Message


class CampaignRepository(BaseRepository[Campaign, Dict[str, Any], Dict[str, Any]]):
    """Campaign repository for campaign operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with session."""
        super().__init__(session=session, model=Campaign)
    
    async def create_campaign(
        self,
        *,
        name: str,
        user_id: str,
        description: Optional[str] = None,
        scheduled_start_at: Optional[datetime] = None,
        scheduled_end_at: Optional[datetime] = None,
        settings: Optional[Dict[str, Any]] = None
    ) -> Campaign:
        """
        Create a new campaign.
        
        Args:
            name: Campaign name
            user_id: User ID
            description: Optional campaign description
            scheduled_start_at: Optional scheduled start time
            scheduled_end_at: Optional scheduled end time
            settings: Optional campaign settings
            
        Returns:
            Campaign: Created campaign
        """
        campaign = Campaign(
            id=str(uuid4()),
            name=name,
            description=description,
            status="draft",
            user_id=user_id,
            scheduled_start_at=scheduled_start_at,
            scheduled_end_at=scheduled_end_at,
            settings=settings or {}
        )
        
        self.session.add(campaign)
        await self.session.commit()
        await self.session.refresh(campaign)
        
        return campaign
    
    async def update_campaign_status(
        self,
        *,
        campaign_id: str,
        status: str,
        started_at: Optional[datetime] = None,
        completed_at: Optional[datetime] = None
    ) -> Optional[Campaign]:
        """
        Update campaign status with proper transaction handling.
        
        Args:
            campaign_id: Campaign ID
            status: New status
            started_at: Optional start timestamp
            completed_at: Optional completion timestamp
            
        Returns:
            Campaign: Updated campaign or None
        """
        # Start a transaction
        async with self.session.begin():
            # Get campaign
            campaign = await self.get_by_id(campaign_id)
            if not campaign:
                return None
            
            old_status = campaign.status
            campaign.status = status
            
            if started_at:
                campaign.started_at = started_at
            
            if completed_at:
                campaign.completed_at = completed_at
            
            # If status is active and no start time, set it now
            if status == "active" and not campaign.started_at:
                campaign.started_at = datetime.now(timezone.utc)
            
            # If status is completed and no completion time, set it now
            if status in ["completed", "cancelled", "failed"] and not campaign.completed_at:
                campaign.completed_at = datetime.now(timezone.utc)
            
            # Add campaign to session
            self.session.add(campaign)
            
            # If transitioning from draft to active, also update any pending messages
            # that are associated with this campaign
            if old_status == "draft" and status == "active":
                from app.models.message import Message
                from app.schemas.message import MessageStatus
                
                # Update messages
                query = update(Message).where(
                    and_(
                        Message.campaign_id == campaign_id,
                        Message.status == MessageStatus.PENDING,
                        or_(
                            Message.scheduled_at.is_(None),
                            Message.scheduled_at <= datetime.now(timezone.utc)
                        )
                    )
                ).values(
                    status=MessageStatus.PROCESSED
                )
                
                await self.session.execute(query)
            
            # Publish event about status change
            from app.services.event_bus.bus import get_event_bus
            from app.services.event_bus.events import EventType
            
            event_bus = get_event_bus()
            event_type = None
            
            if status == "active":
                event_type = EventType.CAMPAIGN_STARTED
            elif status == "paused":
                event_type = EventType.CAMPAIGN_PAUSED
            elif status == "completed":
                event_type = EventType.CAMPAIGN_COMPLETED
            elif status == "cancelled":
                event_type = EventType.CAMPAIGN_CANCELLED
            elif status == "failed":
                event_type = EventType.CAMPAIGN_FAILED
                
            if event_type:
                await event_bus.publish(
                    event_type,
                    {
                        "campaign_id": campaign_id,
                        "previous_status": old_status,
                        "new_status": status,
                        "timestamp": datetime.now(timezone.utc).isoformat()
                    }
                )
            
            # No explicit commit needed - will be committed at the end of the context manager
            await self.session.refresh(campaign)
            
            return campaign

    async def update_campaign_stats(
        self,
        *,
        campaign_id: str,
        increment_sent: int = 0,
        increment_delivered: int = 0,
        increment_failed: int = 0
    ) -> Optional[Campaign]:
        """
        Update campaign statistics.
        
        Args:
            campaign_id: Campaign ID
            increment_sent: Increment sent count
            increment_delivered: Increment delivered count
            increment_failed: Increment failed count
            
        Returns:
            Campaign: Updated campaign or None
        """
        campaign = await self.get_by_id(campaign_id)
        if not campaign:
            return None
        
        # Update counts
        campaign.sent_count += increment_sent
        campaign.delivered_count += increment_delivered
        campaign.failed_count += increment_failed
        
        # Check if campaign is complete
        total_processed = campaign.sent_count + campaign.failed_count
        if total_processed >= campaign.total_messages and campaign.total_messages > 0:
            campaign.status = "completed"
            campaign.completed_at = datetime.now(timezone.utc)
        
        self.session.add(campaign)
        await self.session.commit()
        await self.session.refresh(campaign)
        
        return campaign
    
    async def get_campaigns_for_user(
        self,
        *,
        user_id: str,
        status: Optional[str] = None,
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Campaign], int]:
        """
        Get campaigns for a user with optional filtering.
        
        Args:
            user_id: User ID
            status: Optional status filter
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Campaign], int]: List of campaigns and total count
        """
        # Base query
        query = select(Campaign).where(Campaign.user_id == user_id)
        count_query = select(func.count()).select_from(Campaign).where(Campaign.user_id == user_id)
        
        # Apply status filter
        if status:
            query = query.where(Campaign.status == status)
            count_query = count_query.where(Campaign.status == status)
        
        # Order by created_at desc
        query = query.order_by(desc(Campaign.created_at))
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await self.session.execute(query)
        count_result = await self.session.execute(count_query)
        
        campaigns = result.scalars().all()
        total = count_result.scalar_one()
        
        return campaigns, total
    
    async def add_messages_to_campaign(
        self,
        *,
        campaign_id: str,
        phone_numbers: List[str],
        message_text: str,
        user_id: str
    ) -> int:
        """
        Add messages to a campaign.
        
        Args:
            campaign_id: Campaign ID
            phone_numbers: List of recipient phone numbers
            message_text: Message content
            user_id: User ID
            
        Returns:
            int: Number of messages added
        """
        from app.db.repositories.messages import MessageRepository
        from app.utils.phone import validate_phone
        
        # Get campaign
        campaign = await self.get_by_id(campaign_id)
        if not campaign:
            return 0
        
        # Validate campaign belongs to user
        if campaign.user_id != user_id:
            return 0
        
        # TODO: Implement bulk insertion for better performance
        message_repo = MessageRepository(self.session)
        added_count = 0
        
        for phone in phone_numbers:
            # Basic validation
            is_valid, formatted_number, error, _ = validate_phone(phone)
            if is_valid:
                # Add message to campaign
                await message_repo.create_message(
                    phone_number=formatted_number,
                    message_text=message_text,
                    user_id=user_id,
                    scheduled_at=campaign.scheduled_start_at,
                    metadata={"campaign_id": campaign_id},
                    campaign_id=campaign_id  # Direct link to campaign
                )
                added_count += 1
        
        # Update campaign message count
        if added_count > 0:
            campaign.total_messages += added_count
            self.session.add(campaign)
            await self.session.commit()
        
        return added_count
</file>

<file path="app/db/repositories/users.py">
"""
User repository for database operations related to users.
"""
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import uuid4

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.security import get_password_hash, generate_api_key
from app.db.repositories.base import BaseRepository
from app.models.user import User, APIKey
from app.schemas.user import UserCreate, UserUpdate


class UserRepository(BaseRepository[User, UserCreate, UserUpdate]):
    """User repository for database operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize with session and User model."""
        super().__init__(session=session, model=User)
    
    async def get_by_email(self, email: str) -> Optional[User]:
        """
        Get a user by email.
        
        Args:
            email: User email
            
        Returns:
            User: Found user or None
        """
        return await self.get_by_attribute("email", email)
    
    async def create(
        self, 
        *,
        email: str,
        hashed_password: str,
        full_name: Optional[str] = None,
        is_active: bool = True,
        role: str = "user"
    ) -> User:
        """
        Create a new user.
        
        Args:
            email: User email
            hashed_password: Hashed password
            full_name: User's full name
            is_active: Whether the user is active
            role: User role
            
        Returns:
            User: Created user
        """
        db_obj = User(
            email=email,
            hashed_password=hashed_password,
            full_name=full_name,
            is_active=is_active,
            role=role
        )
        
        self.session.add(db_obj)
        await self.session.commit()
        await self.session.refresh(db_obj)
        
        return db_obj
    
    async def update_password(self, *, user_id: str, new_password: str) -> Optional[User]:
        """
        Update user password.
        
        Args:
            user_id: User ID
            new_password: New password (plain text)
            
        Returns:
            User: Updated user or None
        """
        # Hash the new password
        hashed_password = get_password_hash(new_password)
        
        # Update the user
        return await self.update(
            id=user_id,
            obj_in={"hashed_password": hashed_password}
        )
    
    async def create_api_key(
        self, 
        *,
        user_id: str,
        name: str,
        expires_at: Optional[datetime] = None,
        permissions: List[str] = None
    ) -> APIKey:
        """
        Create a new API key for a user.
        
        Args:
            user_id: User ID
            name: API key name
            expires_at: Expiration timestamp
            permissions: List of permissions
            
        Returns:
            APIKey: Created API key
        """
        # Generate API key
        key_value = generate_api_key()
        
        # Create API key
        api_key = APIKey(
            id=str(uuid4()),
            key=key_value,
            name=name,
            user_id=user_id,
            expires_at=expires_at,
            is_active=True,
            permissions=permissions or []
        )
        
        self.session.add(api_key)
        await self.session.commit()
        await self.session.refresh(api_key)
        
        return api_key
    
    async def get_api_key(self, key: str) -> Optional[APIKey]:
        """
        Get an API key by its value.
        
        Args:
            key: API key value
            
        Returns:
            APIKey: Found API key or None
        """
        query = select(APIKey).where(APIKey.key == key, APIKey.is_active == True)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_api_key_by_id(self, key_id: str) -> Optional[APIKey]:
        """
        Get an API key by its ID.
        
        Args:
            key_id: API key ID
            
        Returns:
            APIKey: Found API key or None
        """
        query = select(APIKey).where(APIKey.id == key_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def list_api_keys(self, user_id: str) -> List[APIKey]:
        """
        List all API keys for a user.
        
        Args:
            user_id: User ID
            
        Returns:
            List[APIKey]: List of API keys
        """
        query = select(APIKey).where(APIKey.user_id == user_id)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update_api_key_usage(self, key: str) -> bool:
        """
        Update the last_used_at timestamp for an API key.
        
        Args:
            key: API key value
            
        Returns:
            bool: True if updated, False if not found
        """
        query = update(APIKey).where(
            APIKey.key == key, 
            APIKey.is_active == True
        ).values(
            last_used_at=datetime.now(timezone.utc)
        )
        
        result = await self.session.execute(query)
        await self.session.commit()
        
        return result.rowcount > 0
    
    async def delete_api_key(self, key_id: str) -> bool:
        """
        Delete an API key.
        
        Args:
            key_id: API key ID
            
        Returns:
            bool: True if deleted, False if not found
        """
        api_key = await self.get_api_key_by_id(key_id)
        if not api_key:
            return False
            
        await self.session.delete(api_key)
        await self.session.commit()
        
        return True
    
    async def deactivate_api_key(self, key_id: str) -> bool:
        """
        Deactivate an API key without deleting it.
        
        Args:
            key_id: API key ID
            
        Returns:
            bool: True if deactivated, False if not found
        """
        api_key = await self.get_api_key_by_id(key_id)
        if not api_key:
            return False
            
        api_key.is_active = False
        self.session.add(api_key)
        await self.session.commit()
        
        return True
</file>

<file path="app/db/repositories/webhooks.py">
"""
Webhook repository for database operations related to webhooks.
"""
from datetime import datetime, timedelta, timezone
from typing import List, Optional, Dict, Any, Tuple
from uuid import uuid4

from sqlalchemy import select, update, delete, and_, or_, desc, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.db.repositories.base import BaseRepository
from app.models.webhook import Webhook, WebhookDelivery, WebhookEvent
from app.core.security import generate_webhook_signing_key


class WebhookRepository(BaseRepository[Webhook, Dict[str, Any], Dict[str, Any]]):
    """Webhook repository for database operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize with session and Webhook model."""
        super().__init__(session=session, model=Webhook)
    
    async def create_webhook(
        self,
        *,
        name: str,
        url: str,
        event_types: List[str],
        user_id: str,
        secret_key: Optional[str] = None,
        gateway_webhook_id: Optional[str] = None
    ) -> Webhook:
        """
        Create a new webhook.
        
        Args:
            name: Webhook name
            url: Webhook URL
            event_types: List of event types to receive
            user_id: User ID
            secret_key: Optional secret key for signature validation
            gateway_webhook_id: Optional gateway webhook ID
            
        Returns:
            Webhook: Created webhook
        """
        # Generate secret key if not provided
        if not secret_key:
            secret_key = generate_webhook_signing_key()
        
        webhook = Webhook(
            id=str(uuid4()),
            name=name,
            url=url,
            event_types=event_types,
            user_id=user_id,
            secret_key=secret_key,
            gateway_webhook_id=gateway_webhook_id,
            is_active=True
        )
        
        self.session.add(webhook)
        await self.session.commit()
        await self.session.refresh(webhook)
        
        return webhook
    
    async def get_webhooks_for_event(
        self,
        *,
        event_type: str,
        user_id: Optional[str] = None
    ) -> List[Webhook]:
        """
        Get webhooks for a specific event type.
        
        Args:
            event_type: Event type
            user_id: Optional user ID to filter webhooks
            
        Returns:
            List[Webhook]: List of matching webhooks
        """
        query = select(Webhook).where(
            and_(
                Webhook.is_active == True,
                Webhook.event_types.contains([event_type])
            )
        )
        
        if user_id:
            query = query.where(Webhook.user_id == user_id)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def create_webhook_delivery(
        self,
        *,
        webhook_id: str,
        event_type: str,
        message_id: Optional[str],
        payload: Dict[str, Any],
        status_code: Optional[int] = None,
        is_success: bool = False,
        error_message: Optional[str] = None,
        retry_count: int = 0
    ) -> WebhookDelivery:
        """
        Record a webhook delivery attempt.
        
        Args:
            webhook_id: Webhook ID
            event_type: Event type
            message_id: Message ID (if applicable)
            payload: Webhook payload
            status_code: HTTP status code
            is_success: Whether delivery was successful
            error_message: Error message if failed
            retry_count: Number of retry attempts
            
        Returns:
            WebhookDelivery: Created webhook delivery record
        """
        delivery = WebhookDelivery(
            id=str(uuid4()),
            webhook_id=webhook_id,
            event_type=event_type,
            message_id=message_id,
            payload=payload,
            status_code=status_code,
            is_success=is_success,
            error_message=error_message,
            retry_count=retry_count
        )
        
        if not is_success and retry_count < 3:  # Configure max retries
            # Schedule next retry with exponential backoff
            backoff = 5 * (2 ** retry_count)  # 5, 10, 20 minutes
            delivery.next_retry_at = datetime.now(timezone.utc) + timedelta(minutes=backoff)
        
        self.session.add(delivery)
        await self.session.commit()
        await self.session.refresh(delivery)
        
        # Update webhook stats
        await self._update_webhook_stats(
            webhook_id=webhook_id,
            is_success=is_success,
            last_triggered=datetime.now(timezone.utc)
        )
        
        return delivery
    
    async def _update_webhook_stats(
        self,
        *,
        webhook_id: str,
        is_success: bool,
        last_triggered: datetime
    ) -> None:
        """
        Update webhook statistics.
        
        Args:
            webhook_id: Webhook ID
            is_success: Whether delivery was successful
            last_triggered: Timestamp of delivery attempt
        """
        webhook = await self.get_by_id(webhook_id)
        if not webhook:
            return
        
        webhook.last_triggered_at = last_triggered
        
        if is_success:
            webhook.success_count += 1
        else:
            webhook.failure_count += 1
        
        self.session.add(webhook)
        await self.session.commit()
    
    async def get_pending_retries(
        self,
        *,
        limit: int = 10
    ) -> List[WebhookDelivery]:
        """
        Get webhook deliveries pending retry.
        
        Args:
            limit: Maximum number of deliveries to return
            
        Returns:
            List[WebhookDelivery]: List of deliveries pending retry
        """
        now = datetime.now(timezone.utc)
        
        query = select(WebhookDelivery).where(
            and_(
                WebhookDelivery.is_success == False,
                WebhookDelivery.next_retry_at <= now,
                WebhookDelivery.next_retry_at.is_not(None),
                WebhookDelivery.retry_count < 3  # Configure max retries
            )
        ).order_by(WebhookDelivery.next_retry_at).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update_delivery_status(
        self,
        *,
        delivery_id: str,
        status_code: int,
        is_success: bool,
        error_message: Optional[str] = None,
        increment_retry: bool = False
    ) -> Optional[WebhookDelivery]:
        """
        Update webhook delivery status.
        
        Args:
            delivery_id: Delivery ID
            status_code: HTTP status code
            is_success: Whether delivery was successful
            error_message: Error message if failed
            increment_retry: Whether to increment retry count
            
        Returns:
            WebhookDelivery: Updated delivery record or None
        """
        delivery = await self.session.get(WebhookDelivery, delivery_id)
        if not delivery:
            return None
        
        delivery.status_code = status_code
        delivery.is_success = is_success
        delivery.error_message = error_message
        
        if increment_retry:
            delivery.retry_count += 1
        
        if not is_success and delivery.retry_count < 3:  # Configure max retries
            # Schedule next retry with exponential backoff
            backoff = 5 * (2 ** delivery.retry_count)  # 5, 10, 20 minutes
            delivery.next_retry_at = datetime.now(timezone.utc) + timedelta(minutes=backoff)
        else:
            delivery.next_retry_at = None
        
        self.session.add(delivery)
        await self.session.commit()
        await self.session.refresh(delivery)
        
        # Update webhook stats
        await self._update_webhook_stats(
            webhook_id=delivery.webhook_id,
            is_success=is_success,
            last_triggered=datetime.now(timezone.utc)
        )
        
        return delivery
    
    async def create_webhook_event(
        self,
        *,
        event_type: str,
        payload: Dict[str, Any],
        phone_number: Optional[str] = None,
        message_id: Optional[str] = None,
        gateway_message_id: Optional[str] = None
    ) -> WebhookEvent:
        """
        Record a webhook event received from SMS gateway.
        
        Args:
            event_type: Event type
            payload: Event payload
            phone_number: Phone number
            message_id: Message ID
            gateway_message_id: Gateway message ID
            
        Returns:
            WebhookEvent: Created webhook event
        """
        event = WebhookEvent(
            id=str(uuid4()),
            event_type=event_type,
            phone_number=phone_number,
            message_id=message_id,
            gateway_message_id=gateway_message_id,
            payload=payload,
            processed=False
        )
        
        self.session.add(event)
        await self.session.commit()
        await self.session.refresh(event)
        
        return event
    
    async def mark_event_processed(
        self,
        *,
        event_id: str,
        error_message: Optional[str] = None
    ) -> Optional[WebhookEvent]:
        """
        Mark a webhook event as processed.
        
        Args:
            event_id: Event ID
            error_message: Optional error message
            
        Returns:
            WebhookEvent: Updated event or None
        """
        event = await self.session.get(WebhookEvent, event_id)
        if not event:
            return None
        
        event.processed = True
        event.error_message = error_message
        
        self.session.add(event)
        await self.session.commit()
        await self.session.refresh(event)
        
        return event
    
    async def get_unprocessed_events(
        self,
        *,
        limit: int = 10
    ) -> List[WebhookEvent]:
        """
        Get unprocessed webhook events.
        
        Args:
            limit: Maximum number of events to return
            
        Returns:
            List[WebhookEvent]: List of unprocessed events
        """
        query = select(WebhookEvent).where(
            WebhookEvent.processed == False
        ).order_by(WebhookEvent.created_at).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
</file>

<file path="app/models/base.py">
"""
Base database model with common fields and methods.
"""
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, Optional

from sqlalchemy import Column, DateTime, String
from sqlalchemy.ext.declarative import as_declarative, declared_attr


@as_declarative()
class Base:
    """Base class for all database models."""
    
    # Generate __tablename__ automatically from class name
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower()
    
    # Common columns for all models
    id = Column(String, primary_key=True, index=True, default=lambda: str(uuid.uuid4()))
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    updated_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc), nullable=False)
    
    def dict(self) -> Dict[str, Any]:
        """Convert model to dictionary."""
        return {c.name: getattr(self, c.name) for c in self.__table__.columns}
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Base":
        """Create model instance from dictionary."""
        return cls(**{
            k: v for k, v in data.items() 
            if k in [c.name for c in cls.__table__.columns]
        })
</file>

<file path="app/models/campaign.py">
# app/models/campaign.py
from datetime import datetime, timezone
from typing import List, Optional

from sqlalchemy import Column, String, DateTime, Boolean, JSON, Integer, ForeignKey, Text
from sqlalchemy.orm import relationship

from app.models.base import Base


class Campaign(Base):
    """Campaign model for bulk SMS messaging."""
    
    # Basic campaign information
    name = Column(String, nullable=False, index=True)
    description = Column(Text, nullable=True)
    
    # Campaign status
    status = Column(String, nullable=False, default="draft", index=True)  # draft, active, paused, completed, cancelled, failed
    
    # Campaign statistics
    total_messages = Column(Integer, default=0, nullable=False)
    sent_count = Column(Integer, default=0, nullable=False)
    delivered_count = Column(Integer, default=0, nullable=False)
    failed_count = Column(Integer, default=0, nullable=False)
    
    # Campaign configuration
    scheduled_start_at = Column(DateTime(timezone=True), nullable=True, index=True)
    scheduled_end_at = Column(DateTime(timezone=True), nullable=True)
    started_at = Column(DateTime(timezone=True), nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    # Campaign settings
    settings = Column(JSON, nullable=True, default=dict)  # Store campaign-specific settings
    
    # Ownership
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    
    # Relationships
    user = relationship("User")
    messages = relationship("Message", back_populates="campaign")
    
    # Helper properties
    @property
    def progress_percentage(self) -> float:
        """Calculate the campaign progress percentage."""
        if self.total_messages == 0:
            return 0
        return round((self.sent_count / self.total_messages) * 100, 2)
    
    @property
    def delivery_success_rate(self) -> float:
        """Calculate the delivery success rate."""
        if self.sent_count == 0:
            return 0
        return round((self.delivered_count / self.sent_count) * 100, 2)
</file>

<file path="app/models/user.py">
"""
Database models for user management.
"""
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any

from sqlalchemy import Boolean, Column, String, DateTime, JSON, ForeignKey
from sqlalchemy.orm import relationship

from app.models.base import Base


class User(Base):
    """User model for authentication and authorization."""
    
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    role = Column(String, default="user", nullable=False)
    
    # Relationships
    api_keys = relationship("APIKey", back_populates="user", cascade="all, delete-orphan")
    messages = relationship("Message", back_populates="user", cascade="all, delete-orphan")


class APIKey(Base):
    """API key model for API authentication."""
    
    key = Column(String, unique=True, index=True, nullable=False)
    name = Column(String, nullable=False)
    user_id = Column(String, ForeignKey("user.id"), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    last_used_at = Column(DateTime(timezone=True), nullable=True)
    permissions = Column(JSON, default=list, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="api_keys")
</file>

<file path="app/models/webhook.py">
"""
Database models for webhook management.
"""
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any

from sqlalchemy import Column, String, DateTime, Boolean, JSON, Integer, ForeignKey, Text
from sqlalchemy.orm import relationship

from app.models.base import Base


class Webhook(Base):
    """Webhook configuration model."""
    
    # Webhook configuration
    name = Column(String, nullable=False)
    url = Column(String, nullable=False)
    event_types = Column(JSON, nullable=False)  # List of event types to send
    is_active = Column(Boolean, default=True, nullable=False)
    secret_key = Column(String, nullable=True)  # For signature validation
    
    # Ownership and association
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    gateway_webhook_id = Column(String, nullable=True)  # ID from SMS gateway
    
    # Stats
    last_triggered_at = Column(DateTime(timezone=True), nullable=True)
    success_count = Column(Integer, default=0, nullable=False)
    failure_count = Column(Integer, default=0, nullable=False)
    
    # Relationships
    user = relationship("User")
    deliveries = relationship("WebhookDelivery", back_populates="webhook", cascade="all, delete-orphan")


class WebhookDelivery(Base):
    """Model for tracking webhook delivery attempts."""
    
    webhook_id = Column(String, ForeignKey("webhook.id"), nullable=False, index=True)
    event_type = Column(String, nullable=False, index=True)
    message_id = Column(String, ForeignKey("message.id"), nullable=True, index=True)
    payload = Column(JSON, nullable=False)
    status_code = Column(Integer, nullable=True)
    is_success = Column(Boolean, nullable=False)
    error_message = Column(String, nullable=True)
    retry_count = Column(Integer, default=0, nullable=False)
    next_retry_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    webhook = relationship("Webhook", back_populates="deliveries")
    message = relationship("Message")


class WebhookEvent(Base):
    """Model for tracking webhook events received from SMS gateway."""
    
    event_type = Column(String, nullable=False, index=True)
    phone_number = Column(String, nullable=True, index=True)
    message_id = Column(String, nullable=True, index=True)
    gateway_message_id = Column(String, nullable=True, index=True)
    payload = Column(JSON, nullable=False)
    processed = Column(Boolean, default=False, nullable=False)
    error_message = Column(String, nullable=True)
</file>

<file path="app/services/campaigns/processor.py">
# app/services/campaigns/processor.py
import asyncio
import logging
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional
import uuid

from app.core.config import settings
from app.db.repositories.campaigns import CampaignRepository
from app.db.repositories.messages import MessageRepository
from app.schemas.message import MessageStatus
from app.services.event_bus.bus import get_event_bus
from app.services.event_bus.events import EventType
from app.services.sms.sender import SMSSender

logger = logging.getLogger("inboxerr.campaigns")

class CampaignProcessor:
    """
    Service for processing SMS campaigns.
    
    Manages campaign execution, chunked processing, and status tracking.
    """
    
    def __init__(
        self,
        campaign_repository: CampaignRepository,
        message_repository: MessageRepository,
        sms_sender: SMSSender,
        event_bus: Any
    ):
        """Initialize campaign processor with required dependencies."""
        self.campaign_repository = campaign_repository
        self.message_repository = message_repository
        self.sms_sender = sms_sender
        self.event_bus = event_bus
        self._processing_campaigns = set()
        self._chunk_size = settings.BATCH_SIZE  # Default from settings
        self._semaphore = asyncio.Semaphore(5)  # Limit concurrent campaigns
    
    async def start_campaign(self, campaign_id: str, user_id: str) -> bool:
        """
        Start a campaign.
        
        Args:
            campaign_id: Campaign ID
            user_id: User ID for authorization
            
        Returns:
            bool: True if campaign was started, False otherwise
        """
        # Get campaign
        campaign = await self.campaign_repository.get_by_id(campaign_id)
        if not campaign:
            return False
        
        # Validate ownership
        if campaign.user_id != user_id:
            return False
        
        # Check if campaign can be started
        if campaign.status != "draft" and campaign.status != "paused":
            return False
        
        # Update status to active
        updated = await self.campaign_repository.update_campaign_status(
            campaign_id=campaign_id,
            status="active",
            started_at=datetime.now(timezone.utc)
        )
        
        if not updated:
            return False
        
        # Start processing in background
        asyncio.create_task(self._process_campaign(campaign_id))
        
        # Publish event
        await self.event_bus.publish(
            EventType.BATCH_CREATED,
            {
                "campaign_id": campaign_id,
                "user_id": user_id,
                "total_messages": campaign.total_messages
            }
        )
        
        return True
    
    async def pause_campaign(self, campaign_id: str, user_id: str) -> bool:
        """
        Pause a campaign.
        
        Args:
            campaign_id: Campaign ID
            user_id: User ID for authorization
            
        Returns:
            bool: True if campaign was paused, False otherwise
        """
        # Get campaign
        campaign = await self.campaign_repository.get_by_id(campaign_id)
        if not campaign:
            return False
        
        # Validate ownership
        if campaign.user_id != user_id:
            return False
        
        # Check if campaign can be paused
        if campaign.status != "active":
            return False
        
        # Update status to paused
        updated = await self.campaign_repository.update_campaign_status(
            campaign_id=campaign_id,
            status="paused"
        )
        
        return updated is not None
    
    async def cancel_campaign(self, campaign_id: str, user_id: str) -> bool:
        """
        Cancel a campaign.
        
        Args:
            campaign_id: Campaign ID
            user_id: User ID for authorization
            
        Returns:
            bool: True if campaign was cancelled, False otherwise
        """
        # Get campaign
        campaign = await self.campaign_repository.get_by_id(campaign_id)
        if not campaign:
            return False
        
        # Validate ownership
        if campaign.user_id != user_id:
            return False
        
        # Check if campaign can be cancelled
        if campaign.status in ["completed", "cancelled", "failed"]:
            return False
        
        # Update status to cancelled
        updated = await self.campaign_repository.update_campaign_status(
            campaign_id=campaign_id,
            status="cancelled",
            completed_at=datetime.now(timezone.utc)
        )
        
        return updated is not None
    
    async def _process_campaign(self, campaign_id: str) -> None:
        """
        Process a campaign in the background.
        
        Args:
            campaign_id: Campaign ID
        """
        if campaign_id in self._processing_campaigns:
            logger.warning(f"Campaign {campaign_id} is already being processed")
            return
        
        # Mark as processing
        self._processing_campaigns.add(campaign_id)
        
        try:
            # Get campaign
            campaign = await self.campaign_repository.get_by_id(campaign_id)
            if not campaign or campaign.status != "active":
                return
            
            # Process in chunks until complete
            async with self._semaphore:
                await self._process_campaign_chunks(campaign)
                
        except Exception as e:
            logger.error(f"Error processing campaign {campaign_id}: {e}", exc_info=True)
            # Update campaign status to failed
            await self.campaign_repository.update_campaign_status(
                campaign_id=campaign_id,
                status="failed",
                completed_at=datetime.now(timezone.utc)
            )
        finally:
            # Remove from processing set
            self._processing_campaigns.remove(campaign_id)
    
    async def _process_campaign_chunks(self, campaign) -> None:
        """
        Process campaign messages in chunks.
        
        Args:
            campaign: Campaign object
        """
        # Query pending messages in chunks
        offset = 0
        
        while True:
            # Check if campaign is still active
            campaign = await self.campaign_repository.get_by_id(campaign.id)
            if not campaign or campaign.status != "active":
                logger.info(f"Campaign {campaign.id} is no longer active, stopping processing")
                return
            
            # Get next chunk of messages
            messages, _ = await self.message_repository.get_messages_for_campaign(
                campaign_id=campaign.id,
                status=MessageStatus.PENDING,
                skip=offset,
                limit=self._chunk_size
            )
            
            # If no more messages, campaign is complete
            if not messages:
                logger.info(f"No more pending messages for campaign {campaign.id}")
                await self.campaign_repository.update_campaign_status(
                    campaign_id=campaign.id,
                    status="completed",
                    completed_at=datetime.now(timezone.utc)
                )
                return
            
            # Process this chunk
            await self._process_message_chunk(campaign.id, messages)
            
            # Update offset for next chunk
            offset += len(messages)
            
            # Small delay between chunks to avoid overloading
            await asyncio.sleep(0.5)
    
    async def _process_message_chunk(self, campaign_id: str, messages: List[Any]) -> None:
        """
        Process a chunk of messages.
        
        Args:
            campaign_id: Campaign ID
            messages: List of message objects
        """
        # Process each message in the chunk
        success_count = 0
        fail_count = 0
        
        for message in messages:
            try:
                # Use SMS sender to send the message
                # Note: This is not optimal for bulk processing and would be improved in future versions
                result = await self.sms_sender._send_to_gateway(
                    phone_number=message.phone_number,
                    message_text=message.message,
                    custom_id=message.custom_id or str(uuid.uuid4())
                )
                
                # Update message status
                await self.message_repository.update_message_status(
                    message_id=message.id,
                    status=result.get("status", MessageStatus.PENDING),
                    event_type="campaign_process",
                    gateway_message_id=result.get("gateway_message_id"),
                    data=result
                )
                
                success_count += 1
                
                # Add delay between messages to avoid overloading gateway
                await asyncio.sleep(settings.DELAY_BETWEEN_SMS)
                
            except Exception as e:
                logger.error(f"Error processing message {message.id}: {e}")
                
                # Update message status to failed
                await self.message_repository.update_message_status(
                    message_id=message.id,
                    status=MessageStatus.FAILED,
                    event_type="campaign_process_error",
                    reason=str(e),
                    data={"error": str(e)}
                )
                
                fail_count += 1
        
        # Update campaign stats
        await self.campaign_repository.update_campaign_stats(
            campaign_id=campaign_id,
            increment_sent=success_count,
            increment_failed=fail_count
        )
        
        logger.info(f"Processed chunk for campaign {campaign_id}: {success_count} sent, {fail_count} failed")


# Dependency injection function
async def get_campaign_processor():
    """Get campaign processor service instance."""
    from app.db.session import get_repository
    from app.db.repositories.campaigns import CampaignRepository
    from app.db.repositories.messages import MessageRepository
    from app.services.event_bus.bus import get_event_bus
    from app.services.sms.sender import get_sms_sender
    
    campaign_repository = await get_repository(CampaignRepository)
    message_repository = await get_repository(MessageRepository)
    sms_sender = await get_sms_sender()
    event_bus = get_event_bus()
    
    return CampaignProcessor(
        campaign_repository=campaign_repository,
        message_repository=message_repository,
        sms_sender=sms_sender,
        event_bus=event_bus
    )
</file>

<file path="app/services/event_bus/bus.py">
"""
Enhanced event bus implementation for asynchronous messaging between components.
Improvements:
- Better lock handling
- Enhanced error handling and reporting
- Subscriber management
- Event batching support
- Proper subscriber cleanup
"""
import asyncio
import logging
import time
import uuid
from typing import Dict, List, Callable, Any, Set, Optional, Tuple
from datetime import datetime, timezone
from contextlib import asynccontextmanager

from app.services.event_bus.events import EventType, Event

logger = logging.getLogger("inboxerr.eventbus")


class EventBus:
    """
    Enhanced event bus for asynchronous messaging between components.
    
    Supports subscription to events, publishing events, and now includes:
    - Better lock handling for thread safety
    - Error propagation for subscribers
    - Event batching
    - Subscriber cleanup
    """
    
    def __init__(self):
        """Initialize the event bus."""
        self._subscribers: Dict[str, List[Tuple[str, Callable]]] = {}
        self._subscriber_ids: Dict[str, Set[str]] = {}
        self._lock = asyncio.Lock()
        self._initialized = False
        self._event_history: List[Dict[str, Any]] = []  # For debugging
        self._max_history = 100  # Maximum events to keep in history
        self._failed_deliveries: Dict[str, List[Dict[str, Any]]] = {}  # Failed event deliveries
    
    async def initialize(self) -> None:
        """Initialize the event bus."""
        if self._initialized:
            return
        
        logger.info("Initializing event bus")
        self._initialized = True
    
    async def shutdown(self) -> None:
        """Shutdown the event bus and clean up resources."""
        logger.info("Shutting down event bus")
        self._initialized = False
        
        # Clear subscribers
        async with self._lock:
            self._subscribers.clear()
            self._subscriber_ids.clear()
    
    @asynccontextmanager
    async def batch(self):
        """
        Context manager for batching multiple events.
        
        This allows multiple events to be published atomically.
        """
        # Create a batch container
        batch = []
        
        # Define the add_event function that will be used within the context
        async def add_event(event_type: str, data: Dict[str, Any]) -> None:
            batch.append((event_type, data))
        
        try:
            # Yield the add_event function for use within the context
            yield add_event
            
            # Process the batch after the context exits
            for event_type, data in batch:
                await self.publish(event_type, data)
                
        except Exception as e:
            logger.error(f"Error in event batch: {e}", exc_info=True)
            # Re-raise the exception after logging
            raise
    
    async def publish(self, event_type: str, data: Dict[str, Any]) -> bool:
        """
        Publish an event to subscribers.
        
        Args:
            event_type: Type of event
            data: Event data
            
        Returns:
            bool: True if event was successfully published
        """
        if not self._initialized:
            await self.initialize()
        
        subscribers = []
        subscriber_ids = []
        
        # Get subscribers with lock
        async with self._lock:
            if event_type in self._subscribers:
                subscribers = self._subscribers[event_type].copy()
                subscriber_ids = list(self._subscriber_ids[event_type])
        
        if not subscribers:
            logger.debug(f"No subscribers for event: {event_type}")
            return True
        
        # Add timestamp if not present
        if "timestamp" not in data:
            data["timestamp"] = datetime.now(timezone.utc).isoformat()
        
        # Add event type for reference
        data["event_type"] = event_type
        # Add unique event ID
        data["event_id"] = str(uuid.uuid4())
        
        # Keep history for debugging
        if len(self._event_history) >= self._max_history:
            self._event_history.pop(0)
        self._event_history.append({
            "event_type": event_type,
            "data": data,
            "subscribers": subscriber_ids,
            "timestamp": data["timestamp"]
        })
        
        # Execute callbacks outside of the lock
        logger.debug(f"Publishing event {event_type} to {len(subscribers)} subscribers")
        
        all_successful = True
        
        for subscriber_id, callback in subscribers:
            try:
                await callback(data)
            except asyncio.CancelledError:
                # Re-raise cancellation to allow proper task cleanup
                logger.warning(f"Subscriber {subscriber_id} was cancelled during event {event_type}")
                raise
            except Exception as e:
                logger.error(f"Error in subscriber {subscriber_id} for {event_type}: {e}", exc_info=True)
                
                # Record failed delivery
                if subscriber_id not in self._failed_deliveries:
                    self._failed_deliveries[subscriber_id] = []
                    
                self._failed_deliveries[subscriber_id].append({
                    "event_type": event_type,
                    "event_id": data["event_id"],
                    "error": str(e),
                    "timestamp": datetime.now(timezone.utc).isoformat()
                })
                
                # Limit failed deliveries history
                if len(self._failed_deliveries[subscriber_id]) > self._max_history:
                    self._failed_deliveries[subscriber_id].pop(0)
                
                all_successful = False
        
        return all_successful
    
    async def subscribe(
        self,
        event_type: str,
        callback: Callable,
        subscriber_id: Optional[str] = None
    ) -> str:
        """
        Subscribe to an event type.
        
        Args:
            event_type: Event type to subscribe to
            callback: Function to call when event occurs
            subscriber_id: Optional subscriber ID
            
        Returns:
            str: Subscriber ID
        """
        if not self._initialized:
            await self.initialize()
        
        # Generate subscriber ID if not provided
        if subscriber_id is None:
            subscriber_id = f"{callback.__module__}.{callback.__name__}_{str(uuid.uuid4())[:8]}"
        
        async with self._lock:
            # Initialize event type if not exists
            if event_type not in self._subscribers:
                self._subscribers[event_type] = []
                self._subscriber_ids[event_type] = set()
            
            # Add subscriber if not already subscribed
            if subscriber_id not in self._subscriber_ids[event_type]:
                self._subscribers[event_type].append((subscriber_id, callback))
                self._subscriber_ids[event_type].add(subscriber_id)
                logger.info(f"Subscribed to {event_type}: {subscriber_id}")
            else:
                # Update callback for existing subscriber ID
                for i, (sid, _) in enumerate(self._subscribers[event_type]):
                    if sid == subscriber_id:
                        self._subscribers[event_type][i] = (subscriber_id, callback)
                        logger.debug(f"Updated subscriber callback for {event_type}: {subscriber_id}")
                        break
        
        return subscriber_id
    
    async def unsubscribe(self, event_type: str, subscriber_id: str) -> bool:
        """
        Unsubscribe from an event type.
        
        Args:
            event_type: Event type to unsubscribe from
            subscriber_id: Subscriber ID
            
        Returns:
            bool: True if unsubscribed, False if not found
        """
        if not self._initialized:
            await self.initialize()
        
        async with self._lock:
            if event_type not in self._subscribers:
                return False
            
            if subscriber_id not in self._subscriber_ids[event_type]:
                return False
            
            # Find and remove the subscriber
            self._subscribers[event_type] = [
                (sid, callback) for sid, callback in self._subscribers[event_type]
                if sid != subscriber_id
            ]
            self._subscriber_ids[event_type].remove(subscriber_id)
            
            logger.info(f"Unsubscribed from {event_type}: {subscriber_id}")
            
            # Clean up failed deliveries for this subscriber
            if subscriber_id in self._failed_deliveries:
                del self._failed_deliveries[subscriber_id]
            
            return True
    
    async def unsubscribe_all(self, subscriber_id: str) -> int:
        """
        Unsubscribe from all event types.
        
        Args:
            subscriber_id: Subscriber ID
            
        Returns:
            int: Number of subscriptions removed
        """
        if not self._initialized:
            await self.initialize()
        
        count = 0
        
        async with self._lock:
            for event_type in list(self._subscribers.keys()):
                # Check if subscriber exists for this event type
                if subscriber_id in self._subscriber_ids[event_type]:
                    # Remove from subscribers list
                    self._subscribers[event_type] = [
                        (sid, callback) for sid, callback in self._subscribers[event_type]
                        if sid != subscriber_id
                    ]
                    # Remove from subscriber IDs set
                    self._subscriber_ids[event_type].remove(subscriber_id)
                    count += 1
            
            # Clean up failed deliveries for this subscriber
            if subscriber_id in self._failed_deliveries:
                del self._failed_deliveries[subscriber_id]
        
        if count > 0:
            logger.info(f"Unsubscribed {subscriber_id} from {count} event types")
        
        return count
    
    def get_subscriber_count(self, event_type: Optional[str] = None) -> int:
        """
        Get the number of subscribers.
        
        Args:
            event_type: Optional event type to count subscribers for
            
        Returns:
            int: Number of subscribers
        """
        if event_type:
            return len(self._subscribers.get(event_type, []))
        else:
            return sum(len(subscribers) for subscribers in self._subscribers.values())
    
    def get_event_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get recent event history for debugging.
        
        Args:
            limit: Maximum number of events to return
            
        Returns:
            List[Dict]: Recent events
        """
        return self._event_history[-limit:] if self._event_history else []
    
    def get_failed_deliveries(self, subscriber_id: Optional[str] = None) -> Dict[str, List[Dict[str, Any]]]:
        """
        Get failed event deliveries.
        
        Args:
            subscriber_id: Optional subscriber ID to filter by
            
        Returns:
            Dict: Failed deliveries by subscriber ID
        """
        if subscriber_id:
            return {subscriber_id: self._failed_deliveries.get(subscriber_id, [])}
        else:
            return self._failed_deliveries


# Singleton instance
_event_bus = EventBus()

def get_event_bus() -> EventBus:
    """Get the singleton event bus instance."""
    return _event_bus
</file>

<file path="app/services/metrics/collector.py">
# app/services/metrics/collector.py
import logging
from typing import Dict, Any, Optional

from app.services.event_bus.bus import get_event_bus
from app.services.event_bus.events import EventType

logger = logging.getLogger("inboxerr.metrics")

# Global metrics store (in-memory for MVP)
_metrics = {
    "messages": {
        "total": 0,
        "sent": 0,
        "delivered": 0,
        "failed": 0
    },
    "users": {
        "total": 0,
        "active": 0
    },
    "webhooks": {
        "total": 0,
        "delivered": 0,
        "failed": 0
    }
}

async def initialize_metrics() -> None:
    """Initialize metrics collector."""
    logger.info("Initializing metrics collector")
    
    # Subscribe to events
    event_bus = get_event_bus()
    
    # Message events
    await event_bus.subscribe(
        EventType.MESSAGE_CREATED,
        _handle_message_created,
        "metrics.message_created"
    )
    
    await event_bus.subscribe(
        EventType.MESSAGE_SENT,
        _handle_message_sent,
        "metrics.message_sent"
    )
    
    await event_bus.subscribe(
        EventType.MESSAGE_DELIVERED,
        _handle_message_delivered,
        "metrics.message_delivered"
    )
    
    await event_bus.subscribe(
        EventType.MESSAGE_FAILED,
        _handle_message_failed,
        "metrics.message_failed"
    )
    
    logger.info("Metrics collector initialized")

async def get_metrics() -> Dict[str, Any]:
    """Get current metrics."""
    return _metrics

async def _handle_message_created(data: Dict[str, Any]) -> None:
    """Handle message created event."""
    _metrics["messages"]["total"] += 1

async def _handle_message_sent(data: Dict[str, Any]) -> None:
    """Handle message sent event."""
    _metrics["messages"]["sent"] += 1

async def _handle_message_delivered(data: Dict[str, Any]) -> None:
    """Handle message delivered event."""
    _metrics["messages"]["delivered"] += 1

async def _handle_message_failed(data: Dict[str, Any]) -> None:
    """Handle message failed event."""
    _metrics["messages"]["failed"] += 1
</file>

<file path="app/services/rate_limiter.py">
"""
Rate limiting service for API request throttling.
"""
import asyncio
import time
from typing import Dict, Any, Optional, Tuple
import logging
from datetime import datetime, timezone

from app.core.config import settings

logger = logging.getLogger("inboxerr.rate_limiter")

class RateLimiter:
    """
    Service for enforcing rate limits on API requests.
    
    Uses a simple in-memory storage for tracking request counts.
    For production, consider using Redis or another distributed storage.
    """
    
    def __init__(self):
        """Initialize the rate limiter with default limits."""
        self._requests = {}
        self._lock = asyncio.Lock()
        
        # Default rate limits by operation type
        self._rate_limits = {
            "send_message": {"requests": 60, "period": 60},  # 60 requests per minute
            "send_batch": {"requests": 10, "period": 60},    # 10 batch requests per minute
            "import_messages": {"requests": 5, "period": 300},  # 5 imports per 5 minutes
            "default": {"requests": 100, "period": 60},      # Default: 100 requests per minute
        }
    
    async def check_rate_limit(
        self, 
        user_id: str, 
        operation: str = "default"
    ) -> bool:
        """
        Check if a request is within rate limits.
        
        Args:
            user_id: ID of the user making the request
            operation: Type of operation being performed
            
        Returns:
            bool: True if request is allowed, raises exception otherwise
            
        Raises:
            HTTPException: If rate limit is exceeded
        """
        from fastapi import HTTPException, status
        
        # Get rate limit for operation
        limit = self._rate_limits.get(operation, self._rate_limits["default"])
        
        # Create key for this user and operation
        key = f"{user_id}:{operation}"
        
        current_time = time.time()
        
        async with self._lock:
            # Initialize if not exists
            if key not in self._requests:
                self._requests[key] = {"count": 0, "reset_at": current_time + limit["period"]}
            
            # Check if we need to reset the counter
            if current_time > self._requests[key]["reset_at"]:
                self._requests[key] = {"count": 0, "reset_at": current_time + limit["period"]}
            
            # Check if we're over the limit
            if self._requests[key]["count"] >= limit["requests"]:
                reset_in = int(self._requests[key]["reset_at"] - current_time)
                logger.warning(f"Rate limit exceeded for {key}. Reset in {reset_in} seconds.")
                
                # Calculate when the rate limit will reset
                reset_at = datetime.fromtimestamp(self._requests[key]["reset_at"])
                
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail=f"Rate limit exceeded. Try again in {reset_in} seconds.",
                    headers={"Retry-After": str(reset_in)}
                )
            
            # Increment counter
            self._requests[key]["count"] += 1
            
            logger.debug(f"Rate limit for {key}: {self._requests[key]['count']}/{limit['requests']}")
            
            return True
    
    def set_limit(self, operation: str, requests: int, period: int) -> None:
        """
        Set a custom rate limit for an operation.
        
        Args:
            operation: Operation type to set limit for
            requests: Maximum number of requests allowed
            period: Time period in seconds
        """
        self._rate_limits[operation] = {"requests": requests, "period": period}
    
    async def get_limit_status(self, user_id: str, operation: str = "default") -> Dict[str, Any]:
        """
        Get current rate limit status for a user and operation.
        
        Args:
            user_id: User ID
            operation: Operation type
            
        Returns:
            Dict: Rate limit status information
        """
        # Get rate limit for operation
        limit = self._rate_limits.get(operation, self._rate_limits["default"])
        
        # Create key for this user and operation
        key = f"{user_id}:{operation}"
        
        current_time = time.time()
        
        async with self._lock:
            # Handle case where user hasn't made any requests yet
            if key not in self._requests:
                return {
                    "limit": limit["requests"],
                    "remaining": limit["requests"],
                    "reset": int(current_time + limit["period"]),
                    "used": 0
                }
            
            # Reset counter if needed
            if current_time > self._requests[key]["reset_at"]:
                self._requests[key] = {"count": 0, "reset_at": current_time + limit["period"]}
            
            # Return current status
            return {
                "limit": limit["requests"],
                "remaining": max(0, limit["requests"] - self._requests[key]["count"]),
                "reset": int(self._requests[key]["reset_at"]),
                "used": self._requests[key]["count"]
            }


# Singleton instance for dependency injection
_rate_limiter = RateLimiter()

def get_rate_limiter() -> RateLimiter:
    """Get the singleton rate limiter instance."""
    return _rate_limiter
</file>

<file path="app/services/webhooks/models.py">
# app/services/webhooks/models.py
"""
Pydantic models for webhook payloads from SMS Gateway.
"""
from datetime import datetime, timezone
from typing import Dict, Any, Optional, Literal
from pydantic import BaseModel, Field

class SmsReceivedPayload(BaseModel):
    """Payload for sms:received event."""
    message_id: str = Field(..., alias="messageId")
    message: str
    phone_number: str = Field(..., alias="phoneNumber")
    sim_number: Optional[int] = Field(None, alias="simNumber")
    received_at: datetime = Field(..., alias="receivedAt")
    
class SmsSentPayload(BaseModel):
    """Payload for sms:sent event."""
    message_id: str = Field(..., alias="messageId")
    phone_number: str = Field(..., alias="phoneNumber")
    sim_number: Optional[int] = Field(None, alias="simNumber")
    sent_at: datetime = Field(..., alias="sentAt")
    
class SmsDeliveredPayload(BaseModel):
    """Payload for sms:delivered event."""
    message_id: str = Field(..., alias="messageId")
    phone_number: str = Field(..., alias="phoneNumber")
    sim_number: Optional[int] = Field(None, alias="simNumber")
    delivered_at: datetime = Field(..., alias="deliveredAt")
    
class SmsFailedPayload(BaseModel):
    """Payload for sms:failed event."""
    message_id: str = Field(..., alias="messageId")
    phone_number: str = Field(..., alias="phoneNumber")
    sim_number: Optional[int] = Field(None, alias="simNumber")
    failed_at: datetime = Field(..., alias="failedAt")
    reason: str
    
class SystemPingPayload(BaseModel):
    """Payload for system:ping event."""
    health: Dict[str, Any]
    
EventType = Literal["sms:received", "sms:sent", "sms:delivered", "sms:failed", "system:ping"]

class WebhookPayload(BaseModel):
    """Base webhook payload from SMS Gateway."""
    device_id: str = Field(..., alias="deviceId")
    event: EventType
    id: str
    webhook_id: str = Field(..., alias="webhookId")
    payload: Dict[str, Any]  # Will be converted to specific payload types based on event
</file>

<file path="app/utils/phone.py">
"""
Phone number validation and formatting utilities.
"""
import re
from typing import Any, Tuple, Dict, Optional, List
import logging

logger = logging.getLogger("inboxerr.phone")

try:
    import phonenumbers
    from phonenumbers import NumberParseException, PhoneNumberFormat
    PHONENUMBERS_AVAILABLE = True
except ImportError:
    PHONENUMBERS_AVAILABLE = False
    logger.warning("phonenumbers library not available, using basic validation")


class PhoneValidationError(Exception):
    """Exception raised for phone validation errors."""
    
    def __init__(self, message: str, details: Optional[Dict] = None):
        self.message = message
        self.details = details or {}
        super().__init__(message)


def validate_phone_basic(number: str) -> Tuple[bool, str, Optional[str]]:
    """
    Basic phone number validation without external libraries.
    
    Args:
        number: Phone number to validate
        
    Returns:
        Tuple[bool, str, str]: (is_valid, formatted_number, error_message)
    """
    # Remove common formatting characters
    cleaned = re.sub(r'[\s\-\(\)\.]+', '', number)
    
    # Check if it's just digits and maybe a leading +
    if not re.match(r'^\+?\d+$', cleaned):
        return False, number, "Phone number contains invalid characters"
    
    # Ensure it starts with + for E.164 format
    if not cleaned.startswith('+'):
        cleaned = '+' + cleaned
    
    # Basic length check
    if len(cleaned) < 8:
        return False, cleaned, "Phone number too short"
    if len(cleaned) > 16:
        return False, cleaned, "Phone number too long"
    
    return True, cleaned, None


def validate_phone_advanced(number: str) -> Tuple[bool, str, Optional[str], Optional[Dict[str, Any]]]:
    """
    Advanced phone number validation using the phonenumbers library.
    
    Args:
        number: Phone number to validate
        
    Returns:
        Tuple[bool, str, str, dict]: (is_valid, formatted_number, error_message, metadata)
    """
    metadata = {}
    
    try:
        # Parse the phone number
        try:
            parsed = phonenumbers.parse(number, None)
        except NumberParseException as e:
            return False, number, f"Parse error: {str(e)}", None
        
        # Check if it's a valid number
        if not phonenumbers.is_valid_number(parsed):
            return False, number, "Invalid phone number", None
        
        # Format in E.164 format
        formatted = phonenumbers.format_number(
            parsed, PhoneNumberFormat.E164
        )
        
        # Get the country and carrier
        country = phonenumbers.region_code_for_number(parsed)
        metadata["country"] = country
        
        # Check if it's a mobile number
        number_type = phonenumbers.number_type(parsed)
        is_mobile = (number_type == phonenumbers.PhoneNumberType.MOBILE)
        metadata["is_mobile"] = is_mobile
        
        # Check for other properties
        metadata["number_type"] = str(number_type)
        metadata["country_code"] = parsed.country_code
        metadata["national_number"] = parsed.national_number
        
        # Additional validations
        is_possible = phonenumbers.is_possible_number(parsed)
        if not is_possible:
            return False, formatted, "Number is not possible", metadata
        
        return True, formatted, None, metadata
    except Exception as e:
        return False, number, f"Validation error: {str(e)}", None


def validate_phone(number: str, strict: bool = False) -> Tuple[bool, str, Optional[str], Optional[Dict]]:
    """
    Validate and format a phone number.
    
    Uses the phonenumbers library if available, otherwise falls back to basic validation.
    
    Args:
        number: Phone number to validate
        strict: Whether to apply strict validation (country code check, etc.)
        
    Returns:
        Tuple[bool, str, str, dict]: (is_valid, formatted_number, error_message, metadata)
    """
    if PHONENUMBERS_AVAILABLE:
        return validate_phone_advanced(number)
    else:
        is_valid, formatted, error = validate_phone_basic(number)
        return is_valid, formatted, error, None


def is_valid_phone(number: str, strict: bool = False) -> bool:
    """
    Check if a phone number is valid.
    
    Args:
        number: Phone number to validate
        strict: Whether to apply strict validation
        
    Returns:
        bool: True if valid, False otherwise
    """
    is_valid, _, _, _ = validate_phone(number, strict)
    return is_valid


def format_phone(number: str) -> str:
    """
    Format a phone number in E.164 format.
    
    Args:
        number: Phone number to format
        
    Returns:
        str: Formatted phone number or original if invalid
        
    Raises:
        PhoneValidationError: If the phone number is invalid
    """
    is_valid, formatted, error, _ = validate_phone(number)
    if not is_valid:
        raise PhoneValidationError(error or "Invalid phone number", {"number": number})
    return formatted


def validate_batch_phone_numbers(phone_numbers: List[str]) -> Dict[str, List[Dict[str, Any]]]:
    """
    Validate a batch of phone numbers.
    
    Args:
        phone_numbers: List of phone numbers to validate
        
    Returns:
        Dict: Dictionary with 'valid' and 'invalid' lists
    """
    valid = []
    invalid = []
    
    for number in phone_numbers:
        is_valid, formatted, error, metadata = validate_phone(number)
        if is_valid:
            valid.append({
                "original": number,
                "formatted": formatted,
                "metadata": metadata or {}
            })
        else:
            invalid.append({
                "original": number,
                "error": error,
                "metadata": metadata or {}
            })
    
    return {
        "valid": valid,
        "invalid": invalid,
        "summary": {
            "total": len(phone_numbers),
            "valid_count": len(valid),
            "invalid_count": len(invalid)
        }
    }


def extract_phone_numbers(text: str) -> List[str]:
    """
    Extract potential phone numbers from text.
    
    Args:
        text: Text to extract phone numbers from
        
    Returns:
        List[str]: List of potential phone numbers
    """
    # Define regex patterns for phone number detection
    patterns = [
        r'\+\d{1,3}\s?\d{1,14}',  # +1 123456789
        r'\(\d{1,4}\)\s?\d{1,14}', # (123) 456789
        r'\d{1,4}[- .]\d{1,4}[- .]\d{1,10}'  # 123-456-7890
    ]
    
    results = []
    
    for pattern in patterns:
        matches = re.findall(pattern, text)
        results.extend(matches)
    
    # Deduplicate and return
    return list(set(results))
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  # API service
  api:
    build: .
    container_name: inboxerr-api
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@db:5432/inboxerr
      - SMS_GATEWAY_URL=${SMS_GATEWAY_URL:-https://endpointnumber1.work.gd/api/3rdparty/v1}
      - SMS_GATEWAY_LOGIN=${SMS_GATEWAY_LOGIN:-}
      - SMS_GATEWAY_PASSWORD=${SMS_GATEWAY_PASSWORD:-}
      - SECRET_KEY=${SECRET_KEY:-CHANGEME_IN_PRODUCTION}
      - WEBHOOK_HOST=0.0.0.0
      - WEBHOOK_PORT=5000
      - LOG_LEVEL=DEBUG
    depends_on:
      db:
        condition: service_healthy
      db-init:
        condition: service_completed_successfully
    networks:
      - inboxerr-network
    restart: unless-stopped

  # Database service
  db:
    image: postgres:14-alpine
    container_name: inboxerr-db
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=inboxerr
    ports:
      - "5432:5432"
    networks:
      - inboxerr-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Database initialization service
  db-init:
    build: .
    container_name: inboxerr-db-init
    command: >
      sh -c "
        echo 'Waiting for database to be ready...' &&
        sleep 5 &&
        echo 'Running database migrations...' &&
        alembic upgrade head &&
        echo 'Creating admin user...' &&
        python app/scripts/create_admin.py &&
        echo 'Database initialization completed.'
      "
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@db:5432/inboxerr
      - SECRET_KEY=${SECRET_KEY:-CHANGEME_IN_PRODUCTION}
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
    networks:
      - inboxerr-network
    restart: "no"  # Run once and exit

  # Optional: Redis for caching and task queue
  redis:
    image: redis:alpine
    container_name: inboxerr-redis
    ports:
      - "6379:6379"
    networks:
      - inboxerr-network
    restart: unless-stopped

  # Optional: PgAdmin for database management
  pgadmin:
    image: dpage/pgadmin4
    container_name: inboxerr-pgadmin
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@inboxerr.com
      - PGADMIN_DEFAULT_PASSWORD=admin
    ports:
      - "5050:80"
    depends_on:
      - db
    networks:
      - inboxerr-network
    restart: unless-stopped

networks:
  inboxerr-network:
    driver: bridge

volumes:
  postgres_data:
</file>

<file path="project_structure.md">
# Inboxerr Backend Project Structure

```
/inboxerr-backend/

 /app/                      # Application package
    __init__.py            # Package initializer
    main.py                # FastAPI application entry point
   
    /api/                  # API endpoints and routing
       __init__.py
       router.py          # Main API router
       /v1/               # API version 1
          __init__.py
          endpoints/     # API endpoints by resource
             __init__.py
             auth.py    # Authentication endpoints
             messages.py # SMS message endpoints
             webhooks.py # Webhook endpoints
             metrics.py  # Metrics and reporting endpoints
          dependencies.py # API-specific dependencies
   
    /core/                 # Core application components
       __init__.py
       config.py          # Application configuration
       security.py        # Security utilities (auth, encryption)
       events.py          # Event handlers for application lifecycle
       exceptions.py      # Custom exception classes
   
    /db/                   # Database related code
       __init__.py
       base.py            # Base DB session setup
       session.py         # DB session management
       repositories/      # Repository pattern implementations
           __init__.py
           base.py        # Base repository class
           messages.py    # Message repository
           users.py       # User repository
   
    /models/               # Database models
       __init__.py
       base.py            # Base model class
       message.py         # SMS message model
       user.py            # User model
       webhook.py         # Webhook model
   
    /schemas/              # Pydantic schemas for API
       __init__.py
       base.py            # Base schema
       message.py         # Message schemas
       user.py            # User schemas
       webhook.py         # Webhook schemas
       metrics.py         # Metrics schemas
   
    /services/             # Business logic services
       __init__.py
       sms/               # SMS related services
          __init__.py
          sender.py      # SMS sender implementation
          validator.py   # Phone/message validation
          gateway.py     # SMS gateway client
      
       event_bus/         # Event management
          __init__.py
          bus.py         # Event bus implementation
          events.py      # Event definitions
          handlers/      # Event handlers
              __init__.py
              message_handlers.py
              system_handlers.py
      
       webhooks/          # Webhook handling
          __init__.py
          handler.py     # Webhook processor
          manager.py     # Webhook registration/management
      
       metrics/           # Metrics collection
           __init__.py
           collector.py   # Metrics collector
   
    /utils/                # Utility functions and helpers
        __init__.py
        phone.py           # Phone number utilities
        logging.py         # Logging configuration
        pagination.py      # Pagination utilities

 /alembic/                  # Database migrations
    env.py                 # Alembic environment
    README                 # Alembic readme
    script.py.mako         # Migration script template
    /versions/             # Migration scripts

 /tests/                    # Test suite
    __init__.py
    conftest.py            # Test configuration and fixtures
    /unit/                 # Unit tests
       __init__.py
       /services/         # Tests for services
       /api/              # Tests for API endpoints
    /integration/          # Integration tests
        __init__.py
        /api/              # API integration tests

 /scripts/                  # Utility scripts
    seed_db.py             # Database seeding script
    generate_keys.py       # Generate security keys

 .env.example               # Example environment variables
 .gitignore                 # Git ignore file
 docker-compose.yml         # Docker Compose configuration
 Dockerfile                 # Docker build configuration
 pyproject.toml             # Python project metadata
 requirements.txt           # Python dependencies
 requirements-dev.txt       # Development dependencies
 README.md                  # Project documentation
```
</file>

<file path="scripts/seed_db.py">
"""
Placeholder script for seeding the database in development.
Currently not in use  extend as needed.
Seed the database with essential data (e.g., admin user).
Currently skips message seeding  placeholder for future use.

"""

import subprocess
import os
import sys

def run_admin_script():
    """Ensure an admin user exists by running create_admin.py."""
    try:
        subprocess.run(
            [sys.executable, "app/scripts/create_admin.py"],
            check=True,
            cwd=os.getcwd(),  # Ensures correct working directory
            env={**os.environ, "PYTHONPATH": os.getcwd()}
        )
        print(" Admin user created.")
    except subprocess.CalledProcessError:
        print(" Failed to create admin user. Check create_admin.py.")


def seed():
    print(" [SKIPPED] No seed data logic implemented yet.")

if __name__ == "__main__":
    seed()
    run_admin_script()
</file>

<file path="alembic/env.py">
from logging.config import fileConfig
import os
import sys
from pathlib import Path

# Add the parent directory to sys.path
sys.path.append(str(Path(__file__).parent.parent))

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context
from app.core.config import settings
from app.db.base import Base


# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# Get database URL from environment or settings
db_url = os.environ.get("ALEMBIC_DB_URL", settings.DATABASE_URL)

# Convert asyncpg URL to standard psycopg2 URL for Alembic
if "+asyncpg" in db_url:
    db_url = db_url.replace("+asyncpg", "")


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    # Set SQL Alchemy URL from our db_url
    config.set_main_option("sqlalchemy.url", db_url)
    
    url = config.get_main_option("sqlalchemy.url")
    
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # Set SQL Alchemy URL from our db_url
    config.set_main_option("sqlalchemy.url", db_url)

    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="app/api/router.py">
"""
Main API router that includes all endpoint routers.
"""
from fastapi import APIRouter

from app.api.v1.endpoints import auth, messages, webhooks, metrics, campaigns, templates


# Create main API router
api_router = APIRouter()

# Include all endpoint routers with appropriate tags
api_router.include_router(
    auth.router, 
    prefix="/auth", 
    tags=["Authentication"]
)
api_router.include_router(
    messages.router, 
    prefix="/messages", 
    tags=["Messages"]
)
api_router.include_router(
    campaigns.router, 
    prefix="/campaigns", 
    tags=["Campaigns"]
)
api_router.include_router(
    templates.router, 
    prefix="/templates", 
    tags=["Templates"]
)
api_router.include_router(
    webhooks.router, 
    prefix="/webhooks", 
    tags=["Webhooks"]
)
api_router.include_router(
    metrics.router, 
    prefix="/metrics", 
    tags=["Metrics"]
)
</file>

<file path="app/core/config.py">
"""
Application settings and configuration management.
"""
from typing import List, Optional, Union
from pydantic import AnyHttpUrl, validator, field_validator
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """Application settings."""
    # Base
    PROJECT_NAME: str = "Inboxerr Backend"
    PROJECT_DESCRIPTION: str = "API backend for SMS management and delivery"
    VERSION: str = "0.1.0"
    API_PREFIX: str = "/api/v1"
    DEBUG: bool = False
    
    # CORS
    BACKEND_CORS_ORIGINS: List[Union[str, AnyHttpUrl]] = []

    @field_validator("BACKEND_CORS_ORIGINS", mode='before')
    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:
        """Parse CORS origins from string or list."""
        if isinstance(v, str) and not v.startswith("["):
            return [i.strip() for i in v.split(",")]
        elif isinstance(v, (list, str)):
            return v
        raise ValueError(v)
    
    # Authentication
    SECRET_KEY: str = "CHANGEME_IN_PRODUCTION"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24  # 1 day
    API_KEY_HEADER: str = "X-API-Key"

    # Database
    DATABASE_URL: str = "postgresql+asyncpg://postgres:admin@localhost:5432/inboxerr"
    
    # SMS Gateway
    SMS_GATEWAY_URL: str = "https://endpointnumber1.work.gd/api/3rdparty/v1"
    SMS_GATEWAY_LOGIN: str = ""
    SMS_GATEWAY_PASSWORD: str = ""
    
    # Webhook
    API_BASE_URL: str = "http://localhost:8000"  # Base URL for webhooks
    WEBHOOK_SIGNATURE_KEY: Optional[str] = None
    WEBHOOK_TIMESTAMP_TOLERANCE: int = 300  # 5 minutes
    
    # SMS Processing
    BATCH_SIZE: int = 100
    DELAY_BETWEEN_SMS: float = 0.3  # seconds
    RETRY_ENABLED: bool = False
    RETRY_MAX_ATTEMPTS: int = 3
    RETRY_INTERVAL_SECONDS: int = 60
    
    # Logging
    LOG_LEVEL: str = "INFO"
    
    class Config:
        """Pydantic config."""
        case_sensitive = True
        env_file = ".env"


# Create singleton settings instance
settings = Settings()
</file>

<file path="app/models/message.py">
"""
Database models for SMS messages.
"""
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any

from sqlalchemy import Column, String, DateTime, Boolean, JSON, Integer, ForeignKey, Text
from sqlalchemy.orm import relationship

from app.models.base import Base


class Message(Base):
    """SMS message model."""
    
    # Core message data
    custom_id = Column(String, unique=True, index=True, nullable=True)
    phone_number = Column(String, nullable=False, index=True)
    message = Column(Text, nullable=False)
    status = Column(String, nullable=False, default="pending", index=True)

    # Campaign relationship
    campaign_id = Column(String, ForeignKey("campaign.id"), nullable=True, index=True)
    campaign = relationship("Campaign", back_populates="messages")
    
    # Timestamps for status tracking
    scheduled_at = Column(DateTime(timezone=True), nullable=True, index=True)
    sent_at = Column(DateTime(timezone=True), nullable=True)
    delivered_at = Column(DateTime(timezone=True), nullable=True)
    failed_at = Column(DateTime(timezone=True), nullable=True)
    
    # Additional data
    reason = Column(String, nullable=True)
    gateway_message_id = Column(String, nullable=True, index=True)
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    meta_data = Column(JSON, nullable=True)  # Changed from 'metadata' to 'meta_data'
    
    # SMS parts tracking
    parts_count = Column(Integer, default=1, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="messages")
    events = relationship("MessageEvent", back_populates="message", cascade="all, delete-orphan")
    batch_id = Column(String, ForeignKey("messagebatch.id"), nullable=True, index=True)
    batch = relationship("MessageBatch", back_populates="messages")


class MessageEvent(Base):
    """Model for tracking message events and status changes."""
    
    message_id = Column(String, ForeignKey("message.id"), nullable=False, index=True)
    event_type = Column(String, nullable=False, index=True)
    status = Column(String, nullable=False)
    data = Column(JSON, nullable=True)
    
    # Relationships
    message = relationship("Message", back_populates="events")


class MessageBatch(Base):
    """Model for tracking message batches."""
    
    name = Column(String, nullable=True)
    total = Column(Integer, default=0, nullable=False)
    processed = Column(Integer, default=0, nullable=False)
    successful = Column(Integer, default=0, nullable=False)
    failed = Column(Integer, default=0, nullable=False)
    status = Column(String, nullable=False, default="pending", index=True)
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    messages = relationship("Message", back_populates="batch")
    user = relationship("User")


class MessageTemplate(Base):
    """Model for storing reusable message templates."""
    
    name = Column(String, nullable=False, index=True)
    content = Column(Text, nullable=False)
    description = Column(String, nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    user_id = Column(String, ForeignKey("user.id"), nullable=False, index=True)
    variables = Column(JSON, nullable=True)  # Define expected variables in the template
    
    # Relationships
    user = relationship("User")
</file>

<file path="app/schemas/campaign.py">
# app/schemas/campaign.py
from typing import List, Optional, Dict, Any
from datetime import datetime, timezone
from uuid import UUID

from pydantic import BaseModel, Field, validator


class CampaignBase(BaseModel):
    """Base schema for campaign data."""
    name: str = Field(..., description="Campaign name")
    description: Optional[str] = Field(None, description="Campaign description")
    scheduled_start_at: Optional[datetime] = Field(None, description="Scheduled start time")
    scheduled_end_at: Optional[datetime] = Field(None, description="Scheduled end time")
    settings: Optional[Dict[str, Any]] = Field(default={}, description="Campaign settings")


class CampaignCreate(CampaignBase):
    """Schema for creating a new campaign."""
    pass


class CampaignCreateFromCSV(BaseModel):
    """Schema for creating a campaign from CSV file."""
    name: str = Field(..., description="Campaign name")
    description: Optional[str] = Field(None, description="Campaign description")
    message_template: str = Field(..., description="Message template to send")
    scheduled_start_at: Optional[datetime] = Field(None, description="Scheduled start time")
    scheduled_end_at: Optional[datetime] = Field(None, description="Scheduled end time")
    settings: Optional[Dict[str, Any]] = Field(default={}, description="Campaign settings")


class CampaignUpdate(BaseModel):
    """Schema for updating a campaign."""
    name: Optional[str] = Field(None, description="Campaign name")
    description: Optional[str] = Field(None, description="Campaign description")
    scheduled_start_at: Optional[datetime] = Field(None, description="Scheduled start time")
    scheduled_end_at: Optional[datetime] = Field(None, description="Scheduled end time")
    settings: Optional[Dict[str, Any]] = Field(None, description="Campaign settings")


class CampaignStatus(BaseModel):
    """Schema for campaign status update."""
    status: str = Field(..., description="Campaign status")
    
    @validator("status")
    def validate_status(cls, v):
        """Validate status value."""
        valid_statuses = ["draft", "active", "paused", "completed", "cancelled", "failed"]
        if v not in valid_statuses:
            raise ValueError(f"Status must be one of: {', '.join(valid_statuses)}")
        return v


class CampaignResponse(CampaignBase):
    """Schema for campaign response."""
    id: str = Field(..., description="Campaign ID")
    status: str = Field(..., description="Campaign status")
    total_messages: int = Field(..., description="Total number of messages")
    sent_count: int = Field(..., description="Number of sent messages")
    delivered_count: int = Field(..., description="Number of delivered messages")
    failed_count: int = Field(..., description="Number of failed messages")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    started_at: Optional[datetime] = Field(None, description="Start timestamp")
    completed_at: Optional[datetime] = Field(None, description="Completion timestamp")
    user_id: str = Field(..., description="User ID")
    
    # Add computed fields
    progress_percentage: float = Field(0, description="Progress percentage")
    delivery_success_rate: float = Field(0, description="Delivery success rate")
    
    class Config:
        """Pydantic config."""
        from_attributes = True


class CampaignListResponse(BaseModel):
    """Schema for campaign list response with pagination."""
    items: List[CampaignResponse]
    total: int
    page: int
    size: int
    pages: int
</file>

<file path="app/schemas/message.py">
"""
Pydantic schemas for message-related API operations.
"""
from typing import List, Optional, Dict, Any
from datetime import datetime, timezone
from enum import Enum
from pydantic import BaseModel, Field, validator


class MessageStatus(str, Enum):
    """Possible message statuses."""
    PENDING = "pending"
    PROCESSED = "processed"
    SENT = "sent"
    DELIVERED = "delivered"
    FAILED = "failed"
    SCHEDULED = "scheduled"
    CANCELLED = "cancelled"


class MessageCreate(BaseModel):
    """Schema for creating a new message."""
    phone_number: str = Field(..., description="Recipient phone number in E.164 format")
    message: str = Field(..., description="Message content")
    scheduled_at: Optional[datetime] = Field(None, description="Schedule message for future delivery")
    custom_id: Optional[str] = Field(None, description="Custom ID for tracking")
    
    @validator("phone_number")
    def validate_phone_number(cls, v):
        """Validate phone number format."""
        # Basic validation - will be handled more thoroughly in the service
        if not v or not (v.startswith("+") and len(v) >= 8):
            raise ValueError("Phone number must be in E.164 format (e.g. +1234567890)")
        return v
    
    @validator("message")
    def validate_message(cls, v):
        """Validate message content."""
        if not v or len(v.strip()) == 0:
            raise ValueError("Message cannot be empty")
        if len(v) > 1600:  # Allow for multi-part SMS
            raise ValueError("Message exceeds maximum length of 1600 characters")
        return v


class MessageResponse(BaseModel):
    """Schema for message response."""
    id: str = Field(..., description="Message ID")
    custom_id: Optional[str] = Field(None, description="Custom ID if provided")
    phone_number: str = Field(..., description="Recipient phone number")
    message: str = Field(..., description="Message content")
    status: MessageStatus = Field(..., description="Current message status")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    scheduled_at: Optional[datetime] = Field(None, description="Scheduled delivery time")
    sent_at: Optional[datetime] = Field(None, description="Time when message was sent")
    delivered_at: Optional[datetime] = Field(None, description="Time when message was delivered")
    failed_at: Optional[datetime] = Field(None, description="Time when message failed")
    reason: Optional[str] = Field(None, description="Failure reason if applicable")
    gateway_message_id: Optional[str] = Field(None, description="ID from SMS gateway")
    user_id: str = Field(..., description="User who sent the message")
    metadata: Optional[Dict[str, Any]] = Field(default={}, description="Additional metadata")
    
    class Config:
        """Pydantic config."""
        from_attributes = True


class MessageStatusUpdate(BaseModel):
    """Schema for updating message status."""
    status: MessageStatus = Field(..., description="New message status")
    reason: Optional[str] = Field(None, description="Reason for status change (required for FAILED)")
    
    @validator("reason")
    def validate_reason(cls, v, values):
        """Validate reason field."""
        if values.get("status") == MessageStatus.FAILED and not v:
            raise ValueError("Reason is required when status is FAILED")
        return v


class BatchOptions(BaseModel):
    """Options for batch processing."""
    delay_between_messages: Optional[float] = Field(0.3, description="Delay between messages in seconds")
    fail_on_first_error: Optional[bool] = Field(False, description="Stop processing on first error")
    retry_failed: Optional[bool] = Field(True, description="Automatically retry failed messages")


class BatchMessageRequest(BaseModel):
    """Schema for batch message request."""
    messages: List[MessageCreate] = Field(..., description="List of messages to send")
    options: Optional[BatchOptions] = Field(default=None, description="Batch processing options")
    
    @validator("messages")
    def validate_messages(cls, v):
        """Validate message list."""
        if not v:
            raise ValueError("Message list cannot be empty")
        if len(v) > 1000:
            raise ValueError("Maximum batch size is 1000 messages")
        return v


class BatchMessageResponse(BaseModel):
    """Schema for batch message response."""
    batch_id: str = Field(..., description="Batch ID for tracking")
    total: int = Field(..., description="Total number of messages in batch")
    processed: int = Field(..., description="Number of messages processed")
    successful: int = Field(..., description="Number of successful messages")
    failed: int = Field(..., description="Number of failed messages")
    status: str = Field(..., description="Overall batch status")
    created_at: datetime = Field(..., description="Batch creation timestamp")
    messages: Optional[List[MessageResponse]] = Field(None, description="List of message responses")
</file>

<file path="app/schemas/user.py">
"""
Pydantic schemas for user-related API operations.
"""
from typing import List, Optional
from datetime import datetime, timezone
from enum import Enum
from pydantic import BaseModel, Field, EmailStr, validator


class UserRole(str, Enum):
    """User role enum."""
    ADMIN = "admin"
    USER = "user"
    API = "api"


class UserBase(BaseModel):
    """Base user schema."""
    email: Optional[EmailStr] = Field(None, description="User email address")
    full_name: Optional[str] = Field(None, description="User's full name")
    is_active: Optional[bool] = Field(True, description="Whether the user is active")
    role: Optional[UserRole] = Field(UserRole.USER, description="User role")


class UserCreate(UserBase):
    """Schema for creating a new user."""
    email: EmailStr = Field(..., description="User email address")
    password: str = Field(..., description="User password")
    
    @validator("password")
    def validate_password(cls, v):
        """Validate password strength."""
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(char.isdigit() for char in v):
            raise ValueError("Password must contain at least one digit")
        if not any(char.isupper() for char in v):
            raise ValueError("Password must contain at least one uppercase letter")
        return v


class UserUpdate(UserBase):
    """Schema for updating a user."""
    password: Optional[str] = Field(None, description="User password")
    
    @validator("password")
    def validate_password(cls, v):
        """Validate password if provided."""
        if v is not None:
            if len(v) < 8:
                raise ValueError("Password must be at least 8 characters long")
            if not any(char.isdigit() for char in v):
                raise ValueError("Password must contain at least one digit")
            if not any(char.isupper() for char in v):
                raise ValueError("Password must contain at least one uppercase letter")
        return v


class User(UserBase):
    """Schema for user response."""
    id: str = Field(..., description="User ID")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    
    class Config:
        """Pydantic config."""
        from_attributes = True


class UserInDB(User):
    """Schema for user in database (with hashed password)."""
    hashed_password: str = Field(..., description="Hashed password")


class Token(BaseModel):
    """Schema for authentication token."""
    access_token: str
    token_type: str = "bearer"
    expires_at: datetime


class TokenData(BaseModel):
    """Schema for token payload."""
    sub: str  # User ID
    exp: Optional[datetime] = None
    role: Optional[str] = None


class APIKey(BaseModel):
    """Schema for API key."""
    id: str = Field(..., description="API key ID")
    key: str = Field(..., description="API key")
    name: str = Field(..., description="API key name")
    user_id: str = Field(..., description="User who owns the API key")
    created_at: datetime = Field(..., description="Creation timestamp")
    expires_at: Optional[datetime] = Field(None, description="Expiration timestamp")
    is_active: bool = Field(True, description="Whether the API key is active")
    last_used_at: Optional[datetime] = Field(None, description="Last usage timestamp")
    permissions: List[str] = Field(default=[], description="List of permissions")
    
    class Config:
        """Pydantic config."""
        from_attributes = True


class APIKeyCreate(BaseModel):
    """Schema for creating a new API key."""
    name: str = Field(..., description="API key name")
    expires_at: Optional[datetime] = Field(None, description="Expiration timestamp")
    permissions: Optional[List[str]] = Field(default=[], description="List of permissions")
</file>

<file path="app/services/event_bus/events.py">
"""
Event type definitions for the event bus.
"""
from enum import Enum, auto
from typing import Dict, Any, Optional
from datetime import datetime, timezone


class EventType(str, Enum):
    """Event types for the event bus."""
    
    # System events
    SYSTEM_STARTUP = "system:startup"
    SYSTEM_SHUTDOWN = "system:shutdown"
    
    # Message events
    MESSAGE_CREATED = "message:created"
    MESSAGE_UPDATED = "message:updated"
    MESSAGE_SENT = "message:sent"
    MESSAGE_DELIVERED = "message:delivered"
    MESSAGE_FAILED = "message:failed"
    MESSAGE_SCHEDULED = "message:scheduled"
    MESSAGE_RETRIED = "message:retried"
    MESSAGE_RETRY_FAILED = "message:retry_failed"
    
    # Batch events
    BATCH_CREATED = "batch:created"
    BATCH_UPDATED = "batch:updated"
    BATCH_COMPLETED = "batch:completed"

    # Campaign events
    CAMPAIGN_CREATED = "campaign:created"
    CAMPAIGN_UPDATED = "campaign:updated"
    CAMPAIGN_STARTED = "campaign:started"
    CAMPAIGN_PAUSED = "campaign:paused"
    CAMPAIGN_COMPLETED = "campaign:completed"
    CAMPAIGN_CANCELLED = "campaign:cancelled"
    CAMPAIGN_FAILED = "campaign:failed"
    
    # SMS Gateway events
    SMS_RECEIVED = "sms:received"
    SMS_SENT = "sms:sent"
    SMS_DELIVERED = "sms:delivered"
    SMS_FAILED = "sms:failed"
    
    # Webhook events
    WEBHOOK_RECEIVED = "webhook:received"
    WEBHOOK_PROCESSED = "webhook:processed"
    
    # User events
    USER_CREATED = "user:created"
    USER_UPDATED = "user:updated"
    USER_DELETED = "user:deleted"
    
    # API events
    API_REQUEST = "api:request"
    API_RESPONSE = "api:response"
    API_ERROR = "api:error"


class Event:
    """
    Base event class.
    
    Contains common event data and helper methods.
    """
    
    def __init__(
        self,
        event_type: EventType,
        data: Dict[str, Any],
        timestamp: Optional[datetime] = None
    ):
        """
        Initialize event.
        
        Args:
            event_type: Event type
            data: Event data
            timestamp: Event timestamp
        """
        self.event_type = event_type
        self.data = data
        self.timestamp = timestamp or datetime.now(timezone.utc)
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert event to dictionary.
        
        Returns:
            Dict: Event data
        """
        return {
            "event_type": self.event_type,
            "data": self.data,
            "timestamp": self.timestamp.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Event":
        """
        Create event from dictionary.
        
        Args:
            data: Event data
            
        Returns:
            Event: Event instance
        """
        event_type = data.get("event_type")
        if isinstance(event_type, str):
            event_type = EventType(event_type)
        
        timestamp = data.get("timestamp")
        if isinstance(timestamp, str):
            timestamp = datetime.fromisoformat(timestamp)
        
        return cls(
            event_type=event_type,
            data=data.get("data", {}),
            timestamp=timestamp
        )


class MessageEvent(Event):
    """
    Message event class.
    
    Contains message-specific event data.
    """
    
    def __init__(
        self,
        event_type: EventType,
        message_id: str,
        user_id: str,
        data: Dict[str, Any],
        timestamp: Optional[datetime] = None
    ):
        """
        Initialize message event.
        
        Args:
            event_type: Event type
            message_id: Message ID
            user_id: User ID
            data: Event data
            timestamp: Event timestamp
        """
        # Add message ID and user ID to data
        data = data.copy()
        data["message_id"] = message_id
        data["user_id"] = user_id
        
        super().__init__(event_type, data, timestamp)
    
    @property
    def message_id(self) -> str:
        """Get message ID."""
        return self.data.get("message_id", "")
    
    @property
    def user_id(self) -> str:
        """Get user ID."""
        return self.data.get("user_id", "")


class WebhookEvent(Event):
    """
    Webhook event class.
    
    Contains webhook-specific event data.
    """
    
    def __init__(
        self,
        event_type: EventType,
        webhook_id: str,
        payload: Dict[str, Any],
        data: Dict[str, Any],
        timestamp: Optional[datetime] = None
    ):
        """
        Initialize webhook event.
        
        Args:
            event_type: Event type
            webhook_id: Webhook ID
            payload: Webhook payload
            data: Event data
            timestamp: Event timestamp
        """
        # Add webhook ID and payload to data
        data = data.copy()
        data["webhook_id"] = webhook_id
        data["payload"] = payload
        
        super().__init__(event_type, data, timestamp)
    
    @property
    def webhook_id(self) -> str:
        """Get webhook ID."""
        return self.data.get("webhook_id", "")
    
    @property
    def payload(self) -> Dict[str, Any]:
        """Get webhook payload."""
        return self.data.get("payload", {})
</file>

<file path="app/services/sms/retry_engine.py">
# app/services/sms/retry_engine.py
import asyncio
import logging
import uuid
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Any, Optional

from app.core.config import settings
from app.db.repositories.messages import MessageRepository
from app.schemas.message import MessageStatus
from app.services.event_bus.events import EventType
from app.services.event_bus.bus import get_event_bus
from app.core.exceptions import SMSGatewayError, RetryableError

logger = logging.getLogger("inboxerr.retry")

class RetryEngine:
    """
    Service for retrying failed messages.
    
    Periodically checks for failed messages and attempts to resend them.
    """
    
    def __init__(self, message_repository: MessageRepository, event_bus: Any, sms_sender: Any):
        """
        Initialize retry engine with required dependencies.
        
        Args:
            message_repository: Repository for message access
            event_bus: Event bus for publishing events
            sms_sender: SMS sender service for resending messages
        """
        self.message_repository = message_repository
        self.event_bus = event_bus
        self.sms_sender = sms_sender
        self._running = False
        self._semaphore = asyncio.Semaphore(5)  # Limit concurrent retries
        
    async def start(self) -> None:
        """Start the retry engine."""
        if self._running:
            return
            
        self._running = True
        logger.info("Starting retry engine")
        
        while self._running:
            try:
                await self._process_retries()
            except Exception as e:
                logger.error(f"Error in retry engine: {e}", exc_info=True)
                
            # Wait before next cycle
            await asyncio.sleep(settings.RETRY_INTERVAL_SECONDS)
            
    async def stop(self) -> None:
        """Stop the retry engine."""
        self._running = False
        logger.info("Retry engine stopped")
    
    async def _process_retries(self) -> None:
        """Process messages pending retry."""
        # Get messages that need retry
        retry_candidates = await self._get_retry_candidates()
        
        if not retry_candidates:
            logger.debug("No messages to retry")
            return
            
        logger.info(f"Found {len(retry_candidates)} messages to retry")
        
        # Process retries with concurrency limit
        tasks = []
        for message in retry_candidates:
            tasks.append(self._retry_message(message))
            
        if tasks:
            # Process retries concurrently but with limit
            for i in range(0, len(tasks), 5):  # Process in chunks of 5
                chunk = tasks[i:i+5]
                await asyncio.gather(*chunk)
                await asyncio.sleep(1)  # Short delay between chunks
    
    async def _get_retry_candidates(self) -> List[Dict[str, Any]]:
        """
        Get messages that are candidates for retry.
        
        Returns:
            List[Dict]: List of messages that should be retried
        """
        # Parameters for retry candidate selection
        now = datetime.now(timezone.utc)
        max_retries = settings.RETRY_MAX_ATTEMPTS
        
        try:
            # Query for messages that:
            # 1. Are in a failed state
            # 2. Have not exceeded max retry attempts
            # 3. Have a retryable error or no error specified
            # 4. Last retry attempt was long enough ago (based on exponential backoff)
            
            # This is a simplified implementation - in production you might want
            # more sophisticated filtering and prioritization
            failed_messages = await self.message_repository.get_retryable_messages(
                max_retries=max_retries,
                limit=50  # Limit number of messages to process in one cycle
            )
            
            # Filter messages based on retry delay (exponential backoff)
            retry_candidates = []
            
            for message in failed_messages:
                # Get retry attempt count (from message metadata or events)
                retry_count = self._get_retry_count(message)
                
                # Calculate backoff delay - 30s, 2m, 8m, 30m, 2h, etc.
                backoff_seconds = 30 * (2 ** retry_count)
                
                # Get timestamp of last attempt
                last_attempt = message.failed_at or message.updated_at
                
                # Check if enough time has passed for retry
                if now - last_attempt > timedelta(seconds=backoff_seconds):
                    retry_candidates.append(message)
            
            return retry_candidates
        
        except Exception as e:
            logger.error(f"Error getting retry candidates: {e}", exc_info=True)
            # Return empty list on error to prevent crashing the retry engine
            return []
    
    
    def _get_retry_count(self, message: Any) -> int:
        """
        Get the retry count for a message.
        
        Args:
            message: Message object
            
        Returns:
            int: Number of retry attempts
        """
        # Check if retry count is in metadata
        meta_data = getattr(message, 'meta_data', {}) or {}
        if isinstance(meta_data, dict) and 'retry_count' in meta_data:
            return meta_data.get('retry_count', 0)
            
        # Fallback - count events of type "retry"
        retry_events = [e for e in getattr(message, 'events', []) 
                       if getattr(e, 'event_type', '') == 'retry']
        return len(retry_events)
    
    async def _retry_message(self, message: Any) -> None:
        """
        Retry sending a message.
        
        Args:
            message: Message to retry
        """
        message_id = message.id
        phone_number = message.phone_number
        message_text = message.message
        custom_id = message.custom_id
        
        # Get current retry count
        retry_count = self._get_retry_count(message)
        
        try:
            logger.info(f"Retrying message {message_id} (attempt {retry_count + 1})")
            
            # Use semaphore to limit concurrent retries
            async with self._semaphore:
                # Reset status to pending for retry
                await self.message_repository.update_message_status(
                    message_id=message_id,
                    status=MessageStatus.PENDING,
                    event_type="retry",
                    data={
                        "retry_count": retry_count + 1,
                        "previous_error": message.reason
                    }
                )
                
                # Update metadata to track retry count
                meta_data = getattr(message, 'meta_data', {}) or {}
                if isinstance(meta_data, dict):
                    meta_data['retry_count'] = retry_count + 1
                    await self.message_repository.update(
                        id=message_id,
                        obj_in={"meta_data": meta_data}
                    )
                
                # Attempt to send again
                result = await self.sms_sender._send_to_gateway(
                    phone_number=phone_number,
                    message_text=message_text,
                    custom_id=custom_id or str(uuid.uuid4())
                )
                
                # Update message status
                await self.message_repository.update_message_status(
                    message_id=message_id,
                    status=result.get("status", MessageStatus.PENDING),
                    event_type="retry_success",
                    gateway_message_id=result.get("gateway_message_id"),
                    data=result
                )
                
                # Publish event
                await self.event_bus.publish(
                    EventType.MESSAGE_RETRIED,
                    {
                        "message_id": message_id,
                        "phone_number": phone_number,
                        "retry_count": retry_count + 1,
                        "status": result.get("status", MessageStatus.PENDING)
                    }
                )
                
                logger.info(f"Successfully retried message {message_id}")
                
        except Exception as e:
            logger.error(f"Error retrying message {message_id}: {e}")
            
            # Update status to failed with incremented retry count
            error_message = str(e)
            is_retryable = isinstance(e, RetryableError)
            
            await self.message_repository.update_message_status(
                message_id=message_id,
                status=MessageStatus.FAILED,
                event_type="retry_failed",
                reason=error_message,
                data={
                    "retry_count": retry_count + 1,
                    "retryable": is_retryable
                }
            )
            
            # Publish event
            await self.event_bus.publish(
                EventType.MESSAGE_RETRY_FAILED,
                {
                    "message_id": message_id,
                    "phone_number": phone_number,
                    "retry_count": retry_count + 1,
                    "error": error_message,
                    "retryable": is_retryable
                }
            )


# Singleton instance
_retry_engine = None

async def get_retry_engine():
    """Get the singleton retry engine instance."""
    global _retry_engine
    
    if _retry_engine is None:
        from app.db.session import get_repository
        from app.db.repositories.messages import MessageRepository
        from app.services.event_bus.bus import get_event_bus
        from app.services.sms.sender import get_sms_sender
        
        message_repository = await get_repository(MessageRepository)
        event_bus = get_event_bus()
        sms_sender = await get_sms_sender()
        
        _retry_engine = RetryEngine(
            message_repository=message_repository,
            event_bus=event_bus,
            sms_sender=sms_sender
        )
        
    return _retry_engine
</file>

<file path="app/services/sms/sender.py">
"""
SMS sender service for interacting with the Android SMS Gateway.
"""
import asyncio
import logging
import uuid
import time
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional, Tuple, Union
from httpx import HTTPStatusError

from app.core.config import settings
from app.core.exceptions import ValidationError, SMSGatewayError, RetryableError, SMSAuthError
from app.utils.phone import validate_phone
from app.db.repositories.messages import MessageRepository
from app.schemas.message import MessageCreate, MessageStatus, BatchMessageRequest, BatchOptions
from app.services.event_bus.events import EventType

# Lazy import of android_sms_gateway to avoid import errors if not installed
try:
    from android_sms_gateway import client, domain
    SMS_GATEWAY_AVAILABLE = True
except ImportError:
    SMS_GATEWAY_AVAILABLE = False


logger = logging.getLogger("inboxerr.sms")


class SMSSender:
    """
    Service for sending SMS messages through the Android SMS Gateway.
    """
    
    def __init__(
        self,
        message_repository: MessageRepository,
        event_bus: Any
    ):
        """
        Initialize SMS sender service.
        
        Args:
            message_repository: Repository for message storage
            event_bus: Event bus for publishing events
        """
        self.message_repository = message_repository
        self.event_bus = event_bus
        self._semaphore = asyncio.Semaphore(10)  # Limit concurrent requests
        self._last_send_time = 0
        
        # Check if gateway client is available
        if not SMS_GATEWAY_AVAILABLE:
            logger.warning("Android SMS Gateway client not installed. SMS sending will be simulated.")
    
    async def send_message(
        self,
        *,
        phone_number: str,
        message_text: str,
        user_id: str,
        scheduled_at: Optional[datetime] = None,
        custom_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        campaign_id: Optional[str] = None,
        priority: int = 0,
        ttl: Optional[int] = None,
        sim_number: Optional[int] = None,
        is_encrypted: bool = False
    ) -> Dict[str, Any]:
        """
        Send a single SMS message.
        
        Args:
            phone_number: Recipient phone number
            message_text: Message content
            user_id: User ID
            scheduled_at: Optional scheduled delivery time
            custom_id: Optional custom ID for tracking
            metadata: Optional additional data
            campaign_id: Optional campaign ID
            priority: Message priority (0-127, 100 bypasses limits)
            ttl: Time-to-live in seconds
            sim_number: SIM card to use (1-3)
            is_encrypted: Whether message is encrypted
            
        Returns:
            Dict: Message details with status
            
        Raises:
            ValidationError: If phone number is invalid
            SMSGatewayError: If there's an error sending the message
        """
        # Validate phone number
        is_valid, formatted_number, error, _ = validate_phone(phone_number)
        if not is_valid:
            raise ValidationError(message=f"Invalid phone number: {error}")
        
        # Generate id to track message in the system.
        custom_id = custom_id or str(uuid.uuid4())

        # Create message in database
        db_message = await self.message_repository.create_message(
            phone_number=formatted_number,
            message_text=message_text,
            user_id=user_id,
            custom_id=custom_id,
            scheduled_at=scheduled_at,
            metadata=metadata or {},
            campaign_id=campaign_id
        )
        
        # If scheduled for future, return message details
        if scheduled_at and scheduled_at > datetime.now(timezone.utc):
            logger.info(f"Message {db_message.id} scheduled for {scheduled_at}")
            
            # Publish event
            await self.event_bus.publish(
                EventType.MESSAGE_SCHEDULED,
                {
                    "message_id": db_message.id,
                    "phone_number": formatted_number,
                    "scheduled_at": scheduled_at.isoformat(),
                    "user_id": user_id
                }
            )
            
            return db_message.dict()
        
        # Otherwise, send immediately
        try:
            result = await self._send_to_gateway(
                phone_number=formatted_number,
                message_text=message_text,
                custom_id=db_message.custom_id,
                priority=priority,
                ttl=ttl,
                sim_number=sim_number,
                is_encrypted=is_encrypted
            )
            
            # Update message status
            await self.message_repository.update_message_status(
                message_id=db_message.id,
                status=result.get("status", MessageStatus.PENDING),
                event_type="gateway_response",
                gateway_message_id=result.get("gateway_message_id"),
                data=result
            )
            
            # Get updated message
            updated_message = await self.message_repository.get_by_id(db_message.id)
            return updated_message.dict()
            
        except Exception as e:
            # Handle error
            error_status = MessageStatus.FAILED
            error_message = str(e)
            logger.error(f"Error sending message {db_message.id}: {error_message}")
            
            # Update message status
            await self.message_repository.update_message_status(
                message_id=db_message.id,
                status=error_status,
                event_type="send_error",
                reason=error_message,
                data={"error": error_message}
            )
            
            # Re-raise as SMSGatewayError
            if isinstance(e, RetryableError):
                raise SMSGatewayError(message=error_message, code="GATEWAY_ERROR", status_code=503)
            else:
                raise SMSGatewayError(message=error_message, code="GATEWAY_ERROR")
    
    async def send_batch(
        self,
        *,
        messages: List[MessageCreate],
        user_id: str,
        options: Optional[BatchOptions] = None,
        campaign_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Send a batch of SMS messages.
        
        Args:
            messages: List of messages to send
            user_id: User ID
            options: Optional batch processing options
            campaign_id: Optional campaign ID
            
        Returns:
            Dict: Batch details with status
            
        Raises:
            ValidationError: If any phone number is invalid
            SMSGatewayError: If there's an error sending the messages
        """
        if not messages:
            raise ValidationError(message="No messages provided")
        
        # Set default options
        if not options:
            options = BatchOptions(
                delay_between_messages=0.3,
                fail_on_first_error=False,
                retry_failed=True
            )
        
        # Create batch in database
        batch = await self.message_repository.create_batch(
            user_id=user_id,
            name=f"Batch {datetime.now(timezone.utc).isoformat()}",
            total=len(messages)
        )
        
        # Process in background
        asyncio.create_task(
            self._process_batch(
                messages=messages,
                user_id=user_id,
                batch_id=batch.id,
                campaign_id=campaign_id,
                options=options
            )
        )
        
        # Return batch details
        return {
            "batch_id": batch.id,
            "total": batch.total,
            "processed": 0,
            "successful": 0,
            "failed": 0,
            "status": batch.status,
            "created_at": batch.created_at
        }
    
    async def _process_batch(
        self,
        *,
        messages: List[MessageCreate],
        user_id: str,
        batch_id: str,
        campaign_id: Optional[str] = None,
        options: BatchOptions
    ) -> None:
        """
        Process a batch of messages in background.
        
        Args:
            messages: List of messages to send
            user_id: User ID
            batch_id: Batch ID
            campaign_id: Optional campaign ID
            options: Batch processing options
        """
        processed = 0
        successful = 0
        failed = 0
        try:
            # Calculate chunk size based on total messages
            # Use smaller chunks for larger batches to avoid overwhelming the system
            total_messages = len(messages)
            if total_messages <= 100:
                chunk_size = 10
            elif total_messages <= 1000:
                chunk_size = 25
            else:
                chunk_size = 50
                
            # Process in chunks for better performance
            for i in range(0, total_messages, chunk_size):
                chunk = messages[i:i+chunk_size]
                
                # Process chunk with concurrent tasks
                tasks = []
                for message in chunk:
                    # Create task for each message
                    task = asyncio.create_task(
                        self._process_single_message(
                            message=message,
                            user_id=user_id,
                            batch_id=batch_id,
                            campaign_id=campaign_id
                        )
                    )
                    tasks.append(task)
                
                # Wait for all tasks to complete
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                # Process results
                for result in results:
                    processed += 1
                    
                    if isinstance(result, Exception):
                        # Failed message
                        failed += 1
                        logger.error(f"Error in batch {batch_id}: {str(result)}")
                        
                        # Stop on first error if configured
                        if options.fail_on_first_error:
                            break
                    else:
                        # Successful message
                        successful += 1
                
                # Update batch progress
                await self.message_repository.update_batch_progress(
                    batch_id=batch_id,
                    increment_processed=len(chunk),
                    increment_successful=sum(1 for r in results if not isinstance(r, Exception)),
                    increment_failed=sum(1 for r in results if isinstance(r, Exception))
                )
                
                # Check if we should stop due to first error
                if options.fail_on_first_error and failed > 0:
                    break
                    
                # Delay between chunks to avoid overwhelming gateway
                if i + chunk_size < total_messages:
                    await asyncio.sleep(options.delay_between_messages * 2)  # Double delay between chunks
            
            # Update batch status
            status = MessageStatus.PROCESSED
            if processed == 0:
                status = MessageStatus.FAILED
            elif failed > 0:
                status = "partial"
            
            await self.message_repository.update_batch_progress(
                batch_id=batch_id,
                status=status
            )
            
            # Publish event
            await self.event_bus.publish(
                EventType.BATCH_COMPLETED,
                {
                    "batch_id": batch_id,
                    "campaign_id": campaign_id,
                    "total": len(messages),
                    "processed": processed,
                    "successful": successful,
                    "failed": failed,
                    "status": status,
                    "user_id": user_id
                }
            )
        except Exception as e:
            logger.error(f"Batch processing crashed: {e}")
            await self.message_repository.session.rollback()

        finally:
            if self.message_repository.session.in_transaction():
                try:
                    await self.message_repository.session.commit()
                except Exception as commit_err:
                    logger.error(f"Commit failed after rollback: {commit_err}")

    
    
    async def _process_single_message(
        self,
        *,
        message: MessageCreate,
        user_id: str,
        batch_id: Optional[str] = None,
        campaign_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Process a single message within a batch.
        
        Args:
            message: Message to send
            user_id: User ID
            batch_id: Optional batch ID
            campaign_id: Optional campaign ID
            
        Returns:
            Dict: Result of message processing
            
        Raises:
            Exception: Any error during processing
        """
        # Build metadata
        metadata = {}
        if batch_id:
            metadata["batch_id"] = batch_id
        if campaign_id:
            metadata["campaign_id"] = campaign_id
            
        # Set priority based on campaign
        # Campaigns get slightly higher priority but still below urgent messages
        priority = 50 if campaign_id else 0
            
        # Send message
        return await self.send_message(
            phone_number=message.phone_number,
            message_text=message.message,
            user_id=user_id,
            scheduled_at=message.scheduled_at,
            custom_id=message.custom_id,
            metadata=metadata,
            campaign_id=campaign_id,
            priority=priority
        )
    
    async def send_messages_bulk(
        self,
        *,
        messages: List[Dict[str, Any]],
        user_id: str,
        campaign_id: Optional[str] = None,
        batch_id: Optional[str] = None,
        chunk_size: int = 50
    ) -> List[Dict[str, Any]]:
        """
        Send multiple messages efficiently in bulk.
        
        Args:
            messages: List of message dictionaries with recipient and content
            user_id: User ID
            campaign_id: Optional campaign ID
            batch_id: Optional batch ID
            chunk_size: Number of messages to process in each chunk
            
        Returns:
            List[Dict]: List of results for each message
        """
        results = []
        
        # Process in chunks
        for i in range(0, len(messages), chunk_size):
            chunk = messages[i:i+chunk_size]
            chunk_results = await self._process_message_chunk(
                messages=chunk,
                user_id=user_id,
                campaign_id=campaign_id,
                batch_id=batch_id
            )
            results.extend(chunk_results)
            
            # Small delay between chunks to prevent overloading
            if i + chunk_size < len(messages):
                await asyncio.sleep(1)
        
        return results
    
    async def _process_message_chunk(
        self, 
        messages: List[Dict[str, Any]],
        user_id: str,
        campaign_id: Optional[str] = None,
        batch_id: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Process a chunk of messages concurrently.
        
        Args:
            messages: List of message dictionaries to process
            user_id: User ID
            campaign_id: Optional campaign ID
            batch_id: Optional batch ID
            
        Returns:
            List[Dict]: Results for each message
        """
        # Create tasks for all messages
        tasks = []
        for msg in messages:
            try:
                # Create database entries first to get IDs
                db_message = await self.message_repository.create_message(
                    phone_number=msg["phone_number"],
                    message_text=msg["message_text"],
                    user_id=user_id,
                    custom_id=msg.get("custom_id"),
                    scheduled_at=msg.get("scheduled_at"),
                    metadata=msg.get("metadata", {}),
                    campaign_id=campaign_id
                )
                
                # Skip if scheduled for the future
                if db_message.scheduled_at and db_message.scheduled_at > datetime.now(timezone.utc):
                    tasks.append(asyncio.create_task(
                        asyncio.sleep(0)  # Dummy task for scheduled messages
                    ))
                    continue
                    
                # Create task to send via gateway
                task = asyncio.create_task(
                    self._send_message_with_error_handling(
                        db_message=db_message,
                        phone_number=msg["phone_number"],
                        message_text=msg["message_text"],
                        priority=msg.get("priority", 0),
                        ttl=msg.get("ttl"),
                        sim_number=msg.get("sim_number"),
                        is_encrypted=msg.get("is_encrypted", False)
                    )
                )
                tasks.append(task)
            
            except Exception as e:
                logger.error(f"Error creating or queuing message: {e}")
                await self.message_repository.session.rollback()
        
        # Wait for all tasks to complete
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            return [r for r in results if not isinstance(r, Exception)]
        
        return []
    
    async def _send_message_with_error_handling(
        self,
        *,
        db_message: Any,
        phone_number: str,
        message_text: str,
        priority: int = 0,
        ttl: Optional[int] = None,
        sim_number: Optional[int] = None,
        is_encrypted: bool = False
    ) -> Dict[str, Any]:
        """
        Send message with error handling and status updates.
        
        Args:
            db_message: Database message object
            phone_number: Recipient phone number
            message_text: Message content
            priority: Message priority
            ttl: Time-to-live in seconds
            sim_number: SIM card to use
            is_encrypted: Whether message is encrypted
            
        Returns:
            Dict: Result of message sending
        """
        try:
            # Send to gateway
            result = await self._send_to_gateway(
                phone_number=phone_number,
                message_text=message_text,
                custom_id=db_message.custom_id,
                priority=priority,
                ttl=ttl,
                sim_number=sim_number,
                is_encrypted=is_encrypted
            )
            
            # Update message status
            await self.message_repository.update_message_status(
                message_id=db_message.id,
                status=result.get("status", MessageStatus.PENDING),
                event_type="gateway_response",
                gateway_message_id=result.get("gateway_message_id"),
                data=result
            )
            
            return result
            
        except Exception as e:
            # Handle error
            error_status = MessageStatus.FAILED
            error_message = str(e)
            logger.error(f"Error sending message {db_message.id}: {error_message}")
            
            # Update message status
            await self.message_repository.update_message_status(
                message_id=db_message.id,
                status=error_status,
                event_type="send_error",
                reason=error_message,
                data={"error": error_message}
            )
            
            # Re-raise to be caught by caller
            raise
    
    async def schedule_batch_from_numbers(
        self,
        *,
        phone_numbers: List[str],
        message_text: str,
        user_id: str,
        scheduled_at: Optional[datetime] = None,
        campaign_id: Optional[str] = None
    ) -> str:
        """
        Schedule a batch of messages from a list of phone numbers.
        
        Args:
            phone_numbers: List of phone numbers
            message_text: Message content
            user_id: User ID
            scheduled_at: Optional scheduled delivery time
            campaign_id: Optional campaign ID
            
        Returns:
            str: Batch ID
            
        Raises:
            ValidationError: If any phone number is invalid
        """
        if not phone_numbers:
            raise ValidationError(message="No phone numbers provided")
        
        # Create messages
        messages = []
        for phone in phone_numbers:
            # Basic validation
            is_valid, formatted_number, error, _ = validate_phone(phone)
            if is_valid:
                messages.append(
                    MessageCreate(
                        phone_number=formatted_number,
                        message=message_text,
                        scheduled_at=scheduled_at,
                        custom_id=str(uuid.uuid4())
                    )
                )
        
        if not messages:
            raise ValidationError(message="No valid phone numbers found")
        
        # Create and process batch
        result = await self.send_batch(
            messages=messages,
            user_id=user_id,
            campaign_id=campaign_id,
            options=BatchOptions(
                delay_between_messages=settings.DELAY_BETWEEN_SMS,
                fail_on_first_error=False,
                retry_failed=True
            )
        )
        
        return result["batch_id"]
    
    async def get_message(self, message_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """
        Get message details.
        
        Args:
            message_id: Message ID or custom ID
            user_id: User ID for authorization
            
        Returns:
            Dict: Message details or None if not found
        """
        # Try to get by ID first
        message = await self.message_repository.get_by_id(message_id)
        
        # If not found, try custom ID
        if not message:
            message = await self.message_repository.get_by_custom_id(message_id)
            
        # If not found, try gateway ID
        if not message:
            message = await self.message_repository.get_by_gateway_id(message_id)
        
        # Check authorization
        if message and str(message.user_id) != str(user_id):
            return None
        
        return message.dict() if message else None
    
    async def list_messages(
        self,
        *,
        filters: Dict[str, Any],
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Dict[str, Any]], int]:
        """
        List messages with filtering and pagination.
        
        Args:
            filters: Filter criteria
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Dict], int]: List of messages and total count
        """
        # Extract user_id from filters
        user_id = filters.pop("user_id", None)
        if not user_id:
            return [], 0
        
        # Get messages
        messages, total = await self.message_repository.list_messages_for_user(
            user_id=user_id,
            status=filters.get("status"),
            phone_number=filters.get("phone_number"),
            from_date=filters.get("from_date"),
            to_date=filters.get("to_date"),
            campaign_id=filters.get("campaign_id"),  # Support filtering by campaign
            skip=skip,
            limit=limit
        )
        
        # Convert to dict
        message_dicts = [message.dict() for message in messages]
        
        return message_dicts, total
    
    async def update_message_status(
        self,
        *,
        message_id: str,
        status: str,
        reason: Optional[str] = None,
        user_id: str
    ) -> Optional[Dict[str, Any]]:
        """
        Update message status.
        
        Args:
            message_id: Message ID
            status: New status
            reason: Reason for status change
            user_id: User ID for authorization
            
        Returns:
            Dict: Updated message or None if not found
        """
        # Get message
        message = await self.message_repository.get_by_id(message_id)
        if not message:
            return None
        
        # Check authorization
        if str(message.user_id) != str(user_id):
            return None
        
        # Update status
        updated = await self.message_repository.update_message_status(
            message_id=message_id,
            status=status,
            event_type="manual_update",
            reason=reason,
            data={"updated_by": user_id}
        )
        
        return updated.dict() if updated else None
    
    async def delete_message(self, message_id: str, user_id: str) -> bool:
        """
        Delete a message.
        
        Args:
            message_id: Message ID
            user_id: User ID for authorization
            
        Returns:
            bool: True if deleted, False otherwise
        """
        # Get message
        message = await self.message_repository.get_by_id(message_id)
        if not message:
            return False
        
        # Check authorization
        if str(message.user_id) != str(user_id):
            return False
        
        # Delete message
        return await self.message_repository.delete(id=message_id)
    
    async def get_task_status(self, task_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """
        Get status of a background task (batch).
        
        Args:
            task_id: Task/batch ID
            user_id: User ID for authorization
            
        Returns:
            Dict: Task status or None if not found
        """
        # Get batch
        batch = await self.message_repository.get_by_id(task_id)
        if not batch:
            return None
        
        # Check authorization
        if str(batch.user_id) != str(user_id):
            return None
        
        # Get message stats
        messages, total = await self.message_repository.get_messages_for_batch(
            batch_id=task_id,
            limit=5  # Just get the first few for preview
        )
        
        # Convert to dict
        message_previews = [message.dict() for message in messages]
        
        return {
            "id": batch.id,
            "status": batch.status,
            "total": batch.total,
            "processed": batch.processed,
            "successful": batch.successful,
            "failed": batch.failed,
            "created_at": batch.created_at,
            "completed_at": batch.completed_at,
            "message_previews": message_previews
        }
    
    async def _send_to_gateway(
        self,
        *,
        phone_number: str,
        message_text: str,
        custom_id: str,
        priority: int = 0,
        ttl: Optional[int] = None,
        sim_number: Optional[int] = None,
        is_encrypted: bool = False
    ) -> Dict[str, Any]:
        """
        Send message to SMS gateway.
        
        Args:
            phone_number: Recipient phone number
            message_text: Message content
            custom_id: Custom ID for tracking (usually our database ID)
            priority: Message priority (0-127, 100 bypasses limits)
            ttl: Time-to-live in seconds
            sim_number: SIM card to use (1-3)
            is_encrypted: Whether message is encrypted
            
        Returns:
            Dict: Gateway response
            
        Raises:
            SMSGatewayError: If there's an error sending the message
            RetryableError: If the error is temporary and can be retried
        """
        # Enforce rate limit (only for non-high-priority messages)
        if priority < 100:
            await self._enforce_rate_limit()
        
        # Check if gateway client is available
        if not SMS_GATEWAY_AVAILABLE:
            # Simulate sending for development
            logger.warning("Simulating SMS send to %s: %s", phone_number, message_text[:30])
            await asyncio.sleep(0.5)  # Simulate API delay
            
            # Return simulated response
            return {
                "status": MessageStatus.SENT,
                "gateway_message_id": f"sim_{uuid.uuid4()}",
                "phone_number": phone_number,
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
        
        # Use semaphore to limit concurrent requests
        async with self._semaphore:
            try:
                # Create client
                async with client.AsyncAPIClient(
                    login=settings.SMS_GATEWAY_LOGIN,
                    password=settings.SMS_GATEWAY_PASSWORD,
                    base_url=settings.SMS_GATEWAY_URL
                ) as sms_client:
                    # Build message with additional parameters
                    message_params = {
                        "id": custom_id,
                        "message": message_text,
                        "phone_numbers": [phone_number],
                        "with_delivery_report": True,
                    }
                    
                    # Add optional parameters if provided
                    if ttl is not None:
                        message_params["ttl"] = ttl
                    if sim_number is not None:
                        message_params["sim_number"] = sim_number
                    if is_encrypted:
                        message_params["is_encrypted"] = True
                    
                    # Create message
                    message = domain.Message(**message_params)
                    
                    # Send message
                    logger.debug(f"Sending to gateway: {phone_number}, message: {message_text[:30]}...")
                    response = await sms_client.send(message)
                    logger.debug(f"Gateway response: {response}")
                    
                    # Check for errors in recipients
                    recipient_state = response.recipients[0] if response.recipients else None
                    if recipient_state and recipient_state.error:
                        raise SMSGatewayError(message=recipient_state.error)
                    
                    # Extract status
                    status = str(response.state.value).lower() if hasattr(response, 'state') else MessageStatus.PENDING
                    gateway_id = getattr(response, 'id', None)
                    
                    # Return result
                    return {
                        "status": status,
                        "gateway_message_id": gateway_id,
                        "phone_number": phone_number,
                        "timestamp": datetime.now(timezone.utc).isoformat()
                    }
            except HTTPStatusError as e:
                if e.response.status_code == 401:
                    logger.error(" Invalid SMS gateway credentials (401 Unauthorized)")
                    raise SMSAuthError()
                raise SMSGatewayError(message=f"SMS gateway error: {str(e)}")

            except Exception as e:
                logger.error(f"Unexpected gateway exception: {type(e).__name__}: {str(e)}")

                if any(k in str(type(e)) for k in ["ConnectionError", "Timeout", "CancelledError"]):
                    raise RetryableError(
                        message=f"Temporary SMS gateway issue: {str(e)}",
                        retry_after=30
                    )

                raise SMSGatewayError(message=f"SMS gateway error: {str(e)}")
    
    async def _enforce_rate_limit(self) -> None:
        """
        Enforce rate limiting for SMS sending.
        
        Adds dynamic delay based on settings.DELAY_BETWEEN_SMS.
        """
        current_time = asyncio.get_event_loop().time()
        elapsed = current_time - self._last_send_time
        remaining_delay = max(0, settings.DELAY_BETWEEN_SMS - elapsed)
        
        if remaining_delay > 0:
            await asyncio.sleep(remaining_delay)
        
        self._last_send_time = asyncio.get_event_loop().time()

    async def send_with_template(
        self,
        *,
        template_id: str,
        phone_number: str,
        variables: Dict[str, str],
        user_id: str,
        scheduled_at: Optional[datetime] = None,
        custom_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Send a message using a template.
        
        Args:
            template_id: Template ID
            phone_number: Recipient phone number
            variables: Dictionary of variable values
            user_id: User ID
            scheduled_at: Optional scheduled delivery time
            custom_id: Optional custom ID for tracking
            
        Returns:
            Dict: Message details with status
            
        Raises:
            ValidationError: If phone number is invalid or template is not found
            SMSGatewayError: If there's an error sending the message
        """
        # Get template repository
        from app.db.session import get_repository
        from app.db.repositories.templates import TemplateRepository
        
        template_repo = await get_repository(TemplateRepository)
        
        # Get template
        template = await template_repo.get_by_id(template_id)
        if not template:
            raise ValidationError(message=f"Template {template_id} not found")
        
        # Check authorization
        if template.user_id != user_id:
            raise ValidationError(message="Not authorized to use this template")
        
        # Apply template
        message_text = await template_repo.apply_template(
            template_id=template_id,
            variables=variables
        )
        
        # Check for missing variables
        import re
        missing_vars = re.findall(r"{{([a-zA-Z0-9_]+)}}", message_text)
        if missing_vars:
            raise ValidationError(
                message="Missing template variables", 
                details={"missing_variables": missing_vars}
            )
        
        # Send message
        metadata = {
            "template_id": template_id,
            "template_variables": variables
        }
        
        return await self.send_message(
            phone_number=phone_number,
            message_text=message_text,
            user_id=user_id,
            scheduled_at=scheduled_at,
            custom_id=custom_id,
            metadata=metadata
        )

    async def send_batch_with_template(
        self,
        *,
        template_id: str,
        recipients: List[Dict[str, Any]],
        user_id: str,
        scheduled_at: Optional[datetime] = None,
        options: Optional[BatchOptions] = None
    ) -> Dict[str, Any]:
        """
        Send a batch of messages using a template.
        
        Args:
            template_id: Template ID
            recipients: List of recipients with their variables
                    Each recipient should have 'phone_number' and 'variables' keys
            user_id: User ID
            scheduled_at: Optional scheduled delivery time
            options: Optional batch processing options
            
        Returns:
            Dict: Batch details with status
            
        Raises:
            ValidationError: If template is not found or recipients format is invalid
            SMSGatewayError: If there's an error sending the messages
        """
        # Get template repository
        from app.db.session import get_repository
        from app.db.repositories.templates import TemplateRepository
        
        template_repo = await get_repository(TemplateRepository)
        
        # Get template
        template = await template_repo.get_by_id(template_id)
        if not template:
            raise ValidationError(message=f"Template {template_id} not found")
        
        # Check authorization
        if template.user_id != user_id:
            raise ValidationError(message="Not authorized to use this template")
        
        # Validate recipients format
        for idx, recipient in enumerate(recipients):
            if "phone_number" not in recipient:
                raise ValidationError(message=f"Recipient at index {idx} is missing 'phone_number'")
            if "variables" not in recipient:
                raise ValidationError(message=f"Recipient at index {idx} is missing 'variables'")
        
        # Create messages for each recipient
        messages = []
        for recipient in recipients:
            # Apply template for each recipient
            message_text = await template_repo.apply_template(
                template_id=template_id,
                variables=recipient["variables"]
            )
            
            # Check for missing variables
            import re
            missing_vars = re.findall(r"{{([a-zA-Z0-9_]+)}}", message_text)
            if missing_vars:
                # Skip this recipient but continue with others
                continue
            
            # Create message
            messages.append(
                MessageCreate(
                    phone_number=recipient["phone_number"],
                    message=message_text,
                    scheduled_at=scheduled_at,
                    custom_id=recipient.get("custom_id")
                )
            )
        
        if not messages:
            raise ValidationError(message="No valid recipients found after applying templates")
        
        # Create batch metadata
        batch_metadata = {
            "template_id": template_id,
            "recipients_count": len(recipients),
            "messages_count": len(messages)
        }
        
        # Use standard batch sending
        batch_result = await self.send_batch(
            messages=messages,
            user_id=user_id,
            options=options
        )
        
        # Add template info to result
        batch_result["template_id"] = template_id
        batch_result["template_name"] = template.name
        
        return batch_result

# Dependency injection function
async def get_sms_sender():
    """Get SMS sender service instance."""
    from app.db.session import get_repository
    from app.db.repositories.messages import MessageRepository
    from app.services.event_bus.bus import get_event_bus
    
    message_repository = await get_repository(MessageRepository)
    event_bus = get_event_bus()
    
    return SMSSender(message_repository, event_bus)
</file>

<file path="app/services/webhooks/manager.py">
# app/services/webhooks/manager.py
import logging
import hmac
import hashlib
import time
import json
from typing import Dict, Any, Optional, List, Tuple
import httpx
from fastapi.encoders import jsonable_encoder
from datetime import datetime, timezone 

from app.core.config import settings
from app.core.exceptions import SMSGatewayError
from app.db.repositories.messages import MessageRepository
from app.db.repositories.webhooks import WebhookRepository
from app.schemas.message import MessageStatus
from app.services.event_bus.bus import get_event_bus
from app.services.event_bus.events import EventType
from app.services.webhooks.models import (
    WebhookPayload, SmsReceivedPayload, SmsSentPayload, 
    SmsDeliveredPayload, SmsFailedPayload, SystemPingPayload
)

logger = logging.getLogger("inboxerr.webhooks")

# Track registered webhooks
_registered_webhooks: Dict[str, str] = {}  # event_type -> webhook_id
_initialized = False

async def initialize_webhook_manager() -> None:
    """Initialize the webhook manager and register with SMS Gateway."""
    global _initialized
    
    if _initialized:
        return
        
    logger.info("Initializing webhook manager")
    
    # Register webhooks for each event type
    events_to_register = [
        "sms:sent", 
        "sms:delivered", 
        "sms:failed"
    ]
    
    for event_type in events_to_register:
        webhook_id = await register_webhook_with_gateway(event_type)
        if webhook_id:
            _registered_webhooks[event_type] = webhook_id
    
    _initialized = True
    logger.info(f"Webhook manager initialized, registered webhooks: {len(_registered_webhooks)}")

async def shutdown_webhook_manager() -> None:
    """Clean up webhook manager resources."""
    logger.info("Shutting down webhook manager")
    
    # Unregister all webhooks
    for event_type, webhook_id in _registered_webhooks.items():
        await unregister_webhook_from_gateway(webhook_id)
    
    _registered_webhooks.clear()
    logger.info("Webhook manager shutdown complete")

async def register_webhook_with_gateway(event_type: str) -> Optional[str]:
    """
    Register a webhook for a specific event type.
    
    Args:
        event_type: Event type to register for
        
    Returns:
        str: Webhook ID if registration successful
    """
    if not settings.SMS_GATEWAY_URL or not settings.SMS_GATEWAY_LOGIN or not settings.SMS_GATEWAY_PASSWORD:
        logger.warning("SMS Gateway credentials not configured, skipping webhook registration")
        return None
    
    # Webhook URL for the Gateway to call
    webhook_url = f"{settings.API_BASE_URL}{settings.API_PREFIX}/webhooks/gateway"
    
    try:
        # Create httpx client with authentication
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{settings.SMS_GATEWAY_URL}/webhooks",
                auth=(settings.SMS_GATEWAY_LOGIN, settings.SMS_GATEWAY_PASSWORD),
                json={
                    "id": f"inboxerr-{event_type}",  # Custom ID for tracking
                    "url": webhook_url,
                    "event": event_type
                },
                timeout=10.0
            )
            
            if response.status_code in (200, 201):
                webhook_data = response.json()
                webhook_id = webhook_data.get("id")
                logger.info(f"Successfully registered webhook for {event_type}: {webhook_id}")
                return webhook_id
            else:
                logger.error(f"Failed to register webhook for {event_type}: {response.status_code} - {response.text}")
                return None
                
    except Exception as e:
        logger.error(f"Error registering webhook for {event_type}: {e}")
        return None

async def unregister_webhook_from_gateway(webhook_id: str) -> bool:
    """
    Unregister a webhook from SMS Gateway.
    
    Args:
        webhook_id: Webhook ID
        
    Returns:
        bool: True if unregistration successful
    """
    if not settings.SMS_GATEWAY_URL or not settings.SMS_GATEWAY_LOGIN or not settings.SMS_GATEWAY_PASSWORD:
        logger.warning("SMS Gateway credentials not configured, skipping webhook unregistration")
        return False
    
    try:
        # Create httpx client with authentication
        async with httpx.AsyncClient() as client:
            response = await client.delete(
                f"{settings.SMS_GATEWAY_URL}/webhooks/{webhook_id}",
                auth=(settings.SMS_GATEWAY_LOGIN, settings.SMS_GATEWAY_PASSWORD),
                timeout=10.0
            )
            
            if response.status_code in (200, 204):
                logger.info(f"Successfully unregistered webhook: {webhook_id}")
                return True
            else:
                logger.error(f"Failed to unregister webhook: {response.status_code} - {response.text}")
                return False
                
    except Exception as e:
        logger.error(f"Error unregistering webhook: {e}")
        return False

async def process_gateway_webhook(raw_body: bytes, headers: Dict[str, str]) -> Tuple[bool, Dict[str, Any]]:
    """
    Process a webhook received from the SMS Gateway with enhanced error handling.
    
    Args:
        raw_body: Raw request body
        headers: Request headers
        
    Returns:
        Tuple[bool, Dict]: (success, processed_data)
    """
    # Decode raw body for payload processing
    try:
        payload_str = raw_body.decode('utf-8')
    except UnicodeDecodeError:
        logger.error("Failed to decode webhook payload")
        return False, {"error": "Invalid payload encoding"}
    
    try:
        # Parse JSON
        try:
            payload_dict = json.loads(payload_str)
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in webhook: {e}")
            return False, {"error": "Invalid JSON payload", "details": str(e)}
        
        # Verify webhook signature if enabled
        if settings.WEBHOOK_SIGNATURE_KEY:
            signature_valid, signature_error = verify_webhook_signature(payload_str, headers)
            if not signature_valid:
                logger.warning(f"Invalid webhook signature: {signature_error}")
                return False, {"error": "Invalid signature", "details": signature_error}
        
        # Validate basic payload structure
        try:
            base_payload = WebhookPayload(**payload_dict)
        except Exception as e:
            logger.error(f"Invalid webhook payload structure: {e}")
            return False, {"error": "Invalid payload structure", "details": str(e)}
        
        event_type = base_payload.event
        gateway_id = base_payload.id
        
        logger.info(f"Processing webhook event: {event_type}, gateway ID: {gateway_id}")
        
        # Record the incoming webhook event in database
        try:
            from app.db.session import get_repository
            webhook_repo = await get_repository(WebhookRepository)
            
            # Create webhook event record
            await webhook_repo.create_webhook_event(
                event_type=event_type,
                payload=payload_dict,
                phone_number=payload_dict.get("payload", {}).get("phoneNumber"),
                gateway_message_id=gateway_id
            )
        except Exception as e:
            # Log error but continue processing - this is just for auditing
            logger.error(f"Error recording webhook event: {e}")
        
        # Process based on event type
        try:
            if event_type == "sms:received":
                payload = SmsReceivedPayload(**payload_dict["payload"])
                result = await process_sms_received(base_payload, payload)
            elif event_type == "sms:sent":
                payload = SmsSentPayload(**payload_dict["payload"])
                result = await process_sms_sent(base_payload, payload)
            elif event_type == "sms:delivered":
                payload = SmsDeliveredPayload(**payload_dict["payload"])
                result = await process_sms_delivered(base_payload, payload)
            elif event_type == "sms:failed":
                payload = SmsFailedPayload(**payload_dict["payload"])
                result = await process_sms_failed(base_payload, payload)
            elif event_type == "system:ping":
                payload = SystemPingPayload(**payload_dict["payload"])
                result = await process_system_ping(base_payload, payload)
            else:
                logger.warning(f"Unknown webhook event type: {event_type}")
                return False, {"error": "Unknown event type", "event_type": event_type}
                
            # Log successful processing
            logger.info(f"Successfully processed webhook event: {event_type}, gateway ID: {gateway_id}")
            
            # Mark event as processed if we created one
            try:
                webhook_events = await webhook_repo.get_unprocessed_events(limit=10)
                for event in webhook_events:
                    if event.gateway_message_id == gateway_id:
                        await webhook_repo.mark_event_processed(event_id=event.id)
            except Exception as e:
                logger.error(f"Error marking webhook event as processed: {e}")
            
            return True, result
            
        except Exception as e:
            logger.error(f"Error processing webhook event {event_type}: {e}", exc_info=True)
            
            # Try to handle specific event processing errors gracefully
            error_details = {"error_type": type(e).__name__, "gateway_id": gateway_id}
            
            # Publish error event
            try:
                from app.services.event_bus.bus import get_event_bus
                from app.services.event_bus.events import EventType
                
                event_bus = get_event_bus()
                await event_bus.publish(
                    EventType.WEBHOOK_PROCESSED,
                    {
                        "success": False,
                        "event_type": event_type,
                        "gateway_id": gateway_id,
                        "error": str(e),
                        "timestamp": datetime.now(timezone.utc).isoformat()
                    }
                )
            except Exception as publish_error:
                logger.error(f"Error publishing webhook error event: {publish_error}")
                
            return False, {"error": f"Error processing {event_type} event", "details": str(e), **error_details}
            
    except Exception as e:
        logger.error(f"Unexpected error in webhook processing: {e}", exc_info=True)
        return False, {"error": "Unexpected error", "details": str(e)}


def verify_webhook_signature(payload: str, headers: Dict[str, str]) -> Tuple[bool, Optional[str]]:
    """
    Verify webhook signature from SMS Gateway with detailed error reporting.
    
    Args:
        payload: Webhook payload string
        headers: Request headers
        
    Returns:
        Tuple[bool, Optional[str]]: (is_valid, error_message_or_none)
    """
    signature = headers.get("X-Signature")
    timestamp = headers.get("X-Timestamp")
    
    if not signature:
        return False, "Missing X-Signature header"
    
    if not timestamp:
        return False, "Missing X-Timestamp header"
    
    # Verify timestamp is recent (within tolerance)
    try:
        ts = int(timestamp)
        current_time = int(time.time())
        if abs(current_time - ts) > settings.WEBHOOK_TIMESTAMP_TOLERANCE:
            return False, f"Timestamp too old: {timestamp} (current: {current_time})"
    except (ValueError, TypeError):
        return False, f"Invalid timestamp format: {timestamp}"
    
    # Calculate expected signature
    message = (payload + timestamp).encode()
    expected_signature = hmac.new(
        settings.WEBHOOK_SIGNATURE_KEY.encode(),
        message,
        hashlib.sha256
    ).hexdigest()
    
    # Compare signatures (constant-time comparison)
    is_valid = hmac.compare_digest(expected_signature, signature)
    
    return is_valid, None if is_valid else "Signature mismatch"

def verify_webhook_signature(payload: str, headers: Dict[str, str]) -> bool:
    """
    Verify webhook signature from SMS Gateway.
    
    Args:
        payload: Webhook payload string
        headers: Request headers
        
    Returns:
        bool: True if signature is valid
    """
    signature = headers.get("X-Signature")
    timestamp = headers.get("X-Timestamp")
    
    if not signature or not timestamp:
        logger.warning("Missing signature headers")
        return False
    
    # Verify timestamp is recent (within tolerance)
    try:
        ts = int(timestamp)
        current_time = int(time.time())
        if abs(current_time - ts) > settings.WEBHOOK_TIMESTAMP_TOLERANCE:
            logger.warning(f"Webhook timestamp too old: {timestamp}")
            return False
    except (ValueError, TypeError):
        logger.warning(f"Invalid timestamp: {timestamp}")
        return False
    
    # Calculate expected signature
    message = (payload + timestamp).encode()
    expected_signature = hmac.new(
        settings.WEBHOOK_SIGNATURE_KEY.encode(),
        message,
        hashlib.sha256
    ).hexdigest()
    
    # Compare signatures (constant-time comparison)
    return hmac.compare_digest(expected_signature, signature)

async def process_sms_received(base_payload: WebhookPayload, payload: SmsReceivedPayload) -> Dict[str, Any]:
    """Process SMS received event."""
    # For inbound messages - not the main focus for now
    logger.info(f"Received SMS: {payload.phone_number} -> '{payload.message}'")
    
    # Publish event for other components
    event_bus = get_event_bus()
    await event_bus.publish(
        EventType.SMS_RECEIVED,
        {
            "gateway_id": base_payload.id,
            "device_id": base_payload.device_id,
            "phone_number": payload.phone_number,
            "message": payload.message,
            "timestamp": payload.received_at.isoformat()
        }
    )
    
    return {
        "status": "processed",
        "event": "sms:received",
        "phone_number": payload.phone_number
    }

async def process_sms_sent(base_payload: WebhookPayload, payload: SmsSentPayload) -> Dict[str, Any]:
    """Process SMS sent event."""
    logger.info(f"SMS sent to {payload.phone_number}, gateway ID: {base_payload.id}")
    
    # Get message repository
    from app.db.session import get_repository
    message_repo = await get_repository(MessageRepository)
    
    # Extract gateway message ID
    gateway_id = base_payload.id
    
    # Find message by gateway ID
    message = await message_repo.get_by_gateway_id(gateway_id)
    if not message:
        # This could be normal if we didn't originate this message
        logger.info(f"No matching message found for gateway ID: {gateway_id}")
        return {
            "status": "acknowledged",
            "event": "sms:sent",
            "message_found": False
        }
    
    # Update message status
    updated_message = await message_repo.update_message_status(
        message_id=message.id,
        status=MessageStatus.SENT,
        event_type="webhook",
        gateway_message_id=gateway_id,
        data=jsonable_encoder(base_payload)
    )
    
    if not updated_message:
        logger.warning(f"Failed to update message status for ID: {message.id}")
        return {
            "status": "error",
            "event": "sms:sent",
            "message_id": message.id,
            "error": "Failed to update message status"
        }
    
    # Publish event
    event_bus = get_event_bus()
    await event_bus.publish(
        EventType.MESSAGE_SENT,
        {
            "message_id": message.id,
            "gateway_id": gateway_id,
            "phone_number": payload.phone_number,
            "user_id": message.user_id,
            "timestamp": payload.sent_at.isoformat()
        }
    )
    
    return {
        "status": "processed",
        "event": "sms:sent",
        "message_id": message.id,
        "phone_number": payload.phone_number
    }

async def process_sms_delivered(base_payload: WebhookPayload, payload: SmsDeliveredPayload) -> Dict[str, Any]:
    """Process SMS delivered event."""
    logger.info(f"SMS delivered to {payload.phone_number}, gateway ID: {base_payload.id}")
    
    # Get message repository
    from app.db.session import get_repository
    message_repo = await get_repository(MessageRepository)
    
    # Extract gateway message ID
    gateway_id = base_payload.id
    
    # Find message by gateway ID
    message = await message_repo.get_by_gateway_id(gateway_id)
    if not message:
        logger.info(f"No matching message found for gateway ID: {gateway_id}")
        return {
            "status": "acknowledged",
            "event": "sms:delivered",
            "message_found": False
        }
    
    # Update message status
    updated_message = await message_repo.update_message_status(
        message_id=message.id,
        status=MessageStatus.DELIVERED,
        event_type="webhook",
        gateway_message_id=gateway_id,
        data=jsonable_encoder(base_payload)
    )
    
    if not updated_message:
        logger.warning(f"Failed to update message status for ID: {message.id}")
        return {
            "status": "error",
            "event": "sms:delivered",
            "message_id": message.id,
            "error": "Failed to update message status"
        }
    
    # Publish event
    event_bus = get_event_bus()
    await event_bus.publish(
        EventType.MESSAGE_DELIVERED,
        {
            "message_id": message.id,
            "gateway_id": gateway_id,
            "phone_number": payload.phone_number,
            "user_id": message.user_id,
            "timestamp": payload.delivered_at.isoformat()
        }
    )
    
    return {
        "status": "processed",
        "event": "sms:delivered",
        "message_id": message.id,
        "phone_number": payload.phone_number
    }

async def process_sms_failed(base_payload: WebhookPayload, payload: SmsFailedPayload) -> Dict[str, Any]:
    """Process SMS failed event."""
    logger.info(f"SMS failed for {payload.phone_number}, reason: {payload.reason}, gateway ID: {base_payload.id}")
    
    # Get message repository
    from app.db.session import get_repository
    message_repo = await get_repository(MessageRepository)
    
    # Extract gateway message ID and failure reason
    gateway_id = base_payload.id
    reason = payload.reason
    
    # Find message by gateway ID
    message = await message_repo.get_by_gateway_id(gateway_id)
    if not message:
        logger.info(f"No matching message found for gateway ID: {gateway_id}")
        return {
            "status": "acknowledged",
            "event": "sms:failed",
            "message_found": False
        }
    
    # Update message status
    updated_message = await message_repo.update_message_status(
        message_id=message.id,
        status=MessageStatus.FAILED,
        event_type="webhook",
        reason=reason,
        gateway_message_id=gateway_id,
        data=jsonable_encoder(base_payload)
    )
    
    if not updated_message:
        logger.warning(f"Failed to update message status for ID: {message.id}")
        return {
            "status": "error",
            "event": "sms:failed",
            "message_id": message.id,
            "error": "Failed to update message status"
        }
    
    # Publish event
    event_bus = get_event_bus()
    await event_bus.publish(
        EventType.MESSAGE_FAILED,
        {
            "message_id": message.id,
            "gateway_id": gateway_id,
            "phone_number": payload.phone_number,
            "user_id": message.user_id,
            "reason": reason,
            "timestamp": payload.failed_at.isoformat()
        }
    )
    
    return {
        "status": "processed",
        "event": "sms:failed",
        "message_id": message.id,
        "phone_number": payload.phone_number,
        "reason": reason
    }

async def process_system_ping(base_payload: WebhookPayload, payload: SystemPingPayload) -> Dict[str, Any]:
    """Process system ping event."""
    logger.info(f"System ping received from device: {base_payload.device_id}")
    
    # Simple acknowledgment
    return {
        "status": "acknowledged",
        "event": "system:ping",
        "device_id": base_payload.device_id
    }

async def fetch_registered_webhooks_from_gateway() -> List[Dict[str, Any]]:
    """
    Fetch registered webhooks from the SMS Gateway.
    Returns a list of registered webhooks or raises an error.
    """
    if not settings.SMS_GATEWAY_URL or not settings.SMS_GATEWAY_LOGIN or not settings.SMS_GATEWAY_PASSWORD:
        raise SMSGatewayError("SMS Gateway credentials not configured", code="SMS_GATEWAY_CONFIG_MISSING")

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{settings.SMS_GATEWAY_URL}/webhooks",
                auth=(settings.SMS_GATEWAY_LOGIN, settings.SMS_GATEWAY_PASSWORD),
                timeout=10.0
            )
            response.raise_for_status()
            return response.json()
    except Exception as e:
        logger.error(f"Error fetching registered webhooks: {e}")
        raise
</file>

<file path="README.md">
# Inboxerr Backend

API backend for SMS management and delivery.

## Features

-  Send individual and batch SMS messages
-  Track message delivery status
-  Import contacts from CSV
-  Scheduled message delivery
-  Webhook integration for real-time updates
-  User authentication and API key management
-  Message templates
-  Comprehensive retry handling
-  Event-driven architecture

## Technology Stack

- **Framework**: FastAPI
- **Database**: PostgreSQL with SQLAlchemy (async)
- **Authentication**: JWT and API keys
- **Containerization**: Docker & Docker Compose
- **API Documentation**: OpenAPI/Swagger
- **Testing**: pytest
- **SMS Gateway Integration**: Android SMS Gateway

## Getting Started

### Prerequisites

- Docker and Docker Compose
- Python 3.10+
- Android SMS Gateway credentials

### Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/inboxerr-backend.git
   cd inboxerr-backend
   ```

2. Copy the example environment file:
   ```bash
   cp .env.example .env
   ```
   
3. Update the `.env` file with your configuration:
   ```
   SMS_GATEWAY_URL=https://endpointnumber1.work.gd/api/3rdparty/v1
   SMS_GATEWAY_LOGIN=your_login
   SMS_GATEWAY_PASSWORD=your_password
   SECRET_KEY=your_secret_key
   ```

4. Start the application with Docker Compose:
   ```bash
   docker-compose up -d
   ```

5. Run database migrations:
   ```bash
   docker-compose exec api alembic upgrade head
   ```

6. Access the API at `http://localhost:8000/api/docs`

### Development Setup

For local development without Docker:

1. Create a virtual environment:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   pip install -r requirements-dev.txt
   ```

3. Set up environment variables:
   ```bash
   export DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/inboxerr
   export SMS_GATEWAY_URL=https://endpointnumber1.work.gd/api/3rdparty/v1
   export SMS_GATEWAY_LOGIN=your_login
   export SMS_GATEWAY_PASSWORD=your_password
   ```

4. Run the application:
   ```bash
   uvicorn app.main:app --reload
   ```

## API Endpoints

### Authentication

- `POST /api/v1/auth/token` - Get access token
- `POST /api/v1/auth/register` - Register new user
- `GET /api/v1/auth/me` - Get current user info
- `POST /api/v1/auth/keys` - Create API key
- `GET /api/v1/auth/keys` - List API keys

### Messages

- `POST /api/v1/messages/send` - Send a single message
- `POST /api/v1/messages/batch` - Send batch of messages
- `POST /api/v1/messages/import` - Import contacts and send messages
- `GET /api/v1/messages/{message_id}` - Get message details
- `GET /api/v1/messages` - List messages
- `PUT /api/v1/messages/{message_id}/status` - Update message status
- `DELETE /api/v1/messages/{message_id}` - Delete message

### Webhooks

- `GET /api/v1/webhooks` - List webhooks
- `POST /api/v1/webhooks` - Register webhook
- `DELETE /api/v1/webhooks/{webhook_id}` - Delete webhook
- `GET /api/v1/webhooks/logs` - Get webhook delivery logs

## Project Structure

```
/inboxerr-backend/

 /app/                      # Application package
    __init__.py            # Package initializer
    main.py                # FastAPI application entry point
   
    /api/                  # API endpoints and routing
       __init__.py
       router.py          # Main API router
       /v1/               # API version 1
          __init__.py
          endpoints/     # API endpoints by resource
             __init__.py
             auth.py    # Authentication endpoints
             messages.py # SMS message endpoints
             webhooks.py # Webhook endpoints
             metrics.py  # Metrics and reporting endpoints
          dependencies.py # API-specific dependencies
   
    /core/                 # Core application components
       __init__.py
       config.py          # Application configuration
       security.py        # Security utilities (auth, encryption)
       events.py          # Event handlers for application lifecycle
       exceptions.py      # Custom exception classes
   
    /db/                   # Database related code
       __init__.py
       base.py            # Base DB session setup
       session.py         # DB session management
       repositories/      # Repository pattern implementations
           __init__.py
           base.py        # Base repository class
           messages.py    # Message repository
           users.py       # User repository
   
    /models/               # Database models
       __init__.py
       base.py            # Base model class
       message.py         # SMS message model
       user.py            # User model
       webhook.py         # Webhook model
   
    /schemas/              # Pydantic schemas for API
       __init__.py
       base.py            # Base schema
       message.py         # Message schemas
       user.py            # User schemas
       webhook.py         # Webhook schemas
       metrics.py         # Metrics schemas
   
    /services/             # Business logic services
       __init__.py
       sms/               # SMS related services
          __init__.py
          sender.py      # SMS sender implementation
          validator.py   # Phone/message validation
          gateway.py     # SMS gateway client
      
       event_bus/         # Event management
          __init__.py
          bus.py         # Event bus implementation
          events.py      # Event definitions
          handlers/      # Event handlers
              __init__.py
              message_handlers.py
              system_handlers.py
      
       webhooks/          # Webhook handling
          __init__.py
          handler.py     # Webhook processor
          manager.py     # Webhook registration/management
      
       metrics/           # Metrics collection
           __init__.py
           collector.py   # Metrics collector
   
    /utils/                # Utility functions and helpers
        __init__.py
        phone.py           # Phone number utilities
        logging.py         # Logging configuration
        pagination.py      # Pagination utilities

 /alembic/                  # Database migrations
    env.py                 # Alembic environment
    README                 # Alembic readme
    script.py.mako         # Migration script template
    /versions/             # Migration scripts

 /tests/                    # Test suite
    __init__.py
    conftest.py            # Test configuration and fixtures
    /unit/                 # Unit tests
       __init__.py
       /services/         # Tests for services
       /api/              # Tests for API endpoints
    /integration/          # Integration tests
        __init__.py
        /api/              # API integration tests

 /scripts/                  # Utility scripts
    seed_db.py             # Database seeding script
    generate_keys.py       # Generate security keys

 .env.example               # Example environment variables
 .gitignore                 # Git ignore file
 docker-compose.yml         # Docker Compose configuration
 Dockerfile                 # Docker build configuration
 pyproject.toml             # Python project metadata
 requirements.txt           # Python dependencies
 requirements-dev.txt       # Development dependencies
 README.md                  # Project documentation
```

## Usage Examples

### Sending a Single SMS

```python
import requests
import json

url = "http://localhost:8000/api/v1/messages/send"
headers = {
    "Authorization": "Bearer YOUR_ACCESS_TOKEN",
    "Content-Type": "application/json"
}
data = {
    "phone_number": "+1234567890",
    "message": "Hello from Inboxerr!"
}

response = requests.post(url, headers=headers, data=json.dumps(data))
print(response.json())
```

### Importing Contacts from CSV

```python
import requests

url = "http://localhost:8000/api/v1/messages/import"
headers = {
    "Authorization": "Bearer YOUR_ACCESS_TOKEN"
}
files = {
    "file": open("contacts.csv", "rb")
}
data = {
    "message_template": "Hello {{name}}, this is a test message!"
}

response = requests.post(url, headers=headers, files=files, data=data)
print(response.json())
```

# Inboxerr API Updates

## Message Template System

The Inboxerr API now includes a robust Message Template System, allowing you to:

- Create reusable templates with variable placeholders
- Apply variables to templates and preview the results
- Send messages using templates with personalized data
- Manage templates (create, update, delete, list)

### Getting Started with Templates

1. **Create a new template**:
   ```bash
   curl -X POST "http://localhost:8000/api/v1/templates" \
     -H "Authorization: Bearer YOUR_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "name": "Welcome Template",
       "content": "Hello {{name}}, welcome to our service!",
       "description": "Welcome message for new users"
     }'
   ```

2. **Send a message using a template**:
   ```bash
   curl -X POST "http://localhost:8000/api/v1/templates/send" \
     -H "Authorization: Bearer YOUR_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "template_id": "YOUR_TEMPLATE_ID",
       "phone_number": "+1234567890",
       "variables": {
         "name": "John"
       }
     }'
   ```

See the full [Message Template System User Guide](path/to/message-template-system-user-guide.md) for more details.

## Database Management

We've added tools to simplify database migration and setup:

### Generating Migrations

To generate a new migration after changing your models:

```bash
python scripts/generate_migration.py "Description of your changes"
```

### Setting Up a Test Database

To set up a test database with sample data:

```bash
python scripts/setup_test_db.py
```

This will:
1. Create a test database if it doesn't exist
2. Run all migrations
3. Create a test user and sample templates

Test user credentials:
- Email: test@example.com
- Password: Test1234!

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
</file>

<file path="tests/conftest.py">
import asyncio
import os
from datetime import datetime
from collections.abc import AsyncGenerator

import pytest
import pytest_asyncio
from httpx import AsyncClient
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from app.main import app
from app.db.repositories.users import UserRepository
from app.db.repositories.templates import TemplateRepository
from app.core.security import get_password_hash
from app.models import base as models
from app.schemas.user import User
from app.api.v1 import dependencies
from app.models.user import User as UserModel


# Use test DB from env or fallback to SQLite
TEST_DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///:memory:")
async_engine = create_async_engine(TEST_DATABASE_URL, echo=False, future=True)
async_session_factory = sessionmaker(async_engine, class_=AsyncSession, expire_on_commit=False)

TEST_USER = {
    "email": "test@example.com",
    "password": "Test1234!",
    "full_name": "Test User",
    "role": "user"
}

TEST_TEMPLATES = [
    {
        "name": "Welcome Message",
        "content": "Hi {{name}}, welcome to our service! We're glad you've joined us.",
        "description": "Template for welcoming new users"
    },
    {
        "name": "OTP Verification",
        "content": "Your verification code is {{code}}. It will expire in {{minutes}} minutes.",
        "description": "Template for sending OTP codes"
    },
    {
        "name": "Appointment Reminder",
        "content": "Hi {{name}}, this is a reminder for your appointment on {{date}} at {{time}}. Reply YES to confirm or call {{phone}} to reschedule.",
        "description": "Template for appointment reminders"
    }
]

@pytest_asyncio.fixture(autouse=True)
def override_auth():
    def fake_user():
        return User(
            id="test-user-id",
            email="test@example.com",
            is_active=True,
            is_superuser=False,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
    app.dependency_overrides[dependencies.get_current_user] = lambda: fake_user()
    yield
    app.dependency_overrides.clear()

@pytest.fixture(scope="session", autouse=True)
def event_loop():
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest_asyncio.fixture(scope="session", autouse=True)
async def initialize_test_db():
    print("  Initializing test DB and seeding data...")
    async with async_engine.begin() as conn:
        await conn.run_sync(models.Base.metadata.drop_all)
        await conn.run_sync(models.Base.metadata.create_all)

    async with async_session_factory() as session:
        user_repo = UserRepository(session)
        existing_user = await user_repo.get_by_email(TEST_USER["email"])
        if not existing_user:
            user = UserModel(
                id="test-user-id",
                email=TEST_USER["email"],
                hashed_password=get_password_hash(TEST_USER["password"]),
                full_name=TEST_USER["full_name"],
                role=TEST_USER["role"],
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            session.add(user)
        else:
            user = existing_user

        template_repo = TemplateRepository(session)
        for template in TEST_TEMPLATES:
            await template_repo.create_template(
                name=template["name"],
                content=template["content"],
                description=template["description"],
                user_id=user.id
            )

        await session.commit()
    
            # --- Add existing message and task for tests that depend on them ---
        from app.db.repositories.messages import MessageRepository
        from datetime import timezone

        now = datetime.now(timezone.utc)
        message_repo = MessageRepository(session)


        await message_repo.create_message(
            phone_number="+1234567890",
            message_text="Test message seeded for unit tests",
            user_id=user.id,
            custom_id="existing-msg-id",
            metadata={}
        )


        # Create a batch using repository logic
        batch = await message_repo.create_batch(
            user_id=user.id,
            name="Test Batch",
            total=1  # One message in batch
        )
        # Override ID for the test that expects it
        batch.id = "existing-task-id"

        # Add a message linked to this batch
        await message_repo.create_message(
            phone_number="+1234567890",
            message_text="Hello from seeded batch",
            user_id=user.id,
            custom_id="msg-in-batch",
            metadata={"batch_id": batch.id}
        )

        await session.commit()

    print(f" Test DB seeded at {TEST_DATABASE_URL}")

@pytest_asyncio.fixture()
async def async_client() -> AsyncGenerator[AsyncClient, None]:
    from httpx import ASGITransport
    transport = ASGITransport(app=app)
    async with AsyncClient(base_url="http://testserver", transport=transport) as client:
        yield client

@pytest_asyncio.fixture()
async def db_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_factory() as session:
        yield session
</file>

<file path="app/db/repositories/messages.py">
"""
Message repository for database operations related to SMS messages.
"""
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any, Tuple
from uuid import uuid4

from sqlalchemy import select, update, delete, and_, or_, desc, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.dialects.postgresql import JSONB

from app.db.repositories.base import BaseRepository
from app.models.message import Message, MessageEvent, MessageBatch, MessageTemplate
from app.schemas.message import MessageCreate, MessageStatus


class MessageRepository(BaseRepository[Message, MessageCreate, Dict[str, Any]]):
    """Message repository for database operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize with session and Message model."""
        super().__init__(session=session, model=Message)
    
    async def create_message(
        self,
        *,
        phone_number: str,
        message_text: str,
        user_id: str,
        custom_id: Optional[str] = None,
        scheduled_at: Optional[datetime] = None,
        metadata: Optional[Dict[str, Any]] = None,
        batch_id: Optional[str] = None,
        campaign_id: Optional[str] = None
    ) -> Message:
        """
        Create a new message.
        
        Args:
            phone_number: Recipient phone number
            message_text: Message content
            user_id: User who is sending the message
            custom_id: Optional custom ID for tracking
            scheduled_at: Optional scheduled time
            metadata: Optional additional data
            batch_id: Optional batch ID
            campaign_id: Optional campaign ID
            
        Returns:
            Message: Created message
        """
        # Set initial status based on scheduling
        initial_status = MessageStatus.SCHEDULED if scheduled_at else MessageStatus.PENDING
        
        # Calculate SMS parts (simple calculation, can be improved)
        parts_count = (len(message_text) + 159) // 160  # 160 chars per SMS part, rounded up
        
        # Create message
        message = Message(
            custom_id=custom_id or str(uuid4()),
            phone_number=phone_number,
            message=message_text,
            status=initial_status,
            scheduled_at=scheduled_at,
            user_id=user_id,
            meta_data=metadata or {},  # Use meta_data instead of metadata
            parts_count=parts_count,
            batch_id=batch_id,
            campaign_id=campaign_id
        )
        
        self.session.add(message)
        await self.session.flush()
        
        # Create initial event
        event = MessageEvent(
            id=str(uuid4()),
            message_id=message.id,
            event_type="created",
            status=initial_status,
            data={
                "phone_number": phone_number,
                "scheduled_at": scheduled_at.isoformat() if scheduled_at else None,
                "campaign_id": campaign_id
            }
        )
        
        self.session.add(event)
        
        # If associated with campaign, increment total message count
        if campaign_id:
            # Get campaign
            from app.db.repositories.campaigns import CampaignRepository
            campaign_repo = CampaignRepository(self.session)
            campaign = await campaign_repo.get_by_id(campaign_id)
            
            if campaign:
                # Use existing campaign repository method to update total messages
                # This ensures all campaign updates go through the repository
                campaign.total_messages += 1
                self.session.add(campaign)
        
        await self.session.commit()
        await self.session.refresh(message)
        
        return message
    
    async def update_message_status(
        self,
        *,
        message_id: str,
        status: str,
        event_type: str,
        reason: Optional[str] = None,
        gateway_message_id: Optional[str] = None,
        data: Optional[Dict[str, Any]] = None
    ) -> Optional[Message]:
        """
        Update message status.
        
        Args:
            message_id: Message ID
            status: New status
            event_type: Event type triggering this update
            reason: Optional reason for status change
            gateway_message_id: Optional gateway message ID
            data: Optional additional data
            
        Returns:
            Message: Updated message or None
        """
        # Get the message
        message = await self.get_by_id(message_id)
        if not message:
            return None
        
        # Update status-specific timestamp
        now = datetime.now(timezone.utc)
        update_data = {
            "status": status,
            "updated_at": now,
        }
        
        if status == MessageStatus.SENT:
            update_data["sent_at"] = now
        elif status == MessageStatus.DELIVERED:
            update_data["delivered_at"] = now
        elif status == MessageStatus.FAILED:
            update_data["failed_at"] = now
            update_data["reason"] = reason
        
        # Set gateway message ID if provided
        if gateway_message_id:
            update_data["gateway_message_id"] = gateway_message_id
        
        # Update the message
        await self.session.execute(
            update(Message)
            .where(Message.id == message_id)
            .values(**update_data)
        )
        
        # Create event for status change
        event = MessageEvent(
            id=str(uuid4()),
            message_id=message_id,
            event_type=event_type,
            status=status,
            data=data or {}
        )
        
        self.session.add(event)
        await self.session.commit()
        
        # Refresh the message
        await self.session.refresh(message)
        
        return message

    async def create_batch(
        self,
        *,
        user_id: str,
        name: str,
        total: int
    ) -> MessageBatch:
        """
        Create a new message batch.
        
        Args:
            user_id: User ID
            name: Batch name
            total: Total number of messages
            
        Returns:
            MessageBatch: Created batch
        """
        batch = MessageBatch(
            id=str(uuid4()),
            name=name,
            total=total,
            processed=0,
            successful=0,
            failed=0,
            status=MessageStatus.PENDING,
            user_id=user_id
        )
        
        self.session.add(batch)
        await self.session.commit()
        await self.session.refresh(batch)
        
        return batch

    async def update_batch_progress(
        self,
        *,
        batch_id: str,
        increment_processed: int = 0,
        increment_successful: int = 0,
        increment_failed: int = 0,
        status: Optional[str] = None
    ) -> Optional[MessageBatch]:
        """
        Update batch progress.
        
        Args:
            batch_id: Batch ID
            increment_processed: Increment processed count
            increment_successful: Increment successful count
            increment_failed: Increment failed count
            status: Optional new status
            
        Returns:
            MessageBatch: Updated batch or None
        """
        batch = await self.get_by_id(batch_id)
        if not batch:
            return None
        
        # Update counts
        batch.processed += increment_processed
        batch.successful += increment_successful
        batch.failed += increment_failed
        
        # Update status if provided
        if status:
            batch.status = status
            
        # If all messages processed, update status and completion time
        if batch.processed >= batch.total:
            batch.status = MessageStatus.PROCESSED if batch.failed == 0 else "partial"
            batch.completed_at = datetime.now(timezone.utc)
        
        self.session.add(batch)
        await self.session.commit()
        await self.session.refresh(batch)
        
        return batch

    async def get_by_custom_id(self, custom_id: str) -> Optional[Message]:
        """
        Get message by custom ID.
        
        Args:
            custom_id: Custom ID
            
        Returns:
            Message: Found message or None
        """
        return await self.get_by_attribute("custom_id", custom_id)

    async def get_by_gateway_id(self, gateway_id: str) -> Optional[Message]:
        """
        Get message by gateway ID.
        
        Args:
            gateway_id: Gateway message ID
            
        Returns:
            Message: Found message or None
        """
        return await self.get_by_attribute("gateway_message_id", gateway_id)

    async def list_messages_for_user(
        self,
        *,
        user_id: str,
        status: Optional[str] = None,
        phone_number: Optional[str] = None,
        from_date: Optional[str] = None,
        to_date: Optional[str] = None,
        campaign_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Message], int]:
        """
        List messages for user with filtering.
        
        Args:
            user_id: User ID
            status: Optional status filter
            phone_number: Optional phone number filter
            from_date: Optional from date filter
            to_date: Optional to date filter
            campaign_id: Optional campaign ID filter
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Message], int]: List of messages and total count
        """
        # Base query
        query = select(Message).where(Message.user_id == user_id)
        count_query = select(func.count()).select_from(Message).where(Message.user_id == user_id)
        
        # Apply filters
        if status:
            query = query.where(Message.status == status)
            count_query = count_query.where(Message.status == status)
        
        if phone_number:
            query = query.where(Message.phone_number == phone_number)
            count_query = count_query.where(Message.phone_number == phone_number)

        if campaign_id:
            query = query.where(Message.campaign_id == campaign_id)
            count_query = count_query.where(Message.campaign_id == campaign_id)
        
        if from_date:
            try:
                from_date_obj = datetime.fromisoformat(from_date.replace('Z', '+00:00'))
                query = query.where(Message.created_at >= from_date_obj)
                count_query = count_query.where(Message.created_at >= from_date_obj)
            except ValueError:
                pass
        
        if to_date:
            try:
                to_date_obj = datetime.fromisoformat(to_date.replace('Z', '+00:00'))
                query = query.where(Message.created_at <= to_date_obj)
                count_query = count_query.where(Message.created_at <= to_date_obj)
            except ValueError:
                pass
        
        # Order by created_at desc
        query = query.order_by(desc(Message.created_at))
        
        # Pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await self.session.execute(query)
        count_result = await self.session.execute(count_query)
        
        messages = result.scalars().all()
        total = count_result.scalar_one()
        
        return messages, total

    async def get_messages_for_batch(
        self,
        *,
        batch_id: str,
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Message], int]:
        """
        Get messages for a batch.
        
        Args:
            batch_id: Batch ID
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Message], int]: List of messages and total count
        """
        # Base query
        query = select(Message).where(Message.batch_id == batch_id)
        count_query = select(func.count()).select_from(Message).where(Message.batch_id == batch_id)
        
        # Order by created_at desc
        query = query.order_by(desc(Message.created_at))
        
        # Pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await self.session.execute(query)
        count_result = await self.session.execute(count_query)
        
        messages = result.scalars().all()
        total = count_result.scalar_one()
        
        return messages, total
    
    async def get_messages_for_campaign(
        self,
        *,
        campaign_id: str,
        status: Optional[str] = None,
        skip: int = 0,
        limit: int = 20
    ) -> Tuple[List[Message], int]:
        """
        Get messages for a campaign.
        
        Args:
            campaign_id: Campaign ID
            status: Optional status filter
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            Tuple[List[Message], int]: List of messages and total count
        """
        # Base query
        query = select(Message).where(Message.campaign_id == campaign_id)
        count_query = select(func.count()).select_from(Message).where(Message.campaign_id == campaign_id)
        
        # Apply status filter
        if status:
            query = query.where(Message.status == status)
            count_query = count_query.where(Message.status == status)
        
        # Order by created_at desc
        query = query.order_by(desc(Message.created_at))
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await self.session.execute(query)
        count_result = await self.session.execute(count_query)
        
        messages = result.scalars().all()
        total = count_result.scalar_one()
        
        return messages, total

    async def get_retryable_messages(
        self,
        *,
        max_retries: int = 3,
        limit: int = 50
    ) -> List[Message]:
        """
        Get messages that can be retried.
        
        Args:
            max_retries: Maximum number of retry attempts
            limit: Maximum number of messages to return
            
        Returns:
            List[Message]: List of retryable messages
        """
        # Query for failed messages that can be retried
        query = select(Message).where(
            and_(
                Message.status == MessageStatus.FAILED,
                or_(
                    Message.meta_data.is_(None),  # No metadata at all
                    ~Message.meta_data.contains({"retry_count": 0}),  # retry_count key is absent
                    Message.meta_data["retry_count"].as_integer() < max_retries  # retry_count too low
                )
            )
        ).order_by(Message.failed_at).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
</file>

<file path="requirements.txt">
aiosqlite==0.21.0
alembic==1.15.2
android-sms-gateway==2.0.0
annotated-types==0.7.0
anyio==4.9.0
asgi-lifespan==2.1.0
asyncpg==0.30.0
bcrypt==4.3.0
certifi==2025.1.31
cffi==1.17.1
click==8.1.8
colorama==0.4.6
coverage==7.8.0
cryptography==44.0.2
dnspython==2.7.0
ecdsa==0.19.1
email_validator==2.2.0
fastapi==0.115.12
greenlet==3.2.1
h11==0.14.0
httpcore==1.0.8
httptools==0.6.4
httpx==0.28.1
idna==3.10
iniconfig==2.1.0
Mako==1.3.10
MarkupSafe==3.0.2
packaging==25.0
passlib==1.7.4
phonenumbers==9.0.3
pluggy==1.5.0
psycopg2-binary==2.9.10
pyasn1==0.4.8
pycparser==2.22
pydantic==2.11.3
pydantic-settings==2.9.1
pydantic_core==2.33.1
PyJWT==2.10.1
pytest==8.3.5
pytest-asyncio==0.26.0
pytest-cov==6.1.1
pytest-mock==3.14.0
python-dateutil==2.9.0.post0
python-dotenv==1.1.0
python-jose==3.4.0
python-multipart==0.0.20
pytz==2025.2
PyYAML==6.0.2
rsa==4.9.1
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.40
starlette==0.46.2
typing-inspection==0.4.0
typing_extensions==4.13.2
uvicorn==0.34.2
watchfiles==1.0.5
websockets==15.0.1
</file>

</files>
